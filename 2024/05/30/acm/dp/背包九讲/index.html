<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"crayonxinxin.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="背包九讲 背包问题是典型的线性dp问题  01背包题目大意有 N 件物品和一个容量为 V 的背包。放入第 i 件物品花费的容积是 c[i] ，得到的价值是 w[i] ，求将哪些物品装入背包可使价值总和最大。  特点：每种物品只有一种  定义状态 dp[i][j]表示前 i 件物品恰放入一个容量为 j 的背包可以获得的最大价值则状态转移方程为： dp[i][j] &#x3D; max(dp[i-1][j] ,">
<meta property="og:type" content="article">
<meta property="og:title" content="背包九讲">
<meta property="og:url" content="http://crayonxinxin.github.io/2024/05/30/acm/dp/%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="背包九讲 背包问题是典型的线性dp问题  01背包题目大意有 N 件物品和一个容量为 V 的背包。放入第 i 件物品花费的容积是 c[i] ，得到的价值是 w[i] ，求将哪些物品装入背包可使价值总和最大。  特点：每种物品只有一种  定义状态 dp[i][j]表示前 i 件物品恰放入一个容量为 j 的背包可以获得的最大价值则状态转移方程为： dp[i][j] &#x3D; max(dp[i-1][j] ,">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-05-30T13:59:40.000Z">
<meta property="article:modified_time" content="2024-05-30T14:03:13.399Z">
<meta property="article:author" content="Crayonxiaoxin">
<meta property="article:tag" content="acm">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://crayonxinxin.github.io/2024/05/30/acm/dp/%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>背包九讲 | Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags<span class="badge">10</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories<span class="badge">23</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">61</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://crayonxinxin.github.io/2024/05/30/acm/dp/%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/crayonxiaoxin.jpg">
      <meta itemprop="name" content="Crayonxiaoxin">
      <meta itemprop="description" content="成名在望">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          背包九讲
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-05-30 21:59:40 / Modified: 22:03:13" itemprop="dateCreated datePublished" datetime="2024-05-30T21:59:40+08:00">2024-05-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/acm/" itemprop="url" rel="index"><span itemprop="name">acm</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/acm/dp/" itemprop="url" rel="index"><span itemprop="name">dp</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>14k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>13 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="背包九讲"><a href="#背包九讲" class="headerlink" title="背包九讲"></a>背包九讲</h1><blockquote>
<p>背包问题是典型的线性dp问题</p>
</blockquote>
<h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>有 N 件物品和一个容量为 V 的背包。放入第 i 件物品花费的容积是 c[i] ，得到的价值是 w[i] ，求将哪些物品装入背包可使价值总和最大。</p>
<blockquote>
<p>特点：每种物品只有一种</p>
</blockquote>
<p>定义状态</p>
<p><code>dp[i][j]</code>表示前 i 件物品恰放入一个容量为 j 的背包可以获得的最大价值<br>则状态转移方程为：</p>
<p><code>dp[i][j] = max(dp[i-1][j] , dp[i-1][j-c[i]] + w[i]])</code></p>
<p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> c[maxn], w[maxn], dp[maxn][maxn];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, v;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        cin &gt;&gt; c[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        cin &gt;&gt; w[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= v;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(c[i]&lt;=j)&#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i - <span class="number">1</span>][j - c[i]] + w[i]);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; dp[n][v] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// std::ios::sync_with_stdio(false);</span></span><br><span class="line">    <span class="comment">// cin.tie(0);</span></span><br><span class="line">    <span class="comment">// cout.tie(0);</span></span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时的时间和空间复杂度均为Θ(<em>V</em>∗<em>N</em>) ,</p>
<h3 id="滚动数组"><a href="#滚动数组" class="headerlink" title="滚动数组"></a>滚动数组</h3><p>滚动数组是 dp 中最常用的空间优化技术</p>
<p>使用滚动数组，可以将 dp 的状态维度减少一维</p>
<p>从转移方程可以看出 <code>dp[i][j] = max(dp[i-1][j-v[i]]+w[i],dp[i-1][j])</code> 只与 <code>dp[i-1]</code>有关，和 <code>dp[i-2],dp[i-3]</code>… 都没有关系，所以我们只需要 <code>dp[i-1]</code> 就够了</p>
<h4 id="交替滚动"><a href="#交替滚动" class="headerlink" title="交替滚动"></a>交替滚动</h4><p>定义<code>dp[2][j]</code>，用<code>dp[1][j],dp[0][j]</code>交替滚动</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= v; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i &amp; <span class="number">1</span>][j] = dp[(i &amp; <span class="number">1</span>) ^ <span class="number">1</span>][j];</span><br><span class="line">        <span class="comment">// 如果当前物品的体积大于当前的容量，显然不能放入</span></span><br><span class="line">        <span class="keyword">if</span> (c[i] &lt;= j)</span><br><span class="line">            dp[i &amp; <span class="number">1</span>][j] = <span class="built_in">max</span>(dp[i &amp; <span class="number">1</span>][j], dp[(i &amp; <span class="number">1</span>) ^ <span class="number">1</span>][j - c[i]] + w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="自我滚动"><a href="#自我滚动" class="headerlink" title="自我滚动"></a>自我滚动</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 逆序！！！</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (c[i] &lt;= j)</span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j], dp[j - c[i]] + w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>循环 j 的时候记得反过来</strong></p>
<h3 id="初始化问题"><a href="#初始化问题" class="headerlink" title="初始化问题"></a>初始化问题</h3><p>我们看到的求最优解的背包问题题目中，事实上有两种不太相同的问法。</p>
<p>有的题目要求“<strong>恰好装满背包</strong>”时的最优解，有的题目则并没有要求必须把背包装满。一种区别这两种问法的实现方法是在初始化的时候有所不同。</p>
<p>如果是第一种问法，要求恰好装满背包，那么在初始化时除了 <code>dp[0]</code> 为 0，其 它 <code>dp[1...v]</code> 均设为 <code>−∞</code>，这样就可以保证最终得到的 <code>dp[v]</code> 是一种恰好装满背包的 最优解。</p>
<p>如果并没有要求必须把背包装满，而是只希望价格尽量大，初始化时应该 将 <code>dp[0...V]</code>全部设为 0 。</p>
<p>这是为什么呢？可以这样理解：初始化的 F 数组事实上就是在没有任何物品可以放入背包时的合法状态。如果要求背包恰好装满，那么此时只有容量为 0 的背包可以在什么也不装且价值为 0 的情况下被“恰好装满”，其它容量的背包均没有合法的解，属于未定义的状态，应该被赋值为 <code>−∞ </code>了。如果背包并非必须被装满，那么任何容量的背包都有一个合法解“什么都不装”，这个解的价值为 0 ，所以初始时状态的值也就全部为 0 了。</p>
<p>这个小技巧完全可以推广到其它类型的背包问题，后面也就不再对进行状态转移之前的初始化进行讲解。</p>
<h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h3><p>有N 种物品和一个容量为V 的背包，每种物品都有无限件可用。第 i 种物品的费用是c [ i ] ，价值是w [ i ]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这种问题类似于01背包，不同的是每件物品有无限件，而01背包每件物品只有一件。状态方程仍然可以按照01背包时的思路，令<code>dp[i][j]</code>表示前 i 种物品放入一个容量为 j 的背包的最大权值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j]=<span class="built_in">max</span>(dp[i−<span class="number">1</span>][j−k∗c[i]]+k∗w[i])   ∣   <span class="number">0</span>≤k∗c[i]≤j</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="comment">//第i件物品</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = c[i]; j &lt;= V; j++)<span class="comment">//背包体积</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k * c[i] &lt;= j; k++)<span class="comment">//决策数</span></span><br><span class="line">				dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i - <span class="number">1</span>][j - k * c[i]] + k * w[i]);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">for 物品</span></span><br><span class="line"><span class="comment">    for 体积</span></span><br><span class="line"><span class="comment">        for 决策</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>注意取 max 时与01背包不同</strong>，max 的第一个参数不再是<code>dp[i-1][j]</code>，因为<code>dp[i][j]</code>要在取多件的情况中取最值； 当 k &#x3D; 0时，<code>dp[i-1][j - k*c[i]] + k*w[i]</code>就相当于<code>dp[i-1][j]</code>，也就是这件物品一件也不取的情况</p>
<p>时间复杂度为<code>Θ(N ∗ Σ(V/c[i]))</code></p>
<h2 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h2><h3 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h3><p>有 N 种物品和一个容量为 V 的背包。第 i 种物品最多有 p [ i ] 件可用，每件费用是c [ i ] ，价值是w [ i ] 。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>对于第 i 种物品有 <code>p[i]+1</code>种策略：取<code>0...p[i]</code>件，令<code>dp[i][j]</code>表示前 i 种物品恰放入一个容量为 j 的背包的最大价值，则有状态转移方程</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j]=<span class="built_in">max</span>(dp[i−<span class="number">1</span>][j−k∗c[i]]+k∗w[i]) ∣     <span class="number">0</span>≤k≤p[i]</span><br></pre></td></tr></table></figure>

<h3 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> dp[maxn], c[maxn], w[maxn], p[maxn];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        cin &gt;&gt; c[i] &gt;&gt; w[i] &gt;&gt; p[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k * c[i] &lt;= j &amp;&amp; k &lt;= p[i]; ++k)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j], dp[j - c[i] * k] + w[i] * k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        res = <span class="built_in">max</span>(res, dp[i]);</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// std::ios::sync_with_stdio(false);</span></span><br><span class="line">    <span class="comment">// cin.tie(0);</span></span><br><span class="line">    <span class="comment">// cout.tie(0);</span></span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度</strong>: O( 物品数 × 背包的体积 × 选法) </p>
<h3 id="二进制优化法"><a href="#二进制优化法" class="headerlink" title="二进制优化法"></a>二进制优化法</h3><blockquote>
<p>本质： 将多重背包转化为 01背包问题</p>
</blockquote>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>暴力法实质上是把多重背包中的每个物品都分成了 p 件，我们可以通过其他分法，可以通过选这些物品，选几个来表示选 s 个的所有可能</p>
<p>这时候就想到了二进制，因为任何实数都可以由二进制数组成。</p>
<p>那么我们就可以把一个物品拆成 $ 2^0 ，2^1 , 2^2 , …… , 2^k , (x-2^{k+1}+1)$ ( k 为最大的  $2^i$ 总和不大于 x 的实数，$log_x$ 个物品</p>
<p>这些物品可以通过组合，组成 0 - x 内的整数（不能漏不能多）</p>
<h4 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h4><p>设一个实数 x ， 拆分成 $ 2^0 ，2^1 , 2^2 , …… , 2^k ,c$ ，因 ( k 为最大的  $2^i$ 总和不大于 x 的实数)为 k 是最大的 $2^k$ 不大于 x 的实数，所以可以知道 c  &lt; $2^{k+1}$</p>
<p>根据二进制可知 0 到 ($2^{k+1}-1$)都可以用以上的数组成</p>
<p>因为 $2^{k+1}-1+c$为可以凑到的最大值，所以$2^{k+1}-1+c&#x3D;p &#x3D;&gt; p-(2^{k+1}-1)$</p>
<p>现在已知$0-(2^{k+1}-1)$ 和$c-p$ 两端都可以由以上数拼接起来，现在问题就是，这两段合在一起的时候，中间有无空缺。</p>
<p>如果有空缺的话，$c&gt;2^{k+1}-1$ 即 $c\ge2^{k+1}$</p>
<p>显然与开始得到的 $c&lt;2^{k+1}$相矛盾，可得0-p中的任何一个数都可以拼接起来</p>
<p><strong>时间复杂度</strong>：O$( 物品数 \times 背包的体积 \times log 选法) $&#x3D; O$(N \times V \times logP)$</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/5/">多重背包问题 ||</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> c[maxn], w[maxn], p[maxn], dp[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> c, w;</span><br><span class="line">&#125; good[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        cin &gt;&gt; c[i] &gt;&gt; w[i] &gt;&gt; p[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 分成2^k次方的时候</span></span><br><span class="line">        <span class="comment">// 新物品的体积和价值 = 选的个数 *单个的体积和价格</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> z = <span class="number">1</span>; z &lt;= p[i]; z *= <span class="number">2</span>, ++cnt)</span><br><span class="line">        &#123;</span><br><span class="line">            good[cnt].c = z * c[i];</span><br><span class="line">            good[cnt].w = z * w[i];</span><br><span class="line">            p[i] -= z;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p[i] &gt; <span class="number">0</span>)<span class="comment">//最后一个物品</span></span><br><span class="line">        &#123;</span><br><span class="line">            good[cnt].c = p[i] * c[i];</span><br><span class="line">            good[cnt++].w = p[i] * w[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//变成了01背包</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; cnt;++j)<span class="comment">//遍历选法</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = m; k &gt;= good[j].c;k--)<span class="comment">//遍历体积，由于是滚动一维，所以要逆序遍历</span></span><br><span class="line">            &#123;</span><br><span class="line">                dp[k]=<span class="built_in">max</span>(dp[k],dp[k-good[j].c]+good[j].w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; dp[m] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// std::ios::sync_with_stdio(false);</span></span><br><span class="line">    <span class="comment">// cin.tie(0);</span></span><br><span class="line">    <span class="comment">// cout.tie(0);</span></span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单调队列优化法"><a href="#单调队列优化法" class="headerlink" title="单调队列优化法"></a>单调队列优化法</h3><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>转移方程<code>dp[i][j] = max(dp[i-1][j], dp[i-1][j-k*c[i]] + k*w[i])</code></p>
<p>单调队列优化的主要思想就是<strong>分组更新</strong>，因为<code>w[i]</code>是成倍增加的，<code>dp[i-1][j]</code>只会更新<code>dp[i-1][j+k*w[i]]</code>(这里是从前往后看的，所以是+)</p>
<p>对于当前为 w 的体积，我们可以按照余数将它分为 w 组，也就是0… w−1同一个剩余系的数在一组<br>比如在模 3 意义下，1 , 4 , 7 , 10 是一组，2 , 5 , 8 , 11 是一组，3 , 6 , 9 , 12 是一组<br>每组的转移是互不影响的，也就是单独转移</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20005</span>;</span><br><span class="line"><span class="comment">// pre存储i - 1的时候的值</span></span><br><span class="line"><span class="comment">// q为偏移量为?时候的单调队列</span></span><br><span class="line"><span class="type">int</span> dp[N], pre[N], q[N], n, m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//n为物品的总数，背包容量为m</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v, w, s;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;v, &amp;w, &amp;s);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//赋值上一层结果</span></span><br><span class="line">        <span class="built_in">memcpy</span>(pre, dp, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//枚举偏移量(起点)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//建新的单调队列 头&gt;&gt;&gt;尾巴，里面存的是体积</span></span><br><span class="line">            <span class="type">int</span> head = <span class="number">0</span>, tail = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//更新该起点代表的行,k是此时的体积</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt;= m; k += v)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//判断窗格是否超过了k,头需要往后滑动</span></span><br><span class="line">                <span class="keyword">if</span> (head &lt;= tail &amp;&amp; k - q[head] &gt; s * v)</span><br><span class="line">                    head++;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//赋值</span></span><br><span class="line">                <span class="comment">//pre[q[head]]+(k - q[head]) / v * w)：前i-1个中选，且体积不大于q[head]的最大价值 + 第i个物品选(k - q[head]) / v 个的价值</span></span><br><span class="line">                <span class="keyword">if</span> (head &lt;= tail)</span><br><span class="line">                    dp[k] = <span class="built_in">max</span>(dp[k], pre[q[head]] + (k - q[head]) / v * w);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//队列中加入k,并且维护队列单调性</span></span><br><span class="line">                <span class="comment">//pre[k]：前i-1个中选，且体积不大于q[head]的最大价值 + 第i个物品选0个</span></span><br><span class="line">                <span class="comment">//pre[q[tail]] + (k - q[tail]) / v * w ：前i-1个中选，且体积不大于q[tail]的最大价值 + 第i个物品选(k - q[tail]) / v个</span></span><br><span class="line">                <span class="keyword">while</span> (head &lt;= tail &amp;&amp; pre[q[tail]] + (k - q[tail]) / v * w &lt; pre[k])</span><br><span class="line">                    tail--;</span><br><span class="line">                q[++tail] = k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, dp[m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="http://acm.sztu.edu.cn/csgoj/problemset/problem?pid=1538">演唱会 SOJ1538</a></p>
<h2 id="混合多种背包问题"><a href="#混合多种背包问题" class="headerlink" title="混合多种背包问题"></a>混合多种背包问题</h2><h3 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h3><p>将前面三个背包混合起来，也就是说，有的物品只可以取一次（01背包），有的物品可以取无限次（完全背包），有的物品可以取的次数有一个上限（多重背包）</p>
<h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>当前物品的选法，和相应的更新值，和之前的物品类型无关。所以每次判断当前物品的类型，选择对应的转移方程来进行转移就可以了。</p>
<h2 id="二维费用背包问题"><a href="#二维费用背包问题" class="headerlink" title="二维费用背包问题"></a>二维费用背包问题</h2><h3 id="题目大意-4"><a href="#题目大意-4" class="headerlink" title="题目大意"></a>题目大意</h3><p>二维费用的背包问题是指：对于每件物品，具有两种不同的费用；选择这件物品必须同时付出这两种代价；对于每种代价都有一个可付出的最大值（背包容量）。问怎样选择物品可以得到最大的价值</p>
<p><strong>P1507 NASA的食物计划</strong></p>
<p>航天飞机的体积有限，当然如果载过重的物品，燃料会浪费很多钱，每件食品都有各自的体积、质量以及所含卡路里。在告诉你体积和质量的最大值的情况下，请输出能达到的食品方案所含卡路里的最大值，当然每个食品只能使用一次。</p>
<h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>状态定义：</p>
<p>现在不仅仅是对体积有限制，还对质量有限制，因此我们在选择一个物品时还应该在意当前的质量，所以需要在01背包的基础上再加一个维度</p>
<p>定义<code>dp[i][j][k]</code>为遍历到第 i 个物品，当前体积不超过 j ，质量不超过 k 获得的最大卡路里值</p>
<p>转移方程</p>
<p><code>dp[i][j][k]=max(dp[i−1][j][k],dp[i−1][j−c[i]][k−g[i]]+w[i])</code></p>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">55</span>, M = <span class="number">4e2</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> h1[N], t1[N], k1[N];</span><br><span class="line"><span class="type">int</span> f[N][M][M];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> h, t, n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;h, &amp;t, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;h1[i], &amp;t1[i], &amp;k1[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i][<span class="number">0</span>][<span class="number">0</span>] = f[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= h; j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= t; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                f[i][j][k] = f[i - <span class="number">1</span>][j][k];</span><br><span class="line">                <span class="keyword">if</span> (h1[i] &lt;= j &amp;&amp; t1[i] &lt;= k)</span><br><span class="line">                &#123;</span><br><span class="line">                    f[i][j][k] = <span class="built_in">max</span>(f[i][j][k], f[i - <span class="number">1</span>][j - h1[i]][k - t1[i]] + k1[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[n][h][t]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="物品总个数的限制"><a href="#物品总个数的限制" class="headerlink" title="物品总个数的限制"></a>物品总个数的限制</h3><p>有时,”二维费用” 的条件是以这样一种隐含的方式给出的：最多只能取 U 件物品。这事实上相等于每件物品多了一种 “件数” 的费用，每个物品的件数费用均为 1 ，可以付出的最大件数费用为 U </p>
<h2 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h2><h3 id="题目大意-5"><a href="#题目大意-5" class="headerlink" title="题目大意"></a>题目大意</h3><p>有 N 件物品和一个容量为 V 的背包。第i ii件物品的费用是 c [ i ] ，价值是 w [ i ] 。这些物品被划分为若干组，每组中的物品互相冲突，最多选一件。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。</p>
<h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><p>将同一组的物品整合起来，称为一个大物品，那么问题就变成了若干个大物品中，每个可以选择其中的一个物品，求总费用不超过限制的价值最大值是多少？</p>
<p>其实可以发现，这个非常的类似多重背包。</p>
<p>定义<code>f[k][j]</code>为遍历到第 k 个大物品，当前体积不超过 j 的价值最大值</p>
<p><code>f[k][j] = max(f[k-1][j] , f[k-1][j-c[i]]+w[i]) </code>   物品 i $\subseteq $组别 k</p>
<h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1005</span>;</span><br><span class="line"><span class="type">int</span> dp[N][N], q[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> wei, val;</span><br><span class="line">    <span class="built_in">node</span>(<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">    &#123;</span><br><span class="line">        wei = a, val = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;node&gt; ve[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;m, &amp;n);</span><br><span class="line">    <span class="type">int</span> we = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        ve[c].<span class="built_in">push_back</span>(<span class="built_in">node</span>(a, b));</span><br><span class="line">        we = <span class="built_in">max</span>(we, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= we; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++)</span><br><span class="line">            dp[i][j] = <span class="number">-1e9</span>;</span><br><span class="line"></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= we; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 遍历体积</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 遍历决策</span></span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; ve[i].<span class="built_in">size</span>(); k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (ve[i][k].wei &lt;= j)</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i - <span class="number">1</span>][j - ve[i][k].wei] + ve[i][k].val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; i++)</span><br><span class="line">        res = <span class="built_in">max</span>(res, dp[we][i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="有依赖的背包问题"><a href="#有依赖的背包问题" class="headerlink" title="有依赖的背包问题"></a>有依赖的背包问题</h2><blockquote>
<p>这种背包问题的物品间存在某种“依赖”的关系。也就是说，i 依赖于 j ，表示若选物品 i ，则必须选物品 j 。</p>
</blockquote>
<p>比如：</p>
<p><del>要求你加入集训队试训前，一定要刷完专题</del></p>
<h3 id="题目大意-6"><a href="#题目大意-6" class="headerlink" title="题目大意"></a>题目大意</h3><p>给出每个物品的价格和重要度和是否是主件或者说是谁的附件，求最后选出的每件物品的价格与重要度乘积和的最大值，每个附件不再有附件。</p>
<p>P1064 [NOIP2006 提高组] 金明的预算方案</p>
<table>
<thead>
<tr>
<th>主件</th>
<th>附 件</th>
</tr>
</thead>
<tbody><tr>
<td>电脑</td>
<td>打印机，扫描仪</td>
</tr>
<tr>
<td>书柜</td>
<td>图书</td>
</tr>
<tr>
<td>书桌</td>
<td>台灯，文具</td>
</tr>
<tr>
<td>工作椅</td>
<td>无</td>
</tr>
</tbody></table>
<p>一个主件和它的附件集合是几乎对于分组背包中的一个物品组。</p>
<p>每个选择了主件又选择了若干附件的策略，对应这个物品组的中的一个物品。</p>
<h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><p>我们可以将每个主件选附件的问题看成一个01背包问题，这样当我们知道给一个主件分配多少价钱的时候，就可以知道此时这个主件及其附件在对应的价钱可以获得的最大价值</p>
<h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">4e3</span> + <span class="number">5</span>, M = <span class="number">65</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ve[M];</span><br><span class="line"><span class="type">int</span> wei[M], imp[M];<span class="comment">//价格和重要度</span></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> dp[M][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;m, &amp;n);</span><br><span class="line">    m /= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;wei[i], &amp;imp[i], &amp;c);</span><br><span class="line">        wei[i] /= <span class="number">10</span>;</span><br><span class="line">        ve[c].<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先处理给出每个主件分配不同空间时对应获得的最大价值</span></span><br><span class="line">    <span class="comment">//  遍历各主件</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">1</span>; u &lt;= n; u++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 01背包问题----(这里滚动了变成了一个维数组)</span></span><br><span class="line">        <span class="comment">// dp[u][j] 表示第 u 个背包，分配 j 体积 可以获得的最大价值</span></span><br><span class="line">        <span class="comment">//  遍历附件（物品数量)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; ve[u].<span class="built_in">size</span>(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> to = ve[u][j];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = m; k &gt;= wei[to]; k--)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[u][k] = <span class="built_in">max</span>(dp[u][k], dp[u][k - wei[to]] + imp[to] * wei[to] * <span class="number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 整合</span></span><br><span class="line">    <span class="comment">// 遍历主件</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ve[<span class="number">0</span>].<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> to = ve[<span class="number">0</span>][i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= wei[to]; j--)<span class="comment">//逆序！</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 遍历给当前主件的附件分配的空间</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = j - wei[to]; k &gt;= <span class="number">0</span>; k--)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[<span class="number">0</span>][j] = <span class="built_in">max</span>(dp[<span class="number">0</span>][j], dp[to][k] + imp[to] * wei[to] * <span class="number">10</span> + dp[<span class="number">0</span>][j - k - wei[to]]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dp[<span class="number">0</span>][m]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="较一般的题目"><a href="#较一般的题目" class="headerlink" title="较一般的题目"></a>较一般的题目</h3><p>依赖关系以图论中的 “森林” 形式给出，也就是说主件的附件依旧可以有自己的附件集合。</p>
<p>刚刚那道题可以直接那么做，主要是因为附件没有附件，如果还有附件的话，就需要继续先计算出附件在面对各价格时可获得的最大值才可以。</p>
<p>这种背包就是 <strong>树形背包</strong> （树形dp的一种），它的特点是每个父节点都需要对它的各个儿子的属性进行一次 dp 来求得自己相关的属性。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">4e3</span> + <span class="number">5</span>, M = <span class="number">65</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ve[M];</span><br><span class="line"><span class="type">int</span> wei[M], imp[M];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> dp[M][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//枚举物品</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ve[u].<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> to = ve[u][i];</span><br><span class="line">        <span class="built_in">dfs</span>(to);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//枚举分给当前物品的体积</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = j; k &gt;= <span class="number">0</span>; k--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (k - wei[to] &gt;= <span class="number">0</span>)</span><br><span class="line">                    dp[u][j] = <span class="built_in">max</span>(dp[u][j], dp[u][j - k] + dp[to][k - wei[to]] + imp[to] * wei[to] * <span class="number">10</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;m, &amp;n);</span><br><span class="line">    m /= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;wei[i], &amp;imp[i], &amp;c);</span><br><span class="line">        wei[i] /= <span class="number">10</span>;</span><br><span class="line">        ve[c].<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    res = dp[<span class="number">0</span>][m];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="背包问题的变化"><a href="#背包问题的变化" class="headerlink" title="背包问题的变化"></a>背包问题的变化</h2><h3 id="输出方案"><a href="#输出方案" class="headerlink" title="输出方案"></a>输出方案</h3><p>一般而言，背包问题是要求一个最优值，如果要求输出这个最优值的方案，可以参照一般动态规划问题输出方案的方法: 记录下每个状态的最优质是由状态转移方程的哪一项推出来的。然后就可以根据这个状态继续往前推导。</p>
<h4 id="题目大意-7"><a href="#题目大意-7" class="headerlink" title="题目大意"></a>题目大意</h4><p>01背包问题，但是要求输出 <strong>字典序最小的方案数</strong> 。</p>
<h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h4><p>求具体方案其实就是判断每个物品是否被选，求方案其实就是从<code>dp[n][m]</code>倒推出来每一个 i 是否选择</p>
<p>需要根据转移方程来判断是否选择第 i 个物品，所以不能滚动。</p>
<p>这里要求字典序最小，所以采用贪心的策略</p>
<p>然后对于每一个物品来说可能有三种情况</p>
<ul>
<li>只能选 —— 必选</li>
<li>只能不选 —— 必不选</li>
<li>可选可不选 —— 一定要选</li>
</ul>
<p>显然求字典序最小的时候，我们需要优先考虑编号小的物品，但是找方案的时候，又是从 <code>dp[n][m] </code> 开始回推的，所以我们在求解 01 背包的时候，从后往前推，就可以从 <code>dp[1][m]</code>始往前推了，这样的话，就和求字典序最小的顺序一致了。</p>
<h4 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> dp[maxn][maxn], n, m, w[maxn], c[maxn];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n;++i)</span><br><span class="line">        cin &gt;&gt; c[i] &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>;--i)<span class="comment">//逆序，使得编号小的可以从编号大的推算而出</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][j] = dp[i + <span class="number">1</span>][j];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(j&gt;=c[i])</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i + <span class="number">1</span>][j - c[i]] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> j = m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j-c[i]&gt;=<span class="number">0</span>&amp;&amp;dp[i][j]==dp[i+<span class="number">1</span>][j-c[i]]+w[i])<span class="comment">//分治</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">            j -= c[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//std::ios::sync_with_stdio(false);</span></span><br><span class="line"><span class="comment">//cin.tie(0);</span></span><br><span class="line"><span class="comment">//cout.tie(0);</span></span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="求第K优解"><a href="#求第K优解" class="headerlink" title="求第K优解"></a>求第K优解</h3><h4 id="题目大意-8"><a href="#题目大意-8" class="headerlink" title="题目大意"></a>题目大意</h4><p>01背包问题，但是需要输出的是可以获得的第 K 大价值。</p>
<h4 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h4><p>我们需要得到的是第 K 大价值，所以当我们得到一个当前为 K+1 大的价值时，就直接舍去。因为它一定不是第 K 大价值，然后我们又需要得到目前得到的 K 个价值具体是多少，所以我们在原来01背包的基础上再加一维</p>
<p>定义<code>dp[i][j][k]</code>: 遍历到第 i 个物品，且体积不超过 j 可得到的第 k 大价值</p>
<p>为了方便，滚动数组优化掉第一个维度，即状态变成<code>dp[i][j]</code>：体积不超过 i 时可以得到的第 j 大价值是多少</p>
<p>01背包的状态转移方程:<code>dp[i][j] = max(dp[i-1][j], dp[i-1][j-c[i]]+w[i])</code></p>
<p>划分了当前选和不选，显然这里的选择会影响到当前状态的 k 个最大值</p>
<p>所以我们取出这两种选法对应的 2*k 个数，排序成新的 k 个最大数</p>
<h4 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">1005</span>][<span class="number">35</span>], wei[<span class="number">105</span>], val[<span class="number">105</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="type">int</span> n, v, k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;v, &amp;k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;val[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;wei[i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= v; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= k; j++)</span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = v; j &gt;= wei[i]; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//a数组记录的是不选第 i 个物品的 k 个最大价值</span></span><br><span class="line">                <span class="comment">//b数组记录的是选第 i 个物品的 k 个最大价值</span></span><br><span class="line">                <span class="type">int</span> a[<span class="number">35</span>] = &#123;<span class="number">0</span>&#125;, b[<span class="number">35</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>; l &lt;= k; l++)</span><br><span class="line">                &#123;</span><br><span class="line">                    a[l] = dp[j][l];</span><br><span class="line">                    b[l] = dp[j - wei[i]][l] + val[i];</span><br><span class="line">                &#125;</span><br><span class="line">                a[k + <span class="number">1</span>] = b[k + <span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> ai = <span class="number">1</span>, bi = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>; l &lt;= k &amp;&amp; (a[ai] != <span class="number">-1</span> || b[bi] != <span class="number">-1</span>); l++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (a[ai] &gt; b[bi])</span><br><span class="line">                        dp[j][l] = a[ai++];</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        dp[j][l] = b[bi++];</span><br><span class="line">                    <span class="comment">//相同的数算同一个</span></span><br><span class="line">                    <span class="keyword">if</span> (dp[j][l] == dp[j][l - <span class="number">1</span>])</span><br><span class="line">                        l--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dp[v][k]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>序号</th>
<th>题号</th>
<th>标题</th>
<th>题目类型</th>
<th>难度评级</th>
<th>题解</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>HDU 2602</td>
<td>Bone collector</td>
<td>01背包</td>
<td>⭐</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>P1060</td>
<td>开心的金明</td>
<td>01背包</td>
<td>⭐</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>P2871</td>
<td>Charm Bracelet S</td>
<td>01背包</td>
<td>⭐</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>P1156</td>
<td>垃圾陷阱</td>
<td>01背包</td>
<td>⭐⭐</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>POJ 1276</td>
<td>Cash Machine</td>
<td>多重背包</td>
<td>⭐</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>POJ 1014</td>
<td>Dividing</td>
<td>多重背包</td>
<td>⭐</td>
<td></td>
</tr>
<tr>
<td>7</td>
<td>P5365</td>
<td>英雄联盟</td>
<td>多重背包</td>
<td>⭐⭐</td>
<td></td>
</tr>
<tr>
<td>8</td>
<td>P1776</td>
<td>宝物筛选</td>
<td>多重背包</td>
<td>⭐⭐</td>
<td></td>
</tr>
<tr>
<td>9</td>
<td>P1853</td>
<td>投资的最大效益</td>
<td>多重背包</td>
<td>⭐⭐</td>
<td></td>
</tr>
<tr>
<td>10</td>
<td>P1782</td>
<td>旅行商的背包</td>
<td>混合背包</td>
<td>⭐⭐</td>
<td></td>
</tr>
<tr>
<td>11</td>
<td>P2851</td>
<td>The Fewest Coins G</td>
<td>混合背包</td>
<td>⭐⭐⭐</td>
<td></td>
</tr>
<tr>
<td>12</td>
<td>P1833</td>
<td>樱花</td>
<td>混合背包</td>
<td>⭐⭐</td>
<td></td>
</tr>
<tr>
<td>13</td>
<td>P1507</td>
<td>NASA的食物计划</td>
<td>二维费用背包</td>
<td>⭐</td>
<td></td>
</tr>
<tr>
<td>14</td>
<td>HDU 1712</td>
<td>ACboy needs your help</td>
<td>分组背包</td>
<td>⭐</td>
<td></td>
</tr>
<tr>
<td>15</td>
<td>P1757</td>
<td>通天之分组背包</td>
<td>分组背包</td>
<td>⭐</td>
<td></td>
</tr>
<tr>
<td>16</td>
<td>P1064</td>
<td>金明的预算方案</td>
<td>有依赖背包</td>
<td>⭐⭐</td>
<td></td>
</tr>
<tr>
<td>17</td>
<td>P3961</td>
<td>黄金矿工</td>
<td>有依赖背包</td>
<td>⭐⭐⭐</td>
<td></td>
</tr>
<tr>
<td>18</td>
<td>POJ 1015</td>
<td>Jury Compromise</td>
<td>01背包+输出具体方案</td>
<td>⭐⭐⭐</td>
<td></td>
</tr>
<tr>
<td>19</td>
<td>HDU 2639</td>
<td>Bone Collector  ||</td>
<td>求第 k 优解</td>
<td>⭐⭐</td>
<td></td>
</tr>
<tr>
<td>20</td>
<td>P1858</td>
<td>多人背包</td>
<td>求第 k 优解</td>
<td>⭐⭐</td>
<td></td>
</tr>
</tbody></table>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/acm/" rel="tag"># acm</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/05/30/git/" rel="prev" title="git">
      <i class="fa fa-chevron-left"></i> git
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/05/30/acm/dp/%E6%A6%82%E7%8E%87dp/" rel="next" title="概率dp">
      概率dp <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2"><span class="nav-number">1.</span> <span class="nav-text">背包九讲</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#01%E8%83%8C%E5%8C%85"><span class="nav-number">1.1.</span> <span class="nav-text">01背包</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E5%A4%A7%E6%84%8F"><span class="nav-number">1.1.1.</span> <span class="nav-text">题目大意</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84"><span class="nav-number">1.1.2.</span> <span class="nav-text">滚动数组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%A4%E6%9B%BF%E6%BB%9A%E5%8A%A8"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">交替滚动</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E6%88%91%E6%BB%9A%E5%8A%A8"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">自我滚动</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E9%97%AE%E9%A2%98"><span class="nav-number">1.1.3.</span> <span class="nav-text">初始化问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85"><span class="nav-number">1.2.</span> <span class="nav-text">完全背包</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E5%A4%A7%E6%84%8F-1"><span class="nav-number">1.2.1.</span> <span class="nav-text">题目大意</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF"><span class="nav-number">1.2.2.</span> <span class="nav-text">思路</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85"><span class="nav-number">1.3.</span> <span class="nav-text">多重背包</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E5%A4%A7%E6%84%8F-2"><span class="nav-number">1.3.1.</span> <span class="nav-text">题目大意</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-1"><span class="nav-number">1.3.2.</span> <span class="nav-text">思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9A%B4%E5%8A%9B%E6%B3%95"><span class="nav-number">1.3.3.</span> <span class="nav-text">暴力法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BC%98%E5%8C%96%E6%B3%95"><span class="nav-number">1.3.4.</span> <span class="nav-text">二进制优化法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-2"><span class="nav-number">1.3.4.1.</span> <span class="nav-text">思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%81%E6%98%8E"><span class="nav-number">1.3.4.2.</span> <span class="nav-text">证明</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96%E6%B3%95"><span class="nav-number">1.3.5.</span> <span class="nav-text">单调队列优化法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-3"><span class="nav-number">1.3.5.1.</span> <span class="nav-text">思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.3.5.2.</span> <span class="nav-text">实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%B7%E5%90%88%E5%A4%9A%E7%A7%8D%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="nav-number">1.4.</span> <span class="nav-text">混合多种背包问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E5%A4%A7%E6%84%8F-3"><span class="nav-number">1.4.1.</span> <span class="nav-text">题目大意</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-4"><span class="nav-number">1.4.2.</span> <span class="nav-text">思路</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E7%BB%B4%E8%B4%B9%E7%94%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="nav-number">1.5.</span> <span class="nav-text">二维费用背包问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E5%A4%A7%E6%84%8F-4"><span class="nav-number">1.5.1.</span> <span class="nav-text">题目大意</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-5"><span class="nav-number">1.5.2.</span> <span class="nav-text">思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-1"><span class="nav-number">1.5.3.</span> <span class="nav-text">实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%A9%E5%93%81%E6%80%BB%E4%B8%AA%E6%95%B0%E7%9A%84%E9%99%90%E5%88%B6"><span class="nav-number">1.5.4.</span> <span class="nav-text">物品总个数的限制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85"><span class="nav-number">1.6.</span> <span class="nav-text">分组背包</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E5%A4%A7%E6%84%8F-5"><span class="nav-number">1.6.1.</span> <span class="nav-text">题目大意</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-6"><span class="nav-number">1.6.2.</span> <span class="nav-text">思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-2"><span class="nav-number">1.6.3.</span> <span class="nav-text">实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%89%E4%BE%9D%E8%B5%96%E7%9A%84%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="nav-number">1.7.</span> <span class="nav-text">有依赖的背包问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E5%A4%A7%E6%84%8F-6"><span class="nav-number">1.7.1.</span> <span class="nav-text">题目大意</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-7"><span class="nav-number">1.7.2.</span> <span class="nav-text">思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-3"><span class="nav-number">1.7.3.</span> <span class="nav-text">实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%83%E4%B8%80%E8%88%AC%E7%9A%84%E9%A2%98%E7%9B%AE"><span class="nav-number">1.7.4.</span> <span class="nav-text">较一般的题目</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%9A%84%E5%8F%98%E5%8C%96"><span class="nav-number">1.8.</span> <span class="nav-text">背包问题的变化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%93%E5%87%BA%E6%96%B9%E6%A1%88"><span class="nav-number">1.8.1.</span> <span class="nav-text">输出方案</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E5%A4%A7%E6%84%8F-7"><span class="nav-number">1.8.1.1.</span> <span class="nav-text">题目大意</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-8"><span class="nav-number">1.8.1.2.</span> <span class="nav-text">思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-4"><span class="nav-number">1.8.1.3.</span> <span class="nav-text">实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B1%82%E7%AC%ACK%E4%BC%98%E8%A7%A3"><span class="nav-number">1.8.2.</span> <span class="nav-text">求第K优解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E5%A4%A7%E6%84%8F-8"><span class="nav-number">1.8.2.1.</span> <span class="nav-text">题目大意</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-9"><span class="nav-number">1.8.2.2.</span> <span class="nav-text">思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-5"><span class="nav-number">1.8.2.3.</span> <span class="nav-text">实现</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Crayonxiaoxin"
      src="/images/crayonxiaoxin.jpg">
  <p class="site-author-name" itemprop="name">Crayonxiaoxin</p>
  <div class="site-description" itemprop="description">成名在望</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">61</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/crayonxinxin" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;crayonxinxin" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Crayonxiaoxin</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">122k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">1:51</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  

</body>
</html>
