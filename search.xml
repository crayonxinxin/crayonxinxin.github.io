<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>git</title>
    <url>/2024/05/30/git/</url>
    <content><![CDATA[<h1 id="git"><a href="#git" class="headerlink" title="git"></a>git</h1><ul>
<li><p>文件提交到仓库</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ git add readme.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;wrote a readme file&quot;//引号内为注释</span><br><span class="line">‘</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>commit</code>可以一次提交很多文件，所以你可以多次<code>add</code>不同的文件</p>
</li>
<li><p>版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用<code>git log</code>命令查看</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit <span class="number">1094</span>adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master)</span><br><span class="line"><span class="function">Author: <span class="title">Michael</span> <span class="title">Liao</span> &lt;<span class="title">askxuefeng</span>@<span class="title">gmail.com</span>&gt;</span></span><br><span class="line"><span class="function"><span class="title">Date</span>:   <span class="title">Fri</span> <span class="title">May</span> 18 21:06:15 2018 +0800</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">append</span> <span class="title">GPL</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">commit</span> <span class="title">e475afc93c209a690c39c13a46716e8fa000c366</span></span></span><br><span class="line"><span class="function"><span class="title">Author</span>: <span class="title">Michael</span> <span class="title">Liao</span> &lt;<span class="title">askxuefeng</span>@<span class="title">gmail.com</span>&gt;</span></span><br><span class="line"><span class="function"><span class="title">Date</span>:   <span class="title">Fri</span> <span class="title">May</span> 18 21:03:36 2018 +0800</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">add</span> <span class="title">distributed</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">commit</span> <span class="title">eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0</span></span></span><br><span class="line"><span class="function"><span class="title">Author</span>: <span class="title">Michael</span> <span class="title">Liao</span> &lt;<span class="title">askxuefeng</span>@<span class="title">gmail.com</span>&gt;</span></span><br><span class="line"><span class="function"><span class="title">Date</span>:   <span class="title">Fri</span> <span class="title">May</span> 18 20:59:18 2018 +0800</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">wrote</span> <span class="title">a</span> <span class="title">readme</span> <span class="title">file</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>​         如果嫌输出信息太多，看得眼花缭乱的，可以试试加上<code>--pretty=oneline</code>参数</p>
<ul>
<li><p>我们要把当前版本<code>append GPL</code>回退到上一个版本<code>add distributed</code>，就可以使用<code>git reset</code>命令</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span><br></pre></td></tr></table></figure>

<ul>
<li><code>HEAD</code>指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令<code>git reset --hard commit_id</code>。</li>
</ul>
</li>
</ul>
<ul>
<li>穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。</li>
<li>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本</li>
</ul>
<ul>
<li><p>命令<code>git checkout -- readme.txt</code>意思就是，把<code>readme.txt</code>文件在工作区的修改全部撤销，这里有两种情况：</p>
<p>一种是<code>readme.txt</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p>
<p>一种是<code>readme.txt</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p>
<p>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态</p>
</li>
</ul>
<p>​      删除文件</p>
<ul>
<li>一是确实要从版本库中删除该文件，那就用命令<code>git rm</code>删掉，并且<code>git commit</code></li>
</ul>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ git rm test.txt</span><br><span class="line">rm &#x27;test.txt&#x27;</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;remove test.txt&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：</li>
</ul>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ git checkout -- test.txt</span><br></pre></td></tr></table></figure>

<p><code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>linux</title>
    <url>/2024/05/30/linux/</url>
    <content><![CDATA[<h1 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h1><blockquote>
<p> Linux只有一个根目录<code>/</code>，所有文件都在它下面</p>
</blockquote>
<h2 id="Linux命令"><a href="#Linux命令" class="headerlink" title="Linux命令"></a>Linux命令</h2><p>在Linux中，命令有其通用的格式</p>
<p><code>command [-options] [parameter]</code></p>
<ul>
<li>command：命令本身</li>
<li>-options：[可选，非必填]命令的选项，可以通过选项控制命令的行为细节</li>
<li>parameter：[可选，非必填]命令的参数，多数用于命令的指向目标</li>
</ul>
<p><code>ls -l /home/tomato</code>  以列表的形式，显示<code>/home/tomato</code>目录内的内容</p>
<h3 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h3><blockquote>
<p>在命令行中，以平铺的形式，展示当前工作目录(默认HOME目录)下的内容</p>
</blockquote>
<p>ls命令默认列出的是<code>Home</code>目录的内容</p>
<ul>
<li><code>Home</code>目录：每个Linux操作用户在Linux系统的个人账户目录</li>
</ul>
<h4 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h4><blockquote>
<p>选项可以组合使用</p>
</blockquote>
<ul>
<li><code>-a</code>：all的意思，即列出全部文件(包含隐藏的文件&#x2F;文件夹) (以<code>.</code>开头的文件为隐藏文件)</li>
<li><code>-l</code>：以列表(竖向排列)的形式展示内容，并展示更多信息</li>
<li><code>-h</code>：<strong>需要和<code>-l</code>搭配使用</strong>，显示文件的大小单位</li>
</ul>
<h3 id="cd命令"><a href="#cd命令" class="headerlink" title="cd命令"></a>cd命令</h3><blockquote>
<p>切换当前所在的工作目录</p>
</blockquote>
<p><code>cd [Linux路径]</code></p>
<ul>
<li>cd命令无需选项，只有参数，表示要切换到哪个目录下</li>
<li>cd命令直接执行，不写参数，表示回到用户的HOME目录</li>
</ul>
<h3 id="pwd命令"><a href="#pwd命令" class="headerlink" title="pwd命令"></a>pwd命令</h3><blockquote>
<p>查看当前所在的工作目录</p>
</blockquote>
<p>特殊路径符</p>
<p>* </p>
<ul>
<li><code>.</code>表示当前目录(<code>cd ./Desktop</code>表示切换到当前目录下的Desktop目录)</li>
<li><code>..</code>表示上一级目录(<code>cd ..</code>即可切换到上一级目录，<code>cd ../..</code>切换到上两级目录)</li>
<li><code>~</code>表示HOME目录，(<code>cd ~</code>即可切换到HOME目录，<code>cd ~.Desktop</code>切换到HOME内的Desktop目录)</li>
</ul>
<h3 id="mkdir命令"><a href="#mkdir命令" class="headerlink" title="mkdir命令"></a>mkdir命令</h3><blockquote>
<p>创建新的目录(文件夹) MaKe DIRectory</p>
</blockquote>
<p><code>mkdir [-p] Linux路径</code></p>
<ul>
<li>参数必填，表示Linux路径，即要创建的文件夹的路径，相对路径或绝对路径都可</li>
<li><code>-p</code>选项可选，表示自动创建不存在的父目录，适用于创建连续多层级的目录</li>
</ul>
<h3 id="touch命令"><a href="#touch命令" class="headerlink" title="touch命令"></a>touch命令</h3><blockquote>
<p>创建文件</p>
</blockquote>
<p><code>touch Linux路径</code></p>
<ul>
<li>无选项，参数必填，表示要创建的文件路径</li>
</ul>
<h3 id="cat命令"><a href="#cat命令" class="headerlink" title="cat命令"></a>cat命令</h3><blockquote>
<p>查看文件内容</p>
</blockquote>
<p><code>cat Linux路径</code></p>
<ul>
<li>无选项，参数必填，表示要创建的文件路径</li>
</ul>
<h3 id="more命令"><a href="#more命令" class="headerlink" title="more命令"></a>more命令</h3><blockquote>
<p>查看文件内容</p>
</blockquote>
<ul>
<li><code>cat</code>是直接把内容全部显示出来</li>
<li><code>more</code>支持翻页，如果文件内容过多，可以一页页展示</li>
<li>无选项，参数必填，表示要创建的文件路径、</li>
<li>空格翻页，q退出</li>
</ul>
<h3 id="cp命令"><a href="#cp命令" class="headerlink" title="cp命令"></a>cp命令</h3><blockquote>
<p>复制文件\文件夹</p>
</blockquote>
<p><code>cp [-r] 参数1 参数2</code></p>
<ul>
<li><code>-r</code>，可选，用于复制文件夹使用，表示递归</li>
<li>参数1，Linux路径，表示被复制的文件或文件夹</li>
<li>参数2，Linux路径，表示要复制去的地方</li>
</ul>
<h3 id="mv命令"><a href="#mv命令" class="headerlink" title="mv命令"></a>mv命令</h3><blockquote>
<p>移动文件\文件夹</p>
</blockquote>
<p><code>mv 参数1 参数2</code></p>
<ul>
<li>参数1，Linux路径，表示被移动的文件或文件夹</li>
<li>参数2，Linux路径，表示要移动去的地方，如果目标不存在，</li>
</ul>
<h3 id="rm命令"><a href="#rm命令" class="headerlink" title="rm命令"></a>rm命令</h3><blockquote>
<p>删除文件、文件夹</p>
</blockquote>
<p><code>rm [-r -f] 参数1 ...</code> </p>
<ul>
<li><code>-f</code>表示强制删除</li>
<li><code>rm</code>支持通配符<code>*</code>，用来做模糊匹配(<code>test*表示匹配以test开头</code>)</li>
</ul>
<h3 id="which命令"><a href="#which命令" class="headerlink" title="which命令"></a>which命令</h3><blockquote>
<p>查找命令的程序文件</p>
</blockquote>
<p>Linux命令其实是一个个的二进制可执行程序</p>
<p><code>which 要查找的命令</code></p>
<h3 id="find命令"><a href="#find命令" class="headerlink" title="find命令"></a>find命令</h3><blockquote>
<p>搜索指定文件</p>
</blockquote>
<h4 id="按照文件名搜索"><a href="#按照文件名搜索" class="headerlink" title="按照文件名搜索"></a>按照文件名搜索</h4><p><code>find 起始路径 -name &quot;被查找文件名&quot;</code></p>
<ul>
<li>支持通配符模糊查找</li>
</ul>
<h4 id="按照文件大小查找"><a href="#按照文件大小查找" class="headerlink" title="按照文件大小查找"></a>按照文件大小查找</h4><p><code>find 起始路径 -size +|-n[kMG]</code></p>
<ul>
<li>+、-表示大于和小于</li>
<li>n表示大小数字</li>
<li>kMG表示大小单位，k(小写字母)表示kb，M表示MB，G表示GB</li>
</ul>
<p>查找小于10KB的文件：<code>find / -size -10k</code></p>
<h3 id="grep命令"><a href="#grep命令" class="headerlink" title="grep命令"></a>grep命令</h3><blockquote>
<p>从文件中通过关键字过滤文件行</p>
</blockquote>
<p><code>grep [-n] 关键字 文件路径</code></p>
<ul>
<li>选项<code>-n</code>可选，表示在结果中显示匹配的行的行号</li>
<li>参数，关键字，必填，表示过滤的关键字，带有空格或其他特殊符号，建议使用””将关键字包围起来</li>
<li>参数，文件路径</li>
</ul>
<h3 id="wc命令"><a href="#wc命令" class="headerlink" title="wc命令"></a>wc命令</h3><blockquote>
<p>统计文件的行数、单词数量等</p>
</blockquote>
<p><code>wc [-c -m -l -w] 文件路径</code></p>
<ul>
<li><code>-c</code>统计byte数量</li>
<li><code>-m</code>统计字符数量</li>
<li><code>-l</code>统计行数</li>
<li><code>-w</code>统计单词数量</li>
</ul>
<h3 id="管道符"><a href="#管道符" class="headerlink" title="管道符 |"></a>管道符 |</h3><p>管道符左边命令的结果，作为右边命令的输入</p>
<h3 id="echo命令"><a href="#echo命令" class="headerlink" title="echo命令"></a>echo命令</h3><blockquote>
<p>在命令行输出指定内容</p>
</blockquote>
<p><code>echo 输出的内容</code></p>
<h3 id="反引号"><a href="#反引号" class="headerlink" title="反引号 &#96;"></a>反引号 &#96;</h3><blockquote>
<p>被反引号包围的内容，会被作为命令执行，而非普通字符</p>
</blockquote>
<p>echo `pwd`  把pwd命令的结果输出</p>
<h3 id="重定向符"><a href="#重定向符" class="headerlink" title="重定向符"></a>重定向符</h3><p><code>&gt;</code>：将左侧命令的结果，<strong>覆盖</strong>写入符号右侧指定的文件中</p>
<p><code>&gt;&gt;</code>： 将左侧命令的结果，<strong>追加</strong>写入到符号右侧指定的文件中(会自动换行)</p>
<p><code>echo &quot;hello Linux&quot; &gt; tomato.txt</code></p>
<h3 id="head命令"><a href="#head命令" class="headerlink" title="head命令"></a>head命令</h3><p><code>head -n 文件路径</code></p>
<ul>
<li><code>-n</code>为要查看的行数</li>
</ul>
<h3 id="tail命令"><a href="#tail命令" class="headerlink" title="tail命令"></a>tail命令</h3><p><code>tail [-n] 文件路径</code></p>
<ul>
<li><code>-n</code>为要查看的行数</li>
</ul>
<h3 id="chmod命令"><a href="#chmod命令" class="headerlink" title="chmod命令"></a>chmod命令</h3><blockquote>
<p>修改文件、文件夹的权限信息</p>
</blockquote>
<p><code>chmod [-R] 权限 文件或文件夹</code></p>
<ul>
<li><code>-R</code>，对文件夹内的全部内容应用同样的操作</li>
<li><code>chomd u=rwx,g=rx,o=x hello.txt</code></li>
</ul>
<p>u为user所属用户权限，g表示group组权限，o表示other其他用户权限</p>
<p>![屏幕截图 2024-02-28 195336](C:\Users\Tomato\OneDrive\图片\屏幕快照\屏幕截图 2024-02-28 195336.png)</p>
<p><code>chmod 751 1.txt</code></p>
<h3 id="chown命令"><a href="#chown命令" class="headerlink" title="chown命令"></a>chown命令</h3><blockquote>
<p>修改文件、文件夹的所属用户和用户组</p>
</blockquote>
<p><strong>普通用户无法修改所属为其它用户或组，所以此命令只适用于root用户执行</strong></p>
<p><code>chown [-R] [用户] [:] [用户组] 文件或文件夹</code></p>
<ul>
<li><code>-R</code>，对文件夹内全部内容应用相同规则</li>
<li>选项，用户，修改所属用户</li>
<li>选项，用户组，修改所属用户组</li>
<li><code>:</code>，用于分隔用户和用户组</li>
</ul>
<p><code>chown root:tomato hello.txt</code></p>
<p><code>chown :tomato hello.txt</code></p>
<h3 id="各类技巧快捷键"><a href="#各类技巧快捷键" class="headerlink" title="各类技巧快捷键"></a>各类技巧快捷键</h3><p><img src="C:\Users\Tomato\AppData\Roaming\Typora\typora-user-images\image-20240229101521839.png" alt="image-20240229101521839"></p>
<h3 id="yum命令"><a href="#yum命令" class="headerlink" title="yum命令"></a>yum命令</h3><blockquote>
<p>自动化安装配置Linux软件，并可以自动解决依赖问题</p>
</blockquote>
<p><code>yum [-y] [install | remove | search] 软件名称</code></p>
<ul>
<li><code>-y</code> ，自动确认，无需手动确认安装或卸载过程</li>
<li>install： 安装</li>
<li>remove： 卸载</li>
<li>search： 搜索</li>
<li>yum命令需要root权限，可以su切换到root，也可以使用sudo权限</li>
<li>yum命令需要联网</li>
</ul>
<h3 id="systemctl命令"><a href="#systemctl命令" class="headerlink" title="systemctl命令"></a>systemctl命令</h3><blockquote>
<p>控制软件的启动、停止、开机自启</p>
</blockquote>
<p><code>systemctl start | stop | status | enable | disable 服务名</code></p>
<h3 id="ln命令"><a href="#ln命令" class="headerlink" title="ln命令"></a>ln命令</h3><blockquote>
<p>在系统中创建软链接，将文件、文件夹链接到其他位置，类似于快捷方式</p>
</blockquote>
<p><code>ln -s 参数1 参数2</code></p>
<ul>
<li><code>-s</code>选项，创建软链接</li>
<li>参数1：被链接的文件或文件夹</li>
<li>参数2：要链接去的目的地</li>
</ul>
<h3 id="data命令"><a href="#data命令" class="headerlink" title="data命令"></a>data命令</h3><p><img src="C:\Users\Tomato\AppData\Roaming\Typora\typora-user-images\image-20240229130157674.png" alt="image-20240229130157674"></p>
<p><img src="C:\Users\Tomato\AppData\Roaming\Typora\typora-user-images\image-20240229130504984.png" alt="image-20240229130504984"></p>
<h3 id="ping命令"><a href="#ping命令" class="headerlink" title="ping命令"></a>ping命令</h3><blockquote>
<p>检查指定的网络服务器是否是可联通状态</p>
</blockquote>
<p><code>ping [-c num] ip或主机名</code></p>
<ul>
<li><code>-c</code>检查的次数，不适用<code>-c</code>将无限次数持续检查</li>
</ul>
<h3 id="wget命令"><a href="#wget命令" class="headerlink" title="wget命令"></a>wget命令</h3><blockquote>
<p>非交互式的文件下载器，可以在命令行内下载网络文件</p>
</blockquote>
<p><code>wget [-b] url</code></p>
<ul>
<li><code>-b</code>，可选，后台下载</li>
<li>url，下载链接</li>
</ul>
<h3 id="curl命令"><a href="#curl命令" class="headerlink" title="curl命令"></a>curl命令</h3><blockquote>
<p>发起网络请求</p>
</blockquote>
<p><code>curl [-O] url</code></p>
<ul>
<li><code>-O</code>用于下载使用</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>css</title>
    <url>/2024/05/30/css/</url>
    <content><![CDATA[<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><p>设置HTML页面中的文本内容，图片的外形以及版面的布局和外观显示样式</p>
<p>可以美化页面，让布局更简单</p>
<h2 id="基础选择器"><a href="#基础选择器" class="headerlink" title="基础选择器"></a>基础选择器</h2><blockquote>
<p>分为基础选择器和复合选择器</p>
</blockquote>
<ul>
<li>基础选择器是由<strong>单个选择器组成的</strong></li>
<li>基础选择器又包括:标签选择器、类选择器、id选择器和通配符选择器</li>
</ul>
<h4 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h4><blockquote>
<p>指用HTML标签名称作为选择器，按标签名称分类，为页面中某一类标签指定统一的CSS样式</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">标签名&#123;</span><br><span class="line">    属性<span class="number">1</span>: 属性值<span class="number">1</span>;</span><br><span class="line">    属性<span class="number">2</span>: 属性值<span class="number">2</span>;</span><br><span class="line">    属性<span class="number">3</span>: 属性值<span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h4><blockquote>
<p>如果想要差异化选择不同的标签，单独选一个或者某几个标签，可以选择<strong>类选择器</strong></p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">.类名&#123;</span><br><span class="line">   属性<span class="number">1</span>: 属性值<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">&lt;did class = &#x27;red&#x27;&gt; 变红色 &lt;/<span class="selector-tag">div</span>&gt; //结构需要用class属性来调用class类的意思</span><br><span class="line"><span class="selector-class">.red</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>类选择器使用 <code>.</code>进行标识，后面紧跟类名(自定义)</li>
<li>长名词或词组可以使用中横线来为选择器命名</li>
</ul>
<h5 id="多类名"><a href="#多类名" class="headerlink" title="多类名"></a>多类名</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span> = <span class="string">&quot;red font35&quot;</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在标签class属性中写多个类名</li>
<li>多个类名中间必须用空格隔开</li>
</ul>
<h4 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a>id选择器</h4><blockquote>
<p>id选择器可以为标有特定id的HTML元素指定特定的样式</p>
</blockquote>
<p>HTML元素以id属性来设置id选择器，CSS中id选择器以<code>#</code>来定义</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#id</span>名&#123;</span><br><span class="line">   属性<span class="number">1</span>: 属性值<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>*** id属性只能在每个HTML文档中出现一次***</p>
<h5 id="id和类选择器的区别"><a href="#id和类选择器的区别" class="headerlink" title="id和类选择器的区别"></a>id和类选择器的区别</h5><ul>
<li>类选择器可以被多次使用</li>
<li>id选择器只能被使用一次</li>
</ul>
<h4 id="通配符选择器"><a href="#通配符选择器" class="headerlink" title="通配符选择器"></a>通配符选择器</h4><blockquote>
<p>使用<code>*</code>定义，它表示选取页面中所有元素(标签)</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">   属性<span class="number">1</span>； 属性值<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="字体属性"><a href="#字体属性" class="headerlink" title="字体属性"></a>字体属性</h3><blockquote>
<p>定义字体类型、大小、粗细和文字样式.</p>
</blockquote>
<h4 id="字体类型"><a href="#字体类型" class="headerlink" title="字体类型"></a>字体类型</h4><p>使用<code>font-family</code>属性定义文本的字体类型</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123; <span class="attribute">font-family</span>: <span class="string">&quot;Microsoft Yahei&quot;</span>;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="字体大小"><a href="#字体大小" class="headerlink" title="字体大小"></a>字体大小</h4><p>使用<code>font-size</code>属性定义字体大小</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">font-size</span>: <span class="number">20</span>fx;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>标题标签比较特殊，需要单独指定文字大小</li>
</ul>
<h4 id="字体粗细"><a href="#字体粗细" class="headerlink" title="字体粗细"></a>字体粗细</h4><p>使用<code>font-weight</code>属性设置文字粗细</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">font-weight</span>: <span class="number">700</span>;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>normal</code>是默认值</li>
<li><code>bold</code>定义粗体</li>
<li>400等同于normal，而700等同于bold，数字后面都不跟单位</li>
</ul>
<h4 id="文字样式"><a href="#文字样式" class="headerlink" title="文字样式"></a>文字样式</h4><p>使用<code>font-style</code>属性设置文本的风格</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;<span class="attribute">font-style</span>: normal;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>normal</code>默认值</li>
<li><code>italic</code>会显示斜体的字体样式</li>
</ul>
<h4 id="字体的复合属性"><a href="#字体的复合属性" class="headerlink" title="字体的复合属性"></a>字体的复合属性</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">   <span class="attribute">font</span>: italic <span class="number">700</span> <span class="number">16px</span> <span class="string">&quot;Micarosoft yahei&quot;</span>;//style-&gt;weight-&gt;size-&gt;family</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用font属性时，必须按上面语法格式中的顺序书写，<strong>不能更换顺序</strong>，并且各个属性间以空格隔开</li>
<li>不需要设置的属性可以省略(取默认值)，但<em><strong>必须保留<code>font-size</code>和<code>font-family</code>属性</strong></em>，否则font属性不起作用</li>
</ul>
<h3 id="文本属性"><a href="#文本属性" class="headerlink" title="文本属性"></a>文本属性</h3><h4 id="文本颜色"><a href="#文本颜色" class="headerlink" title="文本颜色"></a>文本颜色</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>预定义的颜色值: red,green,blue</li>
<li>十六进制: #FF0000, #FF6600</li>
<li>RGB代码: rgb(255,0,0)</li>
</ul>
<h4 id="对其文本"><a href="#对其文本" class="headerlink" title="对其文本"></a>对其文本</h4><blockquote>
<p>text-align属性用于设置元素内文本内容的水平对齐方式</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">   <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>left 左对齐(默认值)</li>
<li>right 右对齐</li>
<li>center 居中对齐</li>
</ul>
<h4 id="装饰文本"><a href="#装饰文本" class="headerlink" title="装饰文本"></a>装饰文本</h4><blockquote>
<p>text-decoration属性规定添加到文本的修饰。可以给文本添加下划线、删除线、上划线等</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">text-decoration</span>: underline;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>none 默认，没有装饰线</li>
<li>underline 下划线。链接a自带下划线</li>
<li>overline 上划线</li>
<li>line-through 删除线</li>
</ul>
<h4 id="文本缩进"><a href="#文本缩进" class="headerlink" title="文本缩进"></a>文本缩进</h4><blockquote>
<p>text-indent属性用来指定文本的第一行缩进，通常是将段落的首行缩进</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">  <span class="attribute">text-indent</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>通过设置该属性，所有元素的第一行都可以缩进一个给定的长度，甚至该长度可以是负值</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line"><span class="attribute">text-indent</span>: <span class="number">2em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>em</code>是一个相对单位，就是当前元素(font-size)1个文字的大小，如果当前元素没有设置大小，则会按照父元素的1个文字大小</p>
</li>
</ul>
<h4 id="行间距"><a href="#行间距" class="headerlink" title="行间距"></a>行间距</h4><blockquote>
<p>line-height属性用于设置行间的距离(行高)。可以控制文本行与行之间的距离</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">26px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="引入方式"><a href="#引入方式" class="headerlink" title="引入方式"></a>引入方式</h3><h4 id="CSS三种样式表"><a href="#CSS三种样式表" class="headerlink" title="CSS三种样式表"></a>CSS三种样式表</h4><p>按照书写的位置(引入的方式)</p>
<ul>
<li>行内样式表(行内式)</li>
<li>内部样式表(嵌入式)</li>
<li>外部样式表(链接式)</li>
</ul>
<h4 id="内部样式表"><a href="#内部样式表" class="headerlink" title="内部样式表"></a>内部样式表</h4><blockquote>
<p>内部样式表是写到HTML内部，是将所有的CSS代码抽取出来，单独放到一个<code>&lt;style&gt;</code>标签中</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>&lt;style&gt;</code>标签理论上可以放在HTML文档的任何地方，但一般会放在文档的<code>&lt;head&gt;</code>标签中</li>
</ul>
<h4 id="行内样式表"><a href="#行内样式表" class="headerlink" title="行内样式表"></a>行内样式表</h4><blockquote>
<p>行内样式表是在元素标签内部的style属性中设定CSS样式，适合于修改简单样式</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;color: red; font-size: 12px;&quot;</span>&gt;</span></span><br><span class="line">    青春不常在，抓紧谈恋爱</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="外部样式表-外链表或链接式引入"><a href="#外部样式表-外链表或链接式引入" class="headerlink" title="外部样式表(外链表或链接式引入)"></a><strong>外部样式表</strong>(外链表或链接式引入)</h4><blockquote>
<p>适合样式较多的情况： 样式单独写到CSS文件中，之后把CSS文件引入到HTML页面中使用</p>
</blockquote>
<ol>
<li><p>新建一个后缀名为<code>.css</code>的样式文件，把所有的CSS代码都放入此文件中</p>
</li>
<li><p>在HTML页面中，使用<code>&lt;link&gt;</code>标签引入这个文件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;css文件路径&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>rel 定义当前文档与被链接文档之间的关系，在这里需要指定为”stylesheet”，表示被链接的文档是一个样式表文件</li>
<li>href 定义所链接外部样式表文件的URL，可以是相对路径，也可以是绝对路径</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>mini</title>
    <url>/2024/05/29/mini/</url>
    <content><![CDATA[<h1 id="腾讯mini"><a href="#腾讯mini" class="headerlink" title="腾讯mini"></a>腾讯mini</h1><h2 id="AICR"><a href="#AICR" class="headerlink" title="AICR"></a>AICR</h2><blockquote>
<p>自动化客户关系管理</p>
</blockquote>
<p><strong>需要关注数据隐私和安全，确保系统的可靠性和用户友好性</strong></p>
<h2 id="RAG"><a href="#RAG" class="headerlink" title="RAG"></a>RAG</h2><blockquote>
<p>检索增强生成</p>
</blockquote>
<ol>
<li>信息检索(检索模型)：从外部知识库中检索相关信息或文档</li>
<li>文本生成(生成模型)：将检索到的信息与生成模型结合，生成更准确和信息丰富的响应</li>
</ol>
<h2 id="AICR-RAG知识库"><a href="#AICR-RAG知识库" class="headerlink" title="AICR RAG知识库"></a>AICR RAG知识库</h2><blockquote>
<p>结合了AICR和RAG技术，以创建一个智能化和高效的客户关系管理系统</p>
</blockquote>
<ul>
<li><p>优势</p>
<ul>
<li>响应准确性</li>
<li>个性化用户体验</li>
<li>效率提升</li>
<li>知识共享和更新</li>
</ul>
</li>
<li><p>挑战</p>
<ul>
<li>数据隐私和安全</li>
<li>技术复杂性</li>
<li>系统更新与维护</li>
</ul>
</li>
</ul>
<h3 id="LLM"><a href="#LLM" class="headerlink" title="LLM"></a>LLM</h3><blockquote>
<p>大型语言模型</p>
<p>基于深度学习技术的自然语言处理模型，旨在生成和理解人类语言</p>
</blockquote>
<h3 id="主要技术和原理"><a href="#主要技术和原理" class="headerlink" title="主要技术和原理"></a>主要技术和原理</h3><ul>
<li><p>神经网络架构</p>
</li>
<li><p>预训练和微调</p>
<ul>
<li>预训练：学习语言的基本结构和词汇的分布</li>
<li>微调：预训练好的模型在特定任务或领域的小规模有监督数据集上进行微调，以适应特定应用场景</li>
</ul>
</li>
<li><p>自监督学习</p>
</li>
<li><p>参数规模</p>
</li>
</ul>
<h2 id="Graph-RAG"><a href="#Graph-RAG" class="headerlink" title="Graph RAG"></a>Graph RAG</h2><blockquote>
<p>利用节点和边之间的关系将数据结构化</p>
<p>这种结构通过使模型能够访问精确且上下文相关的数据，大大提高了LLMs生成知情响应的能力</p>
<p>集成了图数据库</p>
</blockquote>
<p><strong><code>Graph RAG</code>的高度取决于基础<code>KG</code>的质量、深度和广度</strong></p>
<h2 id="Vector-RAG"><a href="#Vector-RAG" class="headerlink" title="Vector RAG"></a>Vector RAG</h2><blockquote>
<p>结合向量检索和生成模型的技术</p>
</blockquote>
<ul>
<li><p>向量检索</p>
<ul>
<li>使用嵌入来表示文本、句子和文档，将他们转换为高维向量</li>
</ul>
</li>
<li><p>增强生成</p>
</li>
</ul>
<h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><ol>
<li>输入处理：<ol>
<li>用户输入一个问题，系统首先将其转换为嵌入向量</li>
</ol>
</li>
<li>向量检索<ol>
<li>在预先构建的知识库中，通过向量相似度检索与输入向量最相似的向量，找到相关的文本片段或文档</li>
<li>向量检索可以通过高效的索引结构加速</li>
</ol>
</li>
<li>信息融合<ol>
<li>检索到的相关信息呗传递给生成模型，生成模型将这些信息与原始输入结合，生成一个综合的、上下文相关的响应</li>
</ol>
</li>
<li>生成输出<ol>
<li>生成模型基于融合的信息生成最终的文本输出</li>
</ol>
</li>
</ol>
<h2 id="读取代码仓库加工生成代码仓库知识库"><a href="#读取代码仓库加工生成代码仓库知识库" class="headerlink" title="读取代码仓库加工生成代码仓库知识库"></a>读取代码仓库加工生成代码仓库知识库</h2><h4 id="获取代码仓库数据"><a href="#获取代码仓库数据" class="headerlink" title="获取代码仓库数据"></a>获取代码仓库数据</h4><p>通过API或直接克隆代码仓库获取代码库的所有文件和相关元数据</p>
<h4 id="解析代码和文档"><a href="#解析代码和文档" class="headerlink" title="解析代码和文档"></a>解析代码和文档</h4><ul>
<li>使用代码解析工具或库解析代码文件，提取函数、类、变量和注释等信息</li>
<li>提取和解析代码库中的文档以获取更多上下文信息</li>
</ul>
<h4 id="生成知识库"><a href="#生成知识库" class="headerlink" title="生成知识库"></a>生成知识库</h4><ul>
<li>创建结构化的数据存储以保存从代码库中提取的信息</li>
<li>使用自然语言处理技术和嵌入模型将代码和文档转化为向量表示，以便于检索和分析</li>
</ul>
<p><strong>RAG技术可以用于最后的生成知识库步骤，可以显著提升系统的检索和生成增强响应</strong></p>
<h2 id="AICP和知识库之间的联系"><a href="#AICP和知识库之间的联系" class="headerlink" title="AICP和知识库之间的联系"></a>AICP和知识库之间的联系</h2><blockquote>
<p>在AICP系统中，知识库是一个关键主件，它存储和组织了大量的信息，帮助系统提供更只能和高效的客户支持和管理</p>
</blockquote>
<ol>
<li>知识库构建</li>
<li>将知识库集成到AICR系统<ol>
<li>知识库接口<ol>
<li>API接口：设计和实现API，使AICR系统能访问知识库</li>
<li>查询语言：使用SQL或专门的查询语言来查询知识库</li>
</ol>
</li>
<li>检索和增强生成<ol>
<li>检索增强生成（RAG）：结合检索模型和生成模型，从知识库中检索相关信息，并生成回答</li>
<li>检索模型：使用向量检索技术从知识库中找到最相关的文档</li>
<li>生成模型：使用生成模型结合检索到的信息，生成上下文相关的回答</li>
</ol>
</li>
</ol>
</li>
<li>实现AICR系统中的应用<ol>
<li>智能客服</li>
<li>个性化推荐</li>
</ol>
</li>
<li>维护反馈和优化</li>
</ol>
<h2 id="RAG-Graph-RAG"><a href="#RAG-Graph-RAG" class="headerlink" title="RAG &#x2F; Graph RAG"></a>RAG &#x2F; Graph RAG</h2><blockquote>
<p>主要区别在于检索模型和数据结构的不同</p>
<p>在Graph RAG中，知识库被表示为图结构，而一般的RAG中，知识库通常是文档集合或数据库</p>
</blockquote>
<ul>
<li><p>更丰富的关系建模</p>
<ul>
<li>图结构：自然表达实体之间的复杂关系（层次关系，关联关系）</li>
<li>上下文理解：捕捉实体之间的多跳关系</li>
</ul>
</li>
<li><p>更高效的信息检索</p>
<ul>
<li>相关子图：可以通过子图提取，获取与查询直接相关的所有节点和边，避免了大规模文档检索的冗余信息</li>
<li>结构化信息：可以获得结构化的信息片段</li>
</ul>
</li>
<li><p>改进的生成质量</p>
<ul>
<li>综合信息：子图包含多层次、多角度的信息</li>
<li>信息整合：生成模型可以将子图中的多个相关信息节点进行整合</li>
</ul>
</li>
<li><p>知识库的动态更新和扩展</p>
<ul>
<li>节点和边的增删：允许动态地添加或删除节点和边</li>
</ul>
</li>
<li><p>多模态信息整合</p>
<ul>
<li>多种数据类型：图结构能够整合文本、图像、视频等多种数据类型，通过节点和边的连接，提供更全面的回答</li>
</ul>
</li>
</ul>
<h2 id="RAG-Vector-RAG"><a href="#RAG-Vector-RAG" class="headerlink" title="RAG &#x2F; Vector RAG"></a>RAG &#x2F; Vector RAG</h2><blockquote>
<p>在Vector RAG知识库中的文档或信息片段预先向量化，并存储在向量数据库中</p>
<p>使用高效的向量检索方法在向量数据库中找到最相似的文档向量，通常在大规模检索中更高效</p>
</blockquote>
<h2 id="提高基础KG质量"><a href="#提高基础KG质量" class="headerlink" title="提高基础KG质量"></a>提高基础KG质量</h2><ol>
<li><p>多样化数据来源</p>
</li>
<li><p>结构化数据</p>
</li>
<li><p>半结构化和非结构化数据</p>
</li>
<li><p>行业数据</p>
<p>使用自动化数据收集，<strong>应用自然语言处理从非结构化文本中提取实体和关系</strong></p>
</li>
<li><p>数据质量提升</p>
<ol>
<li>数据清理和规范化<ol>
<li>去除重复、错误、不完整的数据</li>
<li>统一数据格式和标准</li>
</ol>
</li>
<li>数据验证和校验</li>
<li>实体消歧和实体合并</li>
</ol>
</li>
<li><p>增强数据深度</p>
<ol>
<li>关系挖掘：通过文本分析、关系抽取发现新的实体关系</li>
<li>多挑关系：构建多跳关系，使图谱能够表达复杂的知识结构</li>
</ol>
</li>
<li><p>扩展数据广度</p>
<ol>
<li>跨领域数据集成</li>
<li>多语言支持</li>
</ol>
</li>
<li><p>图谱更新和维护</p>
</li>
<li><p>利用机械学习和深度学习等高级技术和工具</p>
</li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>mini</tag>
      </tags>
  </entry>
  <entry>
    <title>mini</title>
    <url>/2024/05/29/mini/mini/</url>
    <content><![CDATA[<h1 id="腾讯mini"><a href="#腾讯mini" class="headerlink" title="腾讯mini"></a>腾讯mini</h1><h2 id="AICR"><a href="#AICR" class="headerlink" title="AICR"></a>AICR</h2><blockquote>
<p>自动化客户关系管理</p>
</blockquote>
<p><strong>需要关注数据隐私和安全，确保系统的可靠性和用户友好性</strong></p>
<h2 id="RAG"><a href="#RAG" class="headerlink" title="RAG"></a>RAG</h2><blockquote>
<p>检索增强生成</p>
</blockquote>
<ol>
<li>信息检索(检索模型)：从外部知识库中检索相关信息或文档</li>
<li>文本生成(生成模型)：将检索到的信息与生成模型结合，生成更准确和信息丰富的响应</li>
</ol>
<h2 id="AICR-RAG知识库"><a href="#AICR-RAG知识库" class="headerlink" title="AICR RAG知识库"></a>AICR RAG知识库</h2><blockquote>
<p>结合了AICR和RAG技术，以创建一个智能化和高效的客户关系管理系统</p>
</blockquote>
<ul>
<li><p>优势</p>
<ul>
<li>响应准确性</li>
<li>个性化用户体验</li>
<li>效率提升</li>
<li>知识共享和更新</li>
</ul>
</li>
<li><p>挑战</p>
<ul>
<li>数据隐私和安全</li>
<li>技术复杂性</li>
<li>系统更新与维护</li>
</ul>
</li>
</ul>
<h3 id="LLM"><a href="#LLM" class="headerlink" title="LLM"></a>LLM</h3><blockquote>
<p>大型语言模型</p>
<p>基于深度学习技术的自然语言处理模型，旨在生成和理解人类语言</p>
</blockquote>
<h3 id="主要技术和原理"><a href="#主要技术和原理" class="headerlink" title="主要技术和原理"></a>主要技术和原理</h3><ul>
<li><p>神经网络架构</p>
</li>
<li><p>预训练和微调</p>
<ul>
<li>预训练：学习语言的基本结构和词汇的分布</li>
<li>微调：预训练好的模型在特定任务或领域的小规模有监督数据集上进行微调，以适应特定应用场景</li>
</ul>
</li>
<li><p>自监督学习</p>
</li>
<li><p>参数规模</p>
</li>
</ul>
<h2 id="Graph-RAG"><a href="#Graph-RAG" class="headerlink" title="Graph RAG"></a>Graph RAG</h2><blockquote>
<p>利用节点和边之间的关系将数据结构化</p>
<p>这种结构通过使模型能够访问精确且上下文相关的数据，大大提高了LLMs生成知情响应的能力</p>
<p>集成了图数据库</p>
</blockquote>
<p><strong><code>Graph RAG</code>的高度取决于基础<code>KG</code>的质量、深度和广度</strong></p>
<h2 id="Vector-RAG"><a href="#Vector-RAG" class="headerlink" title="Vector RAG"></a>Vector RAG</h2><blockquote>
<p>结合向量检索和生成模型的技术</p>
</blockquote>
<ul>
<li><p>向量检索</p>
<ul>
<li>使用嵌入来表示文本、句子和文档，将他们转换为高维向量</li>
</ul>
</li>
<li><p>增强生成</p>
</li>
</ul>
<h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><ol>
<li>输入处理：<ol>
<li>用户输入一个问题，系统首先将其转换为嵌入向量</li>
</ol>
</li>
<li>向量检索<ol>
<li>在预先构建的知识库中，通过向量相似度检索与输入向量最相似的向量，找到相关的文本片段或文档</li>
<li>向量检索可以通过高效的索引结构加速</li>
</ol>
</li>
<li>信息融合<ol>
<li>检索到的相关信息呗传递给生成模型，生成模型将这些信息与原始输入结合，生成一个综合的、上下文相关的响应</li>
</ol>
</li>
<li>生成输出<ol>
<li>生成模型基于融合的信息生成最终的文本输出</li>
</ol>
</li>
</ol>
<h2 id="读取代码仓库加工生成代码仓库知识库"><a href="#读取代码仓库加工生成代码仓库知识库" class="headerlink" title="读取代码仓库加工生成代码仓库知识库"></a>读取代码仓库加工生成代码仓库知识库</h2><h4 id="获取代码仓库数据"><a href="#获取代码仓库数据" class="headerlink" title="获取代码仓库数据"></a>获取代码仓库数据</h4><p>通过API或直接克隆代码仓库获取代码库的所有文件和相关元数据</p>
<h4 id="解析代码和文档"><a href="#解析代码和文档" class="headerlink" title="解析代码和文档"></a>解析代码和文档</h4><ul>
<li>使用代码解析工具或库解析代码文件，提取函数、类、变量和注释等信息</li>
<li>提取和解析代码库中的文档以获取更多上下文信息</li>
</ul>
<h4 id="生成知识库"><a href="#生成知识库" class="headerlink" title="生成知识库"></a>生成知识库</h4><ul>
<li>创建结构化的数据存储以保存从代码库中提取的信息</li>
<li>使用自然语言处理技术和嵌入模型将代码和文档转化为向量表示，以便于检索和分析</li>
</ul>
<p><strong>RAG技术可以用于最后的生成知识库步骤，可以显著提升系统的检索和生成增强响应</strong></p>
<h2 id="AICP和知识库之间的联系"><a href="#AICP和知识库之间的联系" class="headerlink" title="AICP和知识库之间的联系"></a>AICP和知识库之间的联系</h2><blockquote>
<p>在AICP系统中，知识库是一个关键主件，它存储和组织了大量的信息，帮助系统提供更只能和高效的客户支持和管理</p>
</blockquote>
<ol>
<li>知识库构建</li>
<li>将知识库集成到AICR系统<ol>
<li>知识库接口<ol>
<li>API接口：设计和实现API，使AICR系统能访问知识库</li>
<li>查询语言：使用SQL或专门的查询语言来查询知识库</li>
</ol>
</li>
<li>检索和增强生成<ol>
<li>检索增强生成（RAG）：结合检索模型和生成模型，从知识库中检索相关信息，并生成回答</li>
<li>检索模型：使用向量检索技术从知识库中找到最相关的文档</li>
<li>生成模型：使用生成模型结合检索到的信息，生成上下文相关的回答</li>
</ol>
</li>
</ol>
</li>
<li>实现AICR系统中的应用<ol>
<li>智能客服</li>
<li>个性化推荐</li>
</ol>
</li>
<li>维护反馈和优化</li>
</ol>
<h2 id="RAG-Graph-RAG"><a href="#RAG-Graph-RAG" class="headerlink" title="RAG &#x2F; Graph RAG"></a>RAG &#x2F; Graph RAG</h2><blockquote>
<p>主要区别在于检索模型和数据结构的不同</p>
<p>在Graph RAG中，知识库被表示为图结构，而一般的RAG中，知识库通常是文档集合或数据库</p>
</blockquote>
<ul>
<li><p>更丰富的关系建模</p>
<ul>
<li>图结构：自然表达实体之间的复杂关系（层次关系，关联关系）</li>
<li>上下文理解：捕捉实体之间的多跳关系</li>
</ul>
</li>
<li><p>更高效的信息检索</p>
<ul>
<li>相关子图：可以通过子图提取，获取与查询直接相关的所有节点和边，避免了大规模文档检索的冗余信息</li>
<li>结构化信息：可以获得结构化的信息片段</li>
</ul>
</li>
<li><p>改进的生成质量</p>
<ul>
<li>综合信息：子图包含多层次、多角度的信息</li>
<li>信息整合：生成模型可以将子图中的多个相关信息节点进行整合</li>
</ul>
</li>
<li><p>知识库的动态更新和扩展</p>
<ul>
<li>节点和边的增删：允许动态地添加或删除节点和边</li>
</ul>
</li>
<li><p>多模态信息整合</p>
<ul>
<li>多种数据类型：图结构能够整合文本、图像、视频等多种数据类型，通过节点和边的连接，提供更全面的回答</li>
</ul>
</li>
</ul>
<h2 id="RAG-Vector-RAG"><a href="#RAG-Vector-RAG" class="headerlink" title="RAG &#x2F; Vector RAG"></a>RAG &#x2F; Vector RAG</h2><blockquote>
<p>在Vector RAG知识库中的文档或信息片段预先向量化，并存储在向量数据库中</p>
<p>使用高效的向量检索方法在向量数据库中找到最相似的文档向量，通常在大规模检索中更高效</p>
</blockquote>
<h2 id="提高基础KG质量"><a href="#提高基础KG质量" class="headerlink" title="提高基础KG质量"></a>提高基础KG质量</h2><ol>
<li><p>多样化数据来源</p>
</li>
<li><p>结构化数据</p>
</li>
<li><p>半结构化和非结构化数据</p>
</li>
<li><p>行业数据</p>
<p>使用自动化数据收集，<strong>应用自然语言处理从非结构化文本中提取实体和关系</strong></p>
</li>
<li><p>数据质量提升</p>
<ol>
<li>数据清理和规范化<ol>
<li>去除重复、错误、不完整的数据</li>
<li>统一数据格式和标准</li>
</ol>
</li>
<li>数据验证和校验</li>
<li>实体消歧和实体合并</li>
</ol>
</li>
<li><p>增强数据深度</p>
<ol>
<li>关系挖掘：通过文本分析、关系抽取发现新的实体关系</li>
<li>多挑关系：构建多跳关系，使图谱能够表达复杂的知识结构</li>
</ol>
</li>
<li><p>扩展数据广度</p>
<ol>
<li>跨领域数据集成</li>
<li>多语言支持</li>
</ol>
</li>
<li><p>图谱更新和维护</p>
</li>
<li><p>利用机械学习和深度学习等高级技术和工具</p>
</li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>mini</tag>
      </tags>
  </entry>
  <entry>
    <title>html</title>
    <url>/2024/05/30/html/</url>
    <content><![CDATA[<h2 id="Web-标准"><a href="#Web-标准" class="headerlink" title="Web 标准"></a>Web 标准</h2><p>主要由<strong>结构、表现和行为</strong>三个方面组成</p>
<h1 id="HTML标签"><a href="#HTML标签" class="headerlink" title="HTML标签"></a>HTML标签</h1><h2 id="语法规范"><a href="#语法规范" class="headerlink" title="语法规范"></a>语法规范</h2><ul>
<li>HTML标签是由尖括号包围的关键词</li>
<li>标签通常是成对出现的，称为双标签，第一个为开始标签，第二个是结束标签</li>
<li>也存在单标签</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span>//开始标签<span class="tag">&lt;/<span class="name">html</span>&gt;</span>//结束标签 （比开始标签多一个/）</span><br></pre></td></tr></table></figure>

<h3 id="标签关系"><a href="#标签关系" class="headerlink" title="标签关系"></a>标签关系</h3><ul>
<li><p>包含关系</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>并列关系</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="HTML基本结构标签"><a href="#HTML基本结构标签" class="headerlink" title="HTML基本结构标签"></a>HTML基本结构标签</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span>//HTML标签(页面中最大的标签，我们成为根标签)</span><br><span class="line">   <span class="tag">&lt;<span class="name">head</span>&gt;</span>//文档的头部(注意再head标签中我们必须要设置的标签是title)</span><br><span class="line">      <span class="tag">&lt;<span class="name">title</span>&gt;</span>我的第一个页面<span class="tag">&lt;/<span class="name">title</span>&gt;</span>//文档的标题(让页面拥有一个属于自己的网页标题)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span>//文档的主体(元素包含文档的全部内容，页面内容基本都是放到body里面的)</span><br><span class="line">        你我之间</span><br><span class="line">     <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span>//文档类型声明标签</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span>//网站语言选择</span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span>//字符集</span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>第一个页面<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    浮生若梦</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="HTML常用标签"><a href="#HTML常用标签" class="headerlink" title="HTML常用标签"></a>HTML常用标签</h2><h3 id="标题标签"><a href="#标题标签" class="headerlink" title="标题标签"></a>标题标签</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span> - <span class="tag">&lt;<span class="name">h6</span>&gt;</span>//六级标签</span><br></pre></td></tr></table></figure>

<pre><code><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>标题标签<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
</code></pre>
<h3 id="段落标签"><a href="#段落标签" class="headerlink" title="段落标签"></a>段落标签</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span> 第一段 <span class="tag">&lt;/<span class="name">p</span>&gt;</span> <span class="tag">&lt;<span class="name">p</span>&gt;</span> 第二段 <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="换行标签"><a href="#换行标签" class="headerlink" title="换行标签"></a>换行标签</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">br</span> /&gt;</span>//强制换行</span><br></pre></td></tr></table></figure>

<h2 id="文本格式化标签"><a href="#文本格式化标签" class="headerlink" title="文本格式化标签"></a>文本格式化标签</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">strong</span>&gt;</span><span class="tag">&lt;/<span class="name">strong</span>&gt;</span>//加粗文字    <span class="tag">&lt;<span class="name">b</span>&gt;</span><span class="tag">&lt;/<span class="name">b</span>&gt;</span>//加粗文字</span><br><span class="line"><span class="tag">&lt;<span class="name">em</span>&gt;</span><span class="tag">&lt;/<span class="name">em</span>&gt;</span>//倾斜文字            <span class="tag">&lt;<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span>//倾斜文字</span><br><span class="line"><span class="tag">&lt;<span class="name">del</span>&gt;</span><span class="tag">&lt;/<span class="name">del</span>&gt;</span>//删除线            <span class="tag">&lt;<span class="name">s</span>&gt;</span><span class="tag">&lt;/<span class="name">s</span>&gt;</span>//删除线</span><br><span class="line"><span class="tag">&lt;<span class="name">ins</span>&gt;</span><span class="tag">&lt;/<span class="name">ins</span>&gt;</span>//下划线            <span class="tag">&lt;<span class="name">u</span>&gt;</span><span class="tag">&lt;/<span class="name">u</span>&gt;</span>//下划线</span><br></pre></td></tr></table></figure>

<h2 id="和标签"><a href="#和标签" class="headerlink" title="和标签"></a><div>和<span>标签</h2><p>一个盒子，用来装内容的标签</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>这是头部<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>今日价格<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>div标签用来布局，但是现在一行只能放一个div，大盒子</li>
<li>span标签用来布局，一行上可以多个span，小盒子</li>
</ul>
<h2 id="图像标签和路径"><a href="#图像标签和路径" class="headerlink" title="图像标签和路径"></a>图像标签和路径</h2><h3 id="图像标签"><a href="#图像标签" class="headerlink" title="图像标签"></a>图像标签</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;图像URL&quot;</span> /&gt;</span>//单标签<span class="tag">&lt;<span class="name">img</span>/&gt;</span>标签，src是标签的必须属性，它用于指定图像文件的路径和文件名</span><br></pre></td></tr></table></figure>

<h4 id="图像标签的属性"><a href="#图像标签的属性" class="headerlink" title="图像标签的属性"></a>图像标签的属性</h4><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">src  必须属性，图片路径</span><br><span class="line">alt  替换文本，图像不能显示文字</span><br><span class="line">title  提示文本，鼠标放到图像上，显示的文字</span><br><span class="line">width  设置图像的宽度</span><br><span class="line">height 设置图像的高度</span><br><span class="line">border 设置图像的边框粗细</span><br></pre></td></tr></table></figure>

<h3 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img.jpg&quot;</span> /&gt;</span>//同一级路径</span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;images/img.jpg&quot;</span> /&gt;</span>//下一级路径</span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">sec</span>=<span class="string">&quot;../baidu.gif&quot;</span> /&gt;</span>//上一级路径</span><br></pre></td></tr></table></figure>

<h3 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径"></a>绝对路径</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;绝对路径&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="超链接标签"><a href="#超链接标签" class="headerlink" title="超链接标签"></a>超链接标签</h3><p>可以从一个页面链接到另一个页面</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;跳转目标&quot;</span> <span class="attr">target</span>=<span class="string">&quot;目标窗口的弹出方式&quot;</span>&gt;</span> 文本或图像 <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>href为指定链接目标的url地址，为必须属性</li>
<li>target用于指定链接页面的打开方式，其中_self为默认值，_blank为在新窗口中打开方式</li>
</ul>
<h4 id="超链接标签的分类"><a href="#超链接标签的分类" class="headerlink" title="超链接标签的分类"></a>超链接标签的分类</h4><ul>
<li><p>外部链接</p>
</li>
<li><p>内部链接，网站内部页面之间的相互链接，直接链接内部页面即可，如<code>&lt;a href=&quot;index.html&quot;&gt; 首页 &lt;/a&gt;</code></p>
</li>
<li><p>空连接，把链接目标写成#即可</p>
</li>
<li><p>下载链接，如果href里面地址是一个文件或者压缩包，会下载这个文件</p>
</li>
<li><p>网页元素链接：在网页中的各种网页元素，如文本，图像，表格，音频，视频等都可以添加超链接</p>
<p><code>&lt;a href=&quot;http://www.baidu.com&quot;&gt; &lt;img src=&quot;img.jpg&quot;/&gt; &lt;/a&gt;</code></p>
</li>
<li><p>锚点链接，点我们链接，可以快速定位到页面中的某个位置</p>
<p>​            a.在链接文本的href属性中，设置属性值为<code>#名字</code>的形式，如<code>&lt;a href=&quot;#two&quot;&gt; 第二集 &lt;/a&gt;</code></p>
<ol start="2">
<li>找到目标位置标签，里面添加一个id属性&#x3D;刚才的名字，如<code>&lt;h3 id=&quot;two&quot;&gt; 第二集介绍 &lt;/h3&gt;h3&gt;</code></li>
</ol>
</li>
</ul>
<h2 id="注释和特殊字符"><a href="#注释和特殊字符" class="headerlink" title="注释和特殊字符"></a>注释和特殊字符</h2><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p><code>&lt;!--这是注释--&gt;</code></p>
<h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><p><img src="C:\Users\李佳鑫\Desktop\html\微信图片_20231019093538.jpg"></p>
<h3 id="表格标签"><a href="#表格标签" class="headerlink" title="表格标签"></a>表格标签</h3><p>表格用来显示数据，一般不用来布局</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span>//用于定义表格的标签</span><br><span class="line">   <span class="tag">&lt;<span class="name">tr</span>&gt;</span>//用于定义表格中的行，必须嵌套在<span class="tag">&lt;<span class="name">table</span>&gt;</span>中</span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>单元格内的文字<span class="tag">&lt;/<span class="name">td</span>&gt;</span>//定义表格中的单元格，必须嵌套在<span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">      ...</span><br><span class="line">   <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="表头单元格"><a href="#表头单元格" class="headerlink" title="表头单元格"></a>表头单元格</h4><p>一般表头单元格位于表格的第一行或第一列，表头单元格里面的文本内容加粗居中表示</p>
<p><code>&lt;th&gt; &lt;/th&gt;</code></p>
<h4 id="表格结构标签"><a href="#表格结构标签" class="headerlink" title="表格结构标签"></a>表格结构标签</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">thread</span>&gt;</span> <span class="tag">&lt;/<span class="name">thread</span>&gt;</span>标签表格的头部区域</span><br><span class="line"><span class="tag">&lt;<span class="name">tbody</span>&gt;</span> <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span>标签表格的主题区域</span><br></pre></td></tr></table></figure>

<p>可以更好的分清表格结构</p>
<h4 id="合并单元格"><a href="#合并单元格" class="headerlink" title="合并单元格"></a>合并单元格</h4><p>目标单元格：写合并代码</p>
<ul>
<li>跨行：最上侧单元格为目标单元格，写合并代码<code>&lt;td rowspan = &quot;2&quot;&gt;&lt;/th&gt;</code></li>
<li>跨列：最左侧单元格为目标单元格，写合并代码<code>&lt;td colspan = &quot;2&quot;&gt;&lt;/td&gt;</code></li>
<li>记得要删除多余单元格</li>
</ul>
<h2 id="列表标签"><a href="#列表标签" class="headerlink" title="列表标签"></a>列表标签</h2><p>分为无序列表，有序列表和自定义列表</p>
<h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>没有顺序级别之分，是并列的</p>
</li>
<li><p><code>&lt;ul&gt;</code>中只能嵌套<code>&lt;li&gt;</code>，直接在<code>&lt;ul&gt;</code>标签中输入其他标签或文字的做法是不被允许的</p>
</li>
<li><p><code>&lt;li&gt;</code>相当于一个容器，可以容纳所有元素</p>
</li>
</ul>
<h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>属性与无序列表相似</p>
<h3 id="自定义列表"><a href="#自定义列表" class="headerlink" title="自定义列表"></a>自定义列表</h3><p>自定义列表常用于对术语或名词进行解释和描述，定义列表的列表项前没有任何项目符号</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span> //用于定义描述列表（或定义列表），</span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>名词1<span class="tag">&lt;/<span class="name">dt</span>&gt;</span> //定义项目/名字</span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>名词1 解释1<span class="tag">&lt;/<span class="name">dd</span>&gt;</span> //描述每一个项目/名字</span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>名词1 解释2<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>&lt;dl&gt;</code>里面只能包含<code>&lt;dt&gt;</code>和<code>&lt;dd&gt;</code></p>
</li>
<li><p><code>&lt;dt&gt;</code>和<code>&lt;dd&gt;</code>里面可以放任何标签</p>
</li>
</ul>
<h2 id="表单标签"><a href="#表单标签" class="headerlink" title="表单标签"></a>表单标签</h2><p>为了收集客户信息</p>
<h3 id="表单的组成"><a href="#表单的组成" class="headerlink" title="表单的组成"></a>表单的组成</h3><p>由表单域、表单控件(也称为表单元素)和提示信息三个部分组成</p>
<h4 id="表单域"><a href="#表单域" class="headerlink" title="表单域"></a>表单域</h4><p>包含表单元素的区域</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;url地址&quot;</span> <span class="attr">method</span>=<span class="string">&quot;提交方式&quot;</span> <span class="attr">name</span>=<span class="string">&quot;表单域名称&quot;</span>&gt;</span> //method取值为get或post</span><br><span class="line">   各种表单元素控件</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="表单控件-表单元素"><a href="#表单控件-表单元素" class="headerlink" title="表单控件(表单元素)"></a>表单控件(表单元素)</h4><h5 id="input表单元素"><a href="#input表单元素" class="headerlink" title="input表单元素"></a>input表单元素</h5><p>收集用户信息</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;属性值&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>&lt;input /&gt;</code>标签为单标签</p>
</li>
<li><p>type属性设置不同的属性值用来指定不同的控件类型</p>
<p><img src="C:\Users\李佳鑫\Desktop\html\微信图片_20231020125843.jpg"></p>
</li>
</ul>
<p><img src="C:\Users\李佳鑫\Desktop\html\微信图片_20231020135217.jpg"></p>
<h6 id="标签"><a href="#标签" class="headerlink" title="&lt;label&gt;标签"></a><code>&lt;label&gt;</code>标签</h6><p><code>&lt;label&gt;</code>标签为input元素定义标注(标签)</p>
<p><code>&lt;label&gt;</code>标签用于绑定一个表单元素，当点击<code>&lt;label&gt;</code>标签内的文本时，浏览器就会自动将焦点(光标)转到或者选择对应的表单元素上，用来增加用户体验</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;sex&quot;</span>&gt;</span> 男 <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span>  <span class="attr">id</span>=<span class="string">&quot;sex&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>**<code>&lt;label&gt;</code>标签里面的for属性应当与相关元素的id属性相同</p>
<h5 id="select表单元素"><a href="#select表单元素" class="headerlink" title="select表单元素"></a>select表单元素</h5><p>在页面中，如果有多个选项让用户选择，并且想要节约页面时，我们可以使用<code>&lt;select</code>&gt;标签控件定义下拉列表</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>选项1<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>选项2<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>选项3<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>&lt;select&gt;</code>中至少包含一对<code>&lt;option&gt;</code></p>
</li>
<li><p>在<code>&lt;option&gt;</code>中定义selected &#x3D; “selected”时，当前项即为默认选中项</p>
</li>
</ul>
<h5 id="textarea文本域元素"><a href="#textarea文本域元素" class="headerlink" title="textarea文本域元素"></a>textarea文本域元素</h5><p>当用户输入内容较多的情况下，我们就不能使用文本框表单了此时可以用<code>&lt;textarea&gt;</code>标签,用于定义多行文本输入的控件</p>
<p>常见于留言板，评论</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">rows</span>=<span class="string">&quot;3&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;20&quot;</span>&gt;</span></span><br><span class="line">  文本内容</span><br><span class="line"><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>二分图最大匹配</title>
    <url>/2024/05/30/acm/%E5%9B%BE%E8%AE%BA/%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<h1 id="二分图最大匹配"><a href="#二分图最大匹配" class="headerlink" title="二分图最大匹配"></a>二分图最大匹配</h1><blockquote>
<p>假定图有n个顶点，m条边</p>
<p>给定一个二分图，有左右两个部分，各部分之间的点没有边连接，要求选出一些边，使得这些边没有公共顶点，且边的数量最大</p>
<p>O（nm）</p>
</blockquote>
<h2 id="增广路算法"><a href="#增广路算法" class="headerlink" title="增广路算法"></a>增广路算法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">augment_path</span> &#123;</span><br><span class="line">  vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; g;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; pa;  <span class="comment">// 匹配</span></span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; pb;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; vis;  <span class="comment">// 访问</span></span><br><span class="line">  <span class="type">int</span> n, m;         <span class="comment">// 两个点集中的顶点数量</span></span><br><span class="line">  <span class="type">int</span> dfn;          <span class="comment">// 时间戳记</span></span><br><span class="line">  <span class="type">int</span> res;          <span class="comment">// 匹配数</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">augment_path</span>(<span class="type">int</span> _n, <span class="type">int</span> _m) : <span class="built_in">n</span>(_n), <span class="built_in">m</span>(_m) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="number">0</span> &lt;= n &amp;&amp; <span class="number">0</span> &lt;= m);</span><br><span class="line">    pa = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">-1</span>);</span><br><span class="line">    pb = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m, <span class="number">-1</span>);</span><br><span class="line">    vis = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n);</span><br><span class="line">    g.<span class="built_in">resize</span>(n);</span><br><span class="line">    res = <span class="number">0</span>;</span><br><span class="line">    dfn = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="number">0</span> &lt;= from &amp;&amp; from &lt; n &amp;&amp; <span class="number">0</span> &lt;= to &amp;&amp; to &lt; m);</span><br><span class="line">    g[from].<span class="built_in">push_back</span>(to);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    vis[v] = dfn;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> u : g[v]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (pb[u] == <span class="number">-1</span>) &#123;</span><br><span class="line">        pb[u] = v;</span><br><span class="line">        pa[v] = u;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> u : g[v]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (vis[pb[u]] != dfn &amp;&amp; <span class="built_in">dfs</span>(pb[u])) &#123;</span><br><span class="line">        pa[v] = u;</span><br><span class="line">        pb[u] = v;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      dfn++;</span><br><span class="line">      <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pa[i] == <span class="number">-1</span> &amp;&amp; <span class="built_in">dfs</span>(i)) &#123;</span><br><span class="line">          cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (cnt == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      res += cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>acm</category>
        <category>图论</category>
        <category>图的匹配</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>二分图最大权匹配</title>
    <url>/2024/05/30/acm/%E5%9B%BE%E8%AE%BA/%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9C%80%E5%A4%A7%E6%9D%83%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<h1 id="二分图最大权匹配"><a href="#二分图最大权匹配" class="headerlink" title="二分图最大权匹配"></a>二分图最大权匹配</h1><blockquote>
<p>二分图中边权和最大的匹配</p>
</blockquote>
<h2 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h2><blockquote>
<p>n个顶点，算法复杂度为O（nnn）</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">505</span>;</span><br><span class="line"><span class="type">int</span> line[N][N];</span><br><span class="line"><span class="type">int</span> girl[N],used[N];</span><br><span class="line"><span class="type">int</span> k,m,n;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">found</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(line[x][i]&amp;&amp;!used[i])</span><br><span class="line">        &#123;</span><br><span class="line">            used[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(girl[i]==<span class="number">0</span>||<span class="built_in">found</span>(girl[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                girl[i]=x;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;k)&amp;&amp;k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;m,&amp;n);</span><br><span class="line">        <span class="built_in">memset</span>(line,<span class="number">0</span>,<span class="built_in">sizeof</span>(line));</span><br><span class="line">        <span class="built_in">memset</span>(girl,<span class="number">0</span>,<span class="built_in">sizeof</span>(girl));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;k; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">            line[x][y]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memset</span>(used,<span class="number">0</span>,<span class="built_in">sizeof</span>(used));</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">found</span>(i)) sum++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>acm</category>
        <category>图论</category>
        <category>图的匹配</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>双向bfs</title>
    <url>/2024/05/30/acm/%E5%9B%BE%E8%AE%BA/%E5%8F%8C%E5%90%91bfs/</url>
    <content><![CDATA[<h1 id="双向bfs"><a href="#双向bfs" class="headerlink" title="双向bfs"></a>双向bfs</h1><blockquote>
<p>适用于知道起点和终点的状态下使用，从两个方向开始bfs，</p>
<p>可以设置两个队列，一个队列保存从起点开始搜索的状态，另一个队列用来保存从终点开始搜索的状态，如果某一个状态下出现相交的情况，那么就出现了答案</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> P pair<span class="string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//记录下当前状态, 从前往后搜索值为1，从后往前搜索值为2，如果某状态下，当前节点和准备扩展节点的状态相加为3，说明相遇</span></span><br><span class="line">queue &lt;P&gt; q1, q2; </span><br><span class="line"><span class="type">int</span> r, c, ans, dis[<span class="number">45</span>][<span class="number">45</span>], vst[<span class="number">45</span>][<span class="number">45</span>];</span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">char</span> m[<span class="number">45</span>][<span class="number">45</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dbfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">bool</span> flag;</span><br><span class="line">	q1.<span class="built_in">push</span>(<span class="built_in">P</span>(<span class="number">1</span>, <span class="number">1</span>)), dis[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>, vst[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>; <span class="comment">//从前搜</span></span><br><span class="line">	q2.<span class="built_in">push</span>(<span class="built_in">P</span>(r, c)), dis[r][c] = <span class="number">1</span>, vst[r][c] = <span class="number">2</span>; <span class="comment">//从后搜</span></span><br><span class="line">	<span class="keyword">while</span>(!q1.<span class="built_in">empty</span>() &amp;&amp; !q2.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="type">int</span> x0, y0;</span><br><span class="line">		<span class="keyword">if</span>(q1.<span class="built_in">size</span>() &gt; q2.<span class="built_in">size</span>()) &#123; <span class="comment">//每次扩展搜索树小的队列 flag=1扩展前搜的队列，flag=0扩展后搜的队列</span></span><br><span class="line">			x0 = q2.<span class="built_in">front</span>().first, y0 = q2.<span class="built_in">front</span>().second;</span><br><span class="line">			q2.<span class="built_in">pop</span>();</span><br><span class="line">			flag = <span class="number">0</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			x0 = q1.<span class="built_in">front</span>().first, y0 = q1.<span class="built_in">front</span>().second;</span><br><span class="line">			q1.<span class="built_in">pop</span>();</span><br><span class="line">			flag = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">			<span class="type">int</span> nx = x0 + dx[i];</span><br><span class="line">			<span class="type">int</span> ny = y0 + dy[i];</span><br><span class="line">			<span class="keyword">if</span>(nx &gt;= <span class="number">1</span> &amp;&amp; nx &lt;= r &amp;&amp; ny &gt;= <span class="number">1</span> &amp;&amp; ny &lt;= c &amp;&amp; m[nx][ny] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span>(!dis[nx][ny]) &#123;</span><br><span class="line">					dis[nx][ny] = dis[x0][y0] + <span class="number">1</span>;</span><br><span class="line">					vst[nx][ny] = vst[x0][y0];</span><br><span class="line">					<span class="keyword">if</span>(flag) q1.<span class="built_in">push</span>(<span class="built_in">P</span>(nx, ny));</span><br><span class="line">					<span class="keyword">else</span> q2.<span class="built_in">push</span>(<span class="built_in">P</span>(nx, ny));</span><br><span class="line">				&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">if</span>(vst[x0][y0] + vst[nx][ny]== <span class="number">3</span>) &#123; <span class="comment">//相遇</span></span><br><span class="line">						ans = dis[nx][ny] + dis[x0][y0];</span><br><span class="line">						<span class="keyword">return</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; r &gt;&gt; c;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= r; i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= c; j++)</span><br><span class="line">			cin &gt;&gt; m[i][j];</span><br><span class="line">	<span class="built_in">dbfs</span>(); </span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>acm</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>分层图</title>
    <url>/2024/05/30/acm/%E5%9B%BE%E8%AE%BA/%E5%88%86%E5%B1%82%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="分层图"><a href="#分层图" class="headerlink" title="分层图"></a>分层图</h1><p>当我们要进行图的遍历的时候，有时会进行状态的变化，此时我们可以开多个维度的图，每种维度代表一种状态，当状态改变时就可以转移到另一个维度进行推进；</p>
<h2 id="1-wyh的吃鸡"><a href="#1-wyh的吃鸡" class="headerlink" title="1.wyh的吃鸡"></a>1.wyh的吃鸡</h2><p>  假设地图为n*n的一个图，图中有且仅有一块X的联通快代表安全区域，有一个起点S代表缩圈的时候的起点，图中C代表的是车（保证车的数量小于等于100），标记为.的代表空地，可以任意通过，O代表障碍物不能通过。每次没有车的时候2s可以走一个格（只能走自己的上下左右4个方向），有车的话时间为1s走一个格  </p>
<p> 现在告诉你最多能坚持的时间为t秒，问你在t秒内（含t秒）能否从s点到达安全区域，能的话输出YES，并且输出最短时间，不能的话输出NO。</p>
<p>此题为<strong>bfs</strong>，同时使用<strong>优先队列</strong>优化，我们需要把时间较小的放到队列前面，同时需要注意状态的改变。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line">LL <span class="type">int</span> n,k;</span><br><span class="line"><span class="type">int</span> sx,sy;</span><br><span class="line"><span class="type">char</span> ju[<span class="number">105</span>][<span class="number">105</span>];<span class="comment">//保存图形</span></span><br><span class="line"><span class="type">bool</span> ask[<span class="number">3</span>][<span class="number">105</span>][<span class="number">105</span>];<span class="comment">//标记（第一个维度为不同状态，后面两个维度为坐标）</span></span><br><span class="line"><span class="type">bool</span> pd[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">note</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y;<span class="comment">//坐标</span></span><br><span class="line">    <span class="type">int</span> s;<span class="comment">//时间</span></span><br><span class="line">    <span class="type">int</span> c;<span class="comment">//状态</span></span><br><span class="line">    <span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> note&amp; p) <span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s&gt;p.s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//方向</span></span><br><span class="line"><span class="type">int</span> ax[<span class="number">5</span>],ay[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(pd,<span class="number">0</span>,<span class="keyword">sizeof</span> pd);</span><br><span class="line">    <span class="built_in">memset</span>(ask,<span class="number">0</span>,<span class="keyword">sizeof</span> ask);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ax[<span class="number">1</span>]=<span class="number">-1</span>,ay[<span class="number">1</span>]=<span class="number">0</span>;<span class="comment">//zuo</span></span><br><span class="line">    ax[<span class="number">2</span>]=<span class="number">1</span>,ay[<span class="number">2</span>]=<span class="number">0</span>;<span class="comment">//you</span></span><br><span class="line">    ax[<span class="number">3</span>]=<span class="number">0</span>,ay[<span class="number">3</span>]=<span class="number">-1</span>;<span class="comment">//shang</span></span><br><span class="line">    ax[<span class="number">4</span>]=<span class="number">0</span>,ay[<span class="number">4</span>]=<span class="number">1</span>;<span class="comment">//xia</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Clear</span>();</span><br><span class="line">        cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">            cin&gt;&gt;ju[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(ju[i][j]==<span class="string">&#x27;S&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    sx=i;</span><br><span class="line">                    sy=j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">1e9</span>;</span><br><span class="line">        priority_queue&lt;note&gt;q;</span><br><span class="line">        q.<span class="built_in">push</span>(note&#123;sx,sy,<span class="number">0</span>,<span class="number">2</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())<span class="comment">//bfs</span></span><br><span class="line">        &#123;</span><br><span class="line">            note tmp=q.<span class="built_in">top</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> x=tmp.x, y=tmp.y;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(ask[tmp.c][x][y]||ju[x][y]==<span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(x&lt;<span class="number">0</span>||x&gt;=n||y&lt;<span class="number">0</span>||y&gt;=n) </span><br><span class="line">                <span class="keyword">continue</span>;<span class="comment">//cout&lt;&lt;tmp.c&lt;&lt;&quot; &quot;&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;&quot; &quot;&lt;&lt;tmp.s&lt;&lt;endl;</span></span><br><span class="line">            <span class="keyword">if</span>(ju[x][y]==<span class="string">&#x27;X&#x27;</span>)&#123;</span><br><span class="line">                sum=<span class="built_in">min</span>(sum,tmp.s);<span class="comment">//找到更小的</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ask[tmp.c][x][y]=<span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> c=<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(ju[x][y]==<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">                c=<span class="number">1</span>;<span class="comment">//状态改变</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;++i)&#123;</span><br><span class="line">                <span class="type">int</span> tx=x+ax[i], ty=y+ay[i];</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;tx,ty,tmp.s+<span class="built_in">min</span>(tmp.c,c),<span class="built_in">min</span>(tmp.c,c)&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum&lt;=k)</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>&lt;&lt;sum&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-对于每个点都可以选择下一条边是否赋予权值为0-那么我们就可以将图画出k-1层1"><a href="#2-对于每个点都可以选择下一条边是否赋予权值为0-那么我们就可以将图画出k-1层1" class="headerlink" title="2.对于每个点都可以选择下一条边是否赋予权值为0,那么我们就可以将图画出k+1层1"></a>2.对于每个点都可以选择下一条边是否赋予权值为0,那么我们就可以将图画出k+1层1</h2><p> 代码实现：</p>
<p>我们可以将dis数组开成二维dis[i][j]表示<strong>到达i号结点,用了j次免费操作</strong>!<br>比如dis[2][0]表示到达2号结点,没有用免费操作,也就是在第一层图移动。 比如dis[2][3],到达2号结点用了3次免费操作,那么**下一次移动应该在第3&#x2F;4层图进行!**、</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">5e4</span>+<span class="number">10</span>;</span><br><span class="line">vector&lt;PII&gt;se[maxn];</span><br><span class="line"><span class="type">int</span> dis[maxn][<span class="number">20</span>];</span><br><span class="line"><span class="type">bool</span> vis[maxn][<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> n,m,k,s,t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> id,v,used;<span class="comment">//used使用了几次免费券,id为目标点，v为付出</span></span><br><span class="line">	<span class="built_in">node</span>()&#123;&#125;</span><br><span class="line">	<span class="built_in">node</span>(<span class="type">int</span> id,<span class="type">int</span> v,<span class="type">int</span> used): <span class="built_in">id</span>(id),<span class="built_in">v</span>(v),<span class="built_in">used</span>(used)&#123;&#125;<span class="comment">//构造器</span></span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> node&amp; a) <span class="type">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> a.v&lt;v;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dj</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">memset</span>(dis,<span class="number">0x3f3f3f3f</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">   priority_queue&lt;node&gt;qu;</span><br><span class="line">   qu.<span class="built_in">push</span>(<span class="built_in">node</span>(u,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">   dis[u][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span>(!qu.<span class="built_in">empty</span>())</span><br><span class="line">   &#123;</span><br><span class="line">      node tt=qu.<span class="built_in">top</span>();</span><br><span class="line">	  qu.<span class="built_in">pop</span>();</span><br><span class="line">	  <span class="type">int</span> q=tt.id;<span class="comment">//now</span></span><br><span class="line">	  <span class="type">int</span> p=tt.used;<span class="comment">//目前层数</span></span><br><span class="line">	  <span class="keyword">if</span>(vis[q][p])</span><br><span class="line">	  <span class="keyword">continue</span>;</span><br><span class="line">	  vis[q][p]=<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;se[q].<span class="built_in">size</span>();++i)</span><br><span class="line">	   &#123;</span><br><span class="line">		<span class="type">int</span> next=se[q][i].first;<span class="comment">//下一个连接点</span></span><br><span class="line">		<span class="type">int</span> val=se[q][i].second;<span class="comment">//代价</span></span><br><span class="line">		<span class="comment">//两种i情况。用免费和不用免费</span></span><br><span class="line">		<span class="comment">//不用免费</span></span><br><span class="line">		<span class="keyword">if</span>(dis[next][p]&gt;dis[q][p]+val)</span><br><span class="line">		&#123;</span><br><span class="line">			dis[next][p]=dis[q][p]+val;</span><br><span class="line">			qu.<span class="built_in">push</span>(<span class="built_in">node</span>(next,dis[next][p],p));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//用免费券</span></span><br><span class="line">		<span class="keyword">if</span>(p+<span class="number">1</span>&lt;=k&amp;&amp;dis[next][p+<span class="number">1</span>]&gt;dis[q][p]+<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			dis[next][p+<span class="number">1</span>]=dis[q][p];</span><br><span class="line">			qu.<span class="built_in">push</span>(<span class="built_in">node</span>(next,dis[next][p+<span class="number">1</span>],p+<span class="number">1</span>));</span><br><span class="line">		&#125;</span><br><span class="line">	   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;k&gt;&gt;s&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> a,b,c;</span><br><span class="line">		cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        se[a].<span class="built_in">push_back</span>(&#123;b,c&#125;);</span><br><span class="line">		se[b].<span class="built_in">push_back</span>(&#123;a,c&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dj</span>(s);</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=k;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		ans=<span class="built_in">min</span>(ans,dis[t][i]);</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>acm</category>
        <category>图论</category>
        <category>最短路径</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>最小树形图</title>
    <url>/2024/05/30/acm/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E5%B0%8F%E6%A0%91%E5%BD%A2%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="最小树形图"><a href="#最小树形图" class="headerlink" title="最小树形图"></a>最小树形图</h1><blockquote>
<p>有向图上的最小生成树称为最小树形图</p>
</blockquote>
<h2 id="Edmonds算法"><a href="#Edmonds算法" class="headerlink" title="Edmonds算法"></a>Edmonds算法</h2><p><code>O(nm)</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ans = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> u, v, root = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="built_in">f</span>(i, <span class="number">0</span>, n) in[i] = <span class="number">1e100</span>;</span><br><span class="line">    <span class="built_in">f</span>(i, <span class="number">0</span>, m) &#123;</span><br><span class="line">      u = e[i].s;</span><br><span class="line">      v = e[i].t;</span><br><span class="line">      <span class="keyword">if</span> (u != v &amp;&amp; e[i].w &lt; in[v]) &#123;</span><br><span class="line">        in[v] = e[i].w;</span><br><span class="line">        pre[v] = u;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">f</span>(i, <span class="number">0</span>, m) <span class="keyword">if</span> (i != root &amp;&amp; in[i] &gt; <span class="number">1e50</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> tn = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(id, <span class="number">-1</span>, <span class="keyword">sizeof</span> id);</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">-1</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">    in[root] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">f</span>(i, <span class="number">0</span>, n) &#123;</span><br><span class="line">      ans += in[i];</span><br><span class="line">      v = i;</span><br><span class="line">      <span class="keyword">while</span> (vis[v] != i &amp;&amp; id[v] == <span class="number">-1</span> &amp;&amp; v != root) &#123;</span><br><span class="line">        vis[v] = i;</span><br><span class="line">        v = pre[v];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (v != root &amp;&amp; id[v] == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> u = pre[v]; u != v; u = pre[u]) id[u] = tn;</span><br><span class="line">        id[v] = tn++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tn == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">f</span>(i, <span class="number">0</span>, n) <span class="keyword">if</span> (id[i] == <span class="number">-1</span>) id[i] = tn++;</span><br><span class="line">    <span class="built_in">f</span>(i, <span class="number">0</span>, m) &#123;</span><br><span class="line">      u = e[i].s;</span><br><span class="line">      v = e[i].t;</span><br><span class="line">      e[i].s = id[u];</span><br><span class="line">      e[i].t = id[v];</span><br><span class="line">      <span class="keyword">if</span> (e[i].s != e[i].t) e[i].w -= in[v];</span><br><span class="line">    &#125;</span><br><span class="line">    n = tn;</span><br><span class="line">    root = id[root];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Tarjan算法"><a href="#Tarjan算法" class="headerlink" title="Tarjan算法"></a>Tarjan算法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 102</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line">  <span class="type">int</span> fa[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">UnionFind</span>() &#123; <span class="built_in">memset</span>(fa, <span class="number">0</span>, <span class="built_in">sizeof</span>(fa)); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123; <span class="built_in">memset</span>(fa + <span class="number">1</span>, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="type">int</span>) * n); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> fa[x] ? fa[x] = <span class="built_in">find</span>(fa[x]) : x; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> <span class="keyword">operator</span>[](<span class="type">int</span> x) &#123; <span class="keyword">return</span> <span class="built_in">find</span>(x); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">  <span class="type">int</span> u, v, w, w0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Heap</span> &#123;</span><br><span class="line">  Edge *e;</span><br><span class="line">  <span class="type">int</span> rk, constant;</span><br><span class="line">  Heap *lch, *rch;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Heap</span>(Edge *_e) : <span class="built_in">e</span>(_e), <span class="built_in">rk</span>(<span class="number">1</span>), <span class="built_in">constant</span>(<span class="number">0</span>), <span class="built_in">lch</span>(<span class="literal">NULL</span>), <span class="built_in">rch</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lch) lch-&gt;constant += constant;</span><br><span class="line">    <span class="keyword">if</span> (rch) rch-&gt;constant += constant;</span><br><span class="line">    e-&gt;w += constant;</span><br><span class="line">    constant = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Heap *<span class="title">merge</span><span class="params">(Heap *x, Heap *y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!x) <span class="keyword">return</span> y;</span><br><span class="line">  <span class="keyword">if</span> (!y) <span class="keyword">return</span> x;</span><br><span class="line">  <span class="keyword">if</span> (x-&gt;e-&gt;w + x-&gt;constant &gt; y-&gt;e-&gt;w + y-&gt;constant) <span class="built_in">swap</span>(x, y);</span><br><span class="line">  x-&gt;<span class="built_in">push</span>();</span><br><span class="line">  x-&gt;rch = <span class="built_in">merge</span>(x-&gt;rch, y);</span><br><span class="line">  <span class="keyword">if</span> (!x-&gt;lch || x-&gt;lch-&gt;rk &lt; x-&gt;rch-&gt;rk) <span class="built_in">swap</span>(x-&gt;lch, x-&gt;rch);</span><br><span class="line">  <span class="keyword">if</span> (x-&gt;rch)</span><br><span class="line">    x-&gt;rk = x-&gt;rch-&gt;rk + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    x-&gt;rk = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Edge *<span class="title">extract</span><span class="params">(Heap *&amp;x)</span> </span>&#123;</span><br><span class="line">  Edge *r = x-&gt;e;</span><br><span class="line">  x-&gt;<span class="built_in">push</span>();</span><br><span class="line">  x = <span class="built_in">merge</span>(x-&gt;lch, x-&gt;rch);</span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;Edge&gt; in[maxn];</span><br><span class="line"><span class="type">int</span> n, m, fa[maxn &lt;&lt; <span class="number">1</span>], nxt[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line">Edge *ed[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line">Heap *Q[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line">UnionFind id;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">contract</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">bool</span> mark[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line">  <span class="comment">// 将图上的每一个结点与其相连的那些结点进行记录。</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    queue&lt;Heap *&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; in[i].<span class="built_in">size</span>(); j++) q.<span class="built_in">push</span>(<span class="keyword">new</span> <span class="built_in">Heap</span>(&amp;in[i][j]));</span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      Heap *u = q.<span class="built_in">front</span>();</span><br><span class="line">      q.<span class="built_in">pop</span>();</span><br><span class="line">      Heap *v = q.<span class="built_in">front</span>();</span><br><span class="line">      q.<span class="built_in">pop</span>();</span><br><span class="line">      q.<span class="built_in">push</span>(<span class="built_in">merge</span>(u, v));</span><br><span class="line">    &#125;</span><br><span class="line">    Q[i] = q.<span class="built_in">front</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  mark[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>, p; Q[a]; b = a, mark[b] = <span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 寻找最小入边以及其端点，保证无环。</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      ed[a] = <span class="built_in">extract</span>(Q[a]);</span><br><span class="line">      a = id[ed[a]-&gt;u];</span><br><span class="line">    &#125; <span class="keyword">while</span> (a == b &amp;&amp; Q[a]);</span><br><span class="line">    <span class="keyword">if</span> (a == b) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> (!mark[a]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">// 对发现的环进行收缩，以及环内的结点重新编号，总权值更新。</span></span><br><span class="line">    <span class="keyword">for</span> (a = b, n++; a != n; a = p) &#123;</span><br><span class="line">      id.fa[a] = fa[a] = n;</span><br><span class="line">      <span class="keyword">if</span> (Q[a]) Q[a]-&gt;constant -= ed[a]-&gt;w;</span><br><span class="line">      Q[n] = <span class="built_in">merge</span>(Q[n], Q[a]);</span><br><span class="line">      p = id[ed[a]-&gt;u];</span><br><span class="line">      nxt[p == n ? b : p] = a;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">expand</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> r)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">expand_iter</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  ll r = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> u = nxt[x]; u != x; u = nxt[u]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ed[u]-&gt;w0 &gt;= INF)</span><br><span class="line">      <span class="keyword">return</span> INF;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      r += <span class="built_in">expand</span>(ed[u]-&gt;v, u) + ed[u]-&gt;w0;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">expand</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">  ll r = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (; x != t; x = fa[x]) &#123;</span><br><span class="line">    r += <span class="built_in">expand_iter</span>(x);</span><br><span class="line">    <span class="keyword">if</span> (r &gt;= INF) <span class="keyword">return</span> INF;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">link</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span> </span>&#123; in[v].<span class="built_in">push_back</span>(&#123;u, v, w, w&#125;); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> rt;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;m, &amp;rt);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="type">int</span> u, v, w;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">    <span class="built_in">link</span>(u, v, w);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 保证强连通</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">link</span>(i &gt; <span class="number">1</span> ? i - <span class="number">1</span> : n, i, INF);</span><br><span class="line">  <span class="built_in">contract</span>();</span><br><span class="line">  ll ans = <span class="built_in">expand</span>(rt, n);</span><br><span class="line">  <span class="keyword">if</span> (ans &gt;= INF)</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>acm</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>最小生成树</title>
    <url>/2024/05/30/acm/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
    <content><![CDATA[<h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><h2 id="prim"><a href="#prim" class="headerlink" title="prim"></a>prim</h2><blockquote>
<p>稀疏图，采用邻接矩阵进行存储边之间的关系</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// prim 算法求最小生成树 </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">505</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> vis[maxn],dist[maxn];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> u,v,w;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">(<span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">	dist[pos] = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 一共有 n 个点,就需要 遍历 n 次,每次寻找一个权值最小的点,记录其下标</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">		<span class="type">int</span> cur = <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(!vis[j] &amp;&amp; (cur == <span class="number">-1</span> || dist[j] &lt; dist[cur])) &#123;</span><br><span class="line">				cur = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 这里需要提前终止</span></span><br><span class="line">		<span class="keyword">if</span>(dist[cur] &gt;= INF) <span class="keyword">return</span> INF;</span><br><span class="line">		sum += dist[cur];</span><br><span class="line">		vis[cur] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k ++) &#123;</span><br><span class="line">		    <span class="comment">// 只更新还没有找到的最小权值</span></span><br><span class="line">			<span class="keyword">if</span>(!vis[k]) dist[k] = <span class="built_in">min</span>(dist[k],a[cur][k]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="built_in">memset</span>(a,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(a));</span><br><span class="line">	<span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dist));</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">		a[u][v] = <span class="built_in">min</span>(a[u][v],w);</span><br><span class="line">		a[v][u] = <span class="built_in">min</span>(a[v][u],w);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> value = <span class="built_in">prim</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(value &gt;= INF) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,sum);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="kruskal"><a href="#kruskal" class="headerlink" title="kruskal"></a>kruskal</h2><blockquote>
<p>稠密图，采用邻接表进行存储边之间的关系</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Kruskal 算法求最小生成树 </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2e5</span> + <span class="number">10</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">	<span class="type">int</span> x,y,z;</span><br><span class="line">&#125;edge[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.z &lt; b.z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fa[maxn];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> u,v,w; </span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> sum;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x == fa[x] ? x : fa[x] = <span class="built_in">get</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;edge[i].x,&amp;edge[i].y,&amp;edge[i].z);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">		fa[i] = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(edge + <span class="number">1</span>,edge + <span class="number">1</span> + m,cmp);</span><br><span class="line">	<span class="comment">// 每次加入一条最短的边</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) &#123;</span><br><span class="line">		<span class="type">int</span> x = <span class="built_in">get</span>(edge[i].x);</span><br><span class="line">		<span class="type">int</span> y = <span class="built_in">get</span>(edge[i].y);</span><br><span class="line">		<span class="keyword">if</span>(x == y) <span class="keyword">continue</span>;</span><br><span class="line">		fa[y] = x;</span><br><span class="line">		sum += edge[i].z;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(i == fa[i]) ans ++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(ans &gt; <span class="number">1</span>) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,sum);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>acm</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>拓扑排序</title>
    <url>/2024/05/30/acm/%E5%9B%BE%E8%AE%BA/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><blockquote>
<p> 给一个有向无环图排序</p>
<p> 每次删除一个入度边个数为 0 的点，并刷新其他点的出度边个数</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> p 80112002</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;se[maxn];</span><br><span class="line"><span class="type">int</span> in[maxn],out[maxn];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt;line;</span><br><span class="line">ll dp[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">   &#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    se[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">    ++in[a];<span class="comment">//入度</span></span><br><span class="line">    ++out[b];<span class="comment">//出度</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">   &#123;</span><br><span class="line">    <span class="keyword">if</span>(!in[i])</span><br><span class="line">    &#123;</span><br><span class="line">    dp[i] = <span class="number">1</span>;</span><br><span class="line">    line.<span class="built_in">push</span>(i);<span class="comment">//放入度为0的点</span></span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">while</span>(!line.<span class="built_in">empty</span>())</span><br><span class="line">   &#123;</span><br><span class="line">    <span class="type">int</span> now = line.<span class="built_in">front</span>();</span><br><span class="line">    line.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;se[now].<span class="built_in">size</span>();++i)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> next = se[now][i];</span><br><span class="line">      --in[next];</span><br><span class="line">      dp[next] = (dp[now] + dp[next])%p;</span><br><span class="line">      <span class="keyword">if</span>(!in[next])</span><br><span class="line">      &#123;</span><br><span class="line">        line.<span class="built_in">push</span>(next);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   ll sum=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">   &#123;</span><br><span class="line">    <span class="keyword">if</span>(!out[i])</span><br><span class="line">    &#123;</span><br><span class="line">      sum = (sum+dp[i])%p;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>acm</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>最近公共祖先</title>
    <url>/2024/05/30/acm/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    <content><![CDATA[<h1 id="最近公共祖先LCA"><a href="#最近公共祖先LCA" class="headerlink" title="最近公共祖先LCA"></a>最近公共祖先LCA</h1><h2 id="倍增算法"><a href="#倍增算法" class="headerlink" title="倍增算法"></a>倍增算法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&quot;\n&quot;</span></span></span><br><span class="line"><span class="type">int</span> head[N], to[N&lt;&lt;<span class="number">1</span>], nex[N&lt;&lt;<span class="number">1</span>], cnt=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> fa[N][<span class="number">21</span>], dep[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	to[cnt] = y;</span><br><span class="line">	nex[cnt] = head[x];</span><br><span class="line">	head[x] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">	dep[rt] = dep[f] + <span class="number">1</span>;</span><br><span class="line">	fa[rt][<span class="number">0</span>] = f;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; i) &lt;= dep[rt]; i++)&#123; <span class="comment">//进制由小到大递推 </span></span><br><span class="line">		fa[rt][i] = fa[fa[rt][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = head[rt]; i; i = nex[i])&#123;</span><br><span class="line">		<span class="keyword">if</span>(to[i] == f)&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">dfs</span>(to[i], rt);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LCA</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(dep[x] &lt; dep[y])&#123;</span><br><span class="line">		<span class="built_in">swap</span>(x, y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i--)&#123; <span class="comment">//进制由大到小开始组合 </span></span><br><span class="line">		<span class="keyword">if</span>(dep[fa[x][i]] &gt;= dep[y])&#123;</span><br><span class="line">			x = fa[x][i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">if</span>(x == y)&#123; <span class="comment">//注意特判 </span></span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i--)&#123; <span class="comment">//进制从小到大开始组合 </span></span><br><span class="line">		<span class="keyword">if</span>(fa[x][i] != fa[y][i])&#123;</span><br><span class="line">			x = fa[x][i];</span><br><span class="line">			y = fa[y][i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fa[x][<span class="number">0</span>]; <span class="comment">//这一步尤其考虑，为什么x,y不是LCA，二期父节点一定是LCA </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	<span class="type">int</span> n, m, s;</span><br><span class="line">	<span class="keyword">while</span>(cin &gt;&gt; n &gt;&gt; m &gt;&gt; s)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="built_in">sizeof</span>(head));</span><br><span class="line">		cnt = <span class="number">1</span>;</span><br><span class="line">		<span class="type">int</span> x, y;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">			cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">			<span class="built_in">add</span>(x, y);</span><br><span class="line">			<span class="built_in">add</span>(y, x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">dfs</span>(s, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">			cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">			cout &lt;&lt; <span class="built_in">LCA</span>(x, y) &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Tarjan算法"><a href="#Tarjan算法" class="headerlink" title="Tarjan算法"></a>Tarjan算法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&quot;\n&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="type">int</span> head[N], to[N&lt;&lt;<span class="number">1</span>], nex[N&lt;&lt;<span class="number">1</span>], cnt ;</span><br><span class="line"><span class="type">int</span> visit[N], fa[N];</span><br><span class="line"><span class="type">int</span> qhead[N&lt;&lt;<span class="number">1</span>], qnex[N&lt;&lt;<span class="number">1</span>], qcnt = <span class="number">1</span>, qid[N&lt;&lt;<span class="number">1</span>], ans[N], qto[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	to[cnt] = y;</span><br><span class="line">	nex[cnt] = head[x];</span><br><span class="line">	head[x] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_query</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">	qto[qcnt] = y;</span><br><span class="line">	qnex[qcnt] = qhead[x];</span><br><span class="line">	qid[qcnt] = w;</span><br><span class="line">	qhead[x] = qcnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findx</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(fa[x] == x)&#123;</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fa[x] = <span class="built_in">findx</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = head[rt]; i; i = nex[i])&#123;</span><br><span class="line">		<span class="keyword">if</span>(to[i] == f)<span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">tarjan</span>(to[i], rt);</span><br><span class="line">		fa[to[i]] = rt;</span><br><span class="line">	&#125;</span><br><span class="line">	visit[rt] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = qhead[rt]; i; i = qnex[i])&#123;</span><br><span class="line">		<span class="keyword">if</span>(visit[qto[i]] == <span class="number">0</span>)<span class="keyword">continue</span>; </span><br><span class="line">		ans[qid[i]] = <span class="built_in">findx</span>(qto[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	<span class="type">int</span> n, m, s;</span><br><span class="line">	<span class="keyword">while</span>(cin &gt;&gt; n &gt;&gt; m &gt;&gt; s)&#123;</span><br><span class="line">		<span class="type">int</span> x, y;</span><br><span class="line">		<span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="built_in">sizeof</span>(head));</span><br><span class="line">		cnt = <span class="number">1</span>, qcnt = <span class="number">1</span>;</span><br><span class="line">		<span class="built_in">memset</span>(qhead, <span class="number">0</span>, <span class="built_in">sizeof</span>(qhead));</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">			cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">			<span class="built_in">add_edge</span>(x, y);</span><br><span class="line">			<span class="built_in">add_edge</span>(y, x);</span><br><span class="line">			fa[i] = i;</span><br><span class="line">		&#125;</span><br><span class="line">		fa[n] = n;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">			cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">			<span class="built_in">add_query</span>(x, y, i);</span><br><span class="line">			<span class="built_in">add_query</span>(y, x, i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">tarjan</span>(s, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">			cout &lt;&lt; ans[i] &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>acm</category>
        <category>图论</category>
        <category>树上问题</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>树的重心</title>
    <url>/2024/05/30/acm/%E5%9B%BE%E8%AE%BA/%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83/</url>
    <content><![CDATA[<h1 id="树的重心"><a href="#树的重心" class="headerlink" title="树的重心"></a>树的重心</h1><blockquote>
<p>如果在树中选择某个节点并删除，这棵树将分为若干棵子树，统计子树节点数并记录最大值。取遍树上所有节点，使此最大值取到最小的节点被称为整个树的重心。</p>
</blockquote>
<ul>
<li>树的重心如果不唯一，则至多有两个，且这两个重心相邻。</li>
<li>以树的重心为根时，所有子树的大小都不超过整棵树大小的一半。</li>
<li>树中所有点到某个点的距离和中，到重心的距离和是最小的；如果有两个重心，那么到它们的距离和一样。</li>
<li>把两棵树通过一条边相连得到一棵新的树，那么新的树的重心在连接原来两棵树的重心的路径上。</li>
<li>在一棵树上添加或删除一个叶子，那么它的重心最多只移动一条边的距离</li>
</ul>
]]></content>
      <categories>
        <category>acm</category>
        <category>图论</category>
        <category>树上问题</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>最短路径</title>
    <url>/2024/05/30/acm/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h1 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h1><h2 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h2><blockquote>
<p>不能有负环</p>
<p>适用于任何图</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= n; k++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (x = <span class="number">1</span>; x &lt;= n; x++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (y = <span class="number">1</span>; y &lt;= n; y++) &#123;</span><br><span class="line">      f[x][y] = <span class="built_in">min</span>(f[x][y], f[x][k] + f[k][y]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Bellman-Ford算法"><a href="#Bellman-Ford算法" class="headerlink" title="Bellman-Ford算法"></a>Bellman-Ford算法</h2><blockquote>
<p>可以求出有负权的图的最短路，并可以对最短路不存在的情况进行判断</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">  <span class="type">int</span> u, v, w;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;Edge&gt; edge;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dis[MAXN], u, v, w;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bellmanford</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> s)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dis));</span><br><span class="line">  dis[s] = <span class="number">0</span>;</span><br><span class="line">  <span class="type">bool</span> flag = <span class="literal">false</span>;  <span class="comment">// 判断一轮循环过程中是否发生松弛操作</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; edge.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">      u = edge[j].u, v = edge[j].v, w = edge[j].w;</span><br><span class="line">      <span class="keyword">if</span> (dis[u] == INF) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="comment">// 无穷大与常数加减仍然为无穷大</span></span><br><span class="line">      <span class="comment">// 因此最短路长度为 INF 的点引出的边不可能发生松弛操作</span></span><br><span class="line">      <span class="keyword">if</span> (dis[v] &gt; dis[u] + w) &#123;</span><br><span class="line">        dis[v] = dis[u] + w;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有可以松弛的边时就停止算法</span></span><br><span class="line">    <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 第 n 轮循环仍然可以松弛时说明 s 点可以抵达一个负环</span></span><br><span class="line">  <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="队列优化"><a href="#队列优化" class="headerlink" title="队列优化"></a>队列优化</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span> &#123;</span><br><span class="line">  <span class="type">int</span> v, w;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;edge&gt; e[maxn];</span><br><span class="line"><span class="type">int</span> dis[maxn], cnt[maxn], vis[maxn];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> s)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(dis, <span class="number">63</span>, <span class="built_in">sizeof</span>(dis));</span><br><span class="line">  dis[s] = <span class="number">0</span>, vis[s] = <span class="number">1</span>;</span><br><span class="line">  q.<span class="built_in">push</span>(s);</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>(), vis[u] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> ed : e[u]) &#123;</span><br><span class="line">      <span class="type">int</span> v = ed.v, w = ed.w;</span><br><span class="line">      <span class="keyword">if</span> (dis[v] &gt; dis[u] + w) &#123;</span><br><span class="line">        dis[v] = dis[u] + w;</span><br><span class="line">        cnt[v] = cnt[u] + <span class="number">1</span>;  <span class="comment">// 记录最短路经过的边数</span></span><br><span class="line">        <span class="keyword">if</span> (cnt[v] &gt;= n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 在不经过负环的情况下，最短路至多经过 n - 1 条边</span></span><br><span class="line">        <span class="comment">// 因此如果经过了多于 n 条边，一定说明经过了负环</span></span><br><span class="line">        <span class="keyword">if</span> (!vis[v]) q.<span class="built_in">push</span>(v), vis[v] = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h2><blockquote>
<p>求解非负权图上单源最短路径的算法</p>
</blockquote>
<h3 id="暴力实现"><a href="#暴力实现" class="headerlink" title="暴力实现"></a>暴力实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span> &#123;</span><br><span class="line">  <span class="type">int</span> v, w;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;edge&gt; e[maxn];</span><br><span class="line"><span class="type">int</span> dis[maxn], vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> s)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(dis, <span class="number">63</span>, <span class="built_in">sizeof</span>(dis));</span><br><span class="line">  dis[s] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="type">int</span> u = <span class="number">0</span>, mind = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">      <span class="keyword">if</span> (!vis[j] &amp;&amp; dis[j] &lt; mind) u = j, mind = dis[j];</span><br><span class="line">    vis[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> ed : e[u]) &#123;</span><br><span class="line">      <span class="type">int</span> v = ed.v, w = ed.w;</span><br><span class="line">      <span class="keyword">if</span> (dis[v] &gt; dis[u] + w) dis[v] = dis[u] + w;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="优先队列实现"><a href="#优先队列实现" class="headerlink" title="优先队列实现"></a>优先队列实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span> &#123;</span><br><span class="line">  <span class="type">int</span> v, w;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">  <span class="type">int</span> dis, u;</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> node&amp; a) <span class="type">const</span> &#123; <span class="keyword">return</span> dis &gt; a.dis; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;edge&gt; e[maxn];</span><br><span class="line"><span class="type">int</span> dis[maxn], vis[maxn];</span><br><span class="line">priority_queue&lt;node, vector&lt;node&gt;, greater&lt;node&gt; &gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> s)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(dis, <span class="number">63</span>, <span class="built_in">sizeof</span>(dis));</span><br><span class="line">  dis[s] = <span class="number">0</span>;</span><br><span class="line">  q.<span class="built_in">push</span>(&#123;<span class="number">0</span>, s&#125;);</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="type">int</span> u = q.<span class="built_in">top</span>().u;</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">if</span> (vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">    vis[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> ed : e[u]) &#123;</span><br><span class="line">      <span class="type">int</span> v = ed.v, w = ed.w;</span><br><span class="line">      <span class="keyword">if</span> (dis[v] &gt; dis[u] + w) &#123;</span><br><span class="line">        dis[v] = dis[u] + w;</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;dis[v], v&#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>acm</category>
        <category>图论</category>
        <category>最短路径</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>树的直径</title>
    <url>/2024/05/30/acm/%E5%9B%BE%E8%AE%BA/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/</url>
    <content><![CDATA[<h1 id="树的直径"><a href="#树的直径" class="headerlink" title="树的直径"></a>树的直径</h1><blockquote>
<p>树上任意两节点之间最长的简单路径即为树的直径</p>
</blockquote>
<h2 id="两次DFS"><a href="#两次DFS" class="headerlink" title="两次DFS"></a>两次DFS</h2><blockquote>
<p>若存在负权边，则无法使用两次DFS的方式求解直径</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, c, d[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; E[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> v : E[u]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">    d[v] = d[u] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (d[v] &gt; d[c]) c = v;</span><br><span class="line">    <span class="built_in">dfs</span>(v, u);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="type">int</span> u, v;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">    E[u].<span class="built_in">push_back</span>(v), E[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  d[c] = <span class="number">0</span>, <span class="built_in">dfs</span>(c, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, d[c]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果需要求出一条直径上所有节点，则可以在第二次DFS的过程中，记录每个点的前序节点，即可从直径的一端一路向前，遍历直径上所有的节点</p>
<h2 id="树形dp"><a href="#树形dp" class="headerlink" title="树形dp"></a>树形dp</h2><h3 id="实现1"><a href="#实现1" class="headerlink" title="实现1"></a>实现1</h3><p><code>d1</code>和<code>d2</code>分别为每个节点作为字树的根向下，所能延伸的最长路径长度<code>d1</code>与此长路径<code>d2</code>，那么直径就是对于每个点，该点<code>d1+d2</code>所能取到的值中的最大值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, d = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> d1[N], d2[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; E[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">  d1[u] = d2[u] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> v : E[u]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(v, u);</span><br><span class="line">    <span class="type">int</span> t = d1[v] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (t &gt; d1[u])</span><br><span class="line">      d2[u] = d1[u], d1[u] = t;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (t &gt; d2[u])</span><br><span class="line">      d2[u] = t;</span><br><span class="line">  &#125;</span><br><span class="line">  d = <span class="built_in">max</span>(d, d1[u] + d2[u]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="type">int</span> u, v;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">    E[u].<span class="built_in">push_back</span>(v), E[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, d);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="实现2"><a href="#实现2" class="headerlink" title="实现2"></a>实现2</h3><p><code>dp[u]</code>:以u为根的子树中，从u出发的最长路径。</p>
<p>转移方程：<code>dp[u] = max(dp[u],dp[v]+w(u,v)) , w(u,v)表示所经过边的权重</code> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, d = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> dp[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; E[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> v : E[u]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(v, u);</span><br><span class="line">    d = <span class="built_in">max</span>(d, dp[u] + dp[v] + <span class="number">1</span>);</span><br><span class="line">    dp[u] = <span class="built_in">max</span>(dp[u], dp[v] + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="type">int</span> u, v;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">    E[u].<span class="built_in">push_back</span>(v), E[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, d);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>acm</category>
        <category>图论</category>
        <category>树上问题</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>欧拉图</title>
    <url>/2024/05/30/acm/%E5%9B%BE%E8%AE%BA/%E6%AC%A7%E6%8B%89%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="欧拉图"><a href="#欧拉图" class="headerlink" title="欧拉图"></a>欧拉图</h1><blockquote>
<p>欧拉回路：通过图中每条边恰好一次的回路</p>
<p>欧拉通路：通过图中每条边恰好一次的通路</p>
<p>欧拉图：具有欧拉回路的图</p>
<p>半欧拉图：具有欧拉通路但不具有欧拉回路的图</p>
<p>欧拉图中所有顶点的度数都是偶数</p>
</blockquote>
<ul>
<li><p>无向图是欧拉图当且仅当：</p>
<ul>
<li><p>非零度顶点是连通的</p>
</li>
<li><p>顶点的度数都是偶数</p>
</li>
</ul>
</li>
<li><p>无向图是半欧拉图当且仅当：</p>
<ul>
<li><p>非零度顶点是连通的</p>
</li>
<li><p>恰有 2 个奇度顶点</p>
</li>
</ul>
</li>
<li><p>有向图是欧拉图当且仅当：</p>
<ul>
<li><p>非零度顶点是强连通的</p>
</li>
<li><p>每个顶点的入度和出度相等</p>
</li>
</ul>
</li>
<li><p>有向图是半欧拉图当且仅当：</p>
<ul>
<li><p>非零度顶点是弱连通的</p>
</li>
<li><p>至多一个顶点的出度与入度之差为 1</p>
</li>
<li><p>至多一个顶点的入度与出度之差为 1</p>
</li>
<li><p>其他顶点的入度和出度相等</p>
</li>
</ul>
</li>
</ul>
<h2 id="求欧拉回路"><a href="#求欧拉回路" class="headerlink" title="求欧拉回路"></a>求欧拉回路</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> ans[<span class="number">200</span>];</span><br><span class="line"><span class="type">int</span> top;</span><br><span class="line"><span class="type">int</span> N,M;</span><br><span class="line"><span class="type">int</span> mp[<span class="number">200</span>][<span class="number">200</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    top++;</span><br><span class="line">    ans[top]=x;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;=N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(mp[x][i]&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            mp[x][i]=mp[i][x]=<span class="number">0</span>;<span class="comment">///删除此边</span></span><br><span class="line">            <span class="built_in">dfs</span>(i);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fleury</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> brige,i;</span><br><span class="line">    top=<span class="number">1</span>;</span><br><span class="line">    ans[top]=x;<span class="comment">///将起点放入Euler路径中</span></span><br><span class="line">    <span class="keyword">while</span>(top&gt;=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        brige=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;=N; i++) <span class="comment">/// 试图搜索一条边不是割边（桥）</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(mp[ans[top]][i]&gt;<span class="number">0</span>)<span class="comment">///存在一条可以扩展的边</span></span><br><span class="line">            &#123;</span><br><span class="line">                brige=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!brige)<span class="comment">/// 如果没有点可以扩展，输出并出栈</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ans[top]);</span><br><span class="line">            top--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>     <span class="comment">/// 否则继续搜索欧拉路径</span></span><br><span class="line">        &#123;</span><br><span class="line">            top--;<span class="comment">///为了回溯</span></span><br><span class="line">            <span class="built_in">dfs</span>(ans[top+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y,deg,num,start,i,j;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;N,&amp;M);</span><br><span class="line">    <span class="built_in">memset</span>(mp,<span class="number">0</span>,<span class="built_in">sizeof</span> (mp));</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=M; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        mp[x][y]=<span class="number">1</span>;</span><br><span class="line">        mp[y][x]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    num=<span class="number">0</span>;</span><br><span class="line">    start=<span class="number">1</span>;<span class="comment">///这里初始化为1</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        deg=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;=N; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            deg+=mp[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(deg%<span class="number">2</span>==<span class="number">1</span>)<span class="comment">///奇度顶点</span></span><br><span class="line">        &#123;</span><br><span class="line">            start=i;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(num==<span class="number">0</span>||num==<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fleury</span>(start);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;No Euler path&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>acm</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>网络流</title>
    <url>/2024/05/30/acm/%E5%9B%BE%E8%AE%BA/%E7%BD%91%E7%BB%9C%E6%B5%81/</url>
    <content><![CDATA[<h1 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h1><blockquote>
<ul>
<li>有向图G(V,E)</li>
<li>有且仅有一个顶点S，它的入度为0，称为源点</li>
<li>有且仅有一个顶点T，它的出度为0，称为汇点</li>
<li>每一条弧都有非负数，叫做该边的容量；</li>
<li>称为网络流图，记为G&#x3D;(V,E,C)</li>
</ul>
</blockquote>
<h3 id="网络流模型例子"><a href="#网络流模型例子" class="headerlink" title="网络流模型例子"></a>网络流模型例子</h3><p>想要将一些水从S运到T，必须经过一些水站，连接水站的是管道，每条管道都有它的最大能容纳的水量，求S到T最多能流多少流量。</p>
<h3 id="可行流"><a href="#可行流" class="headerlink" title="可行流"></a>可行流</h3><ul>
<li>每一条狐，都有$\ f[i][j] \ \le\  c[i][j]\ $；即对于每条边，流经该边的流量不得超过该边的容量(不撑爆水管)。</li>
<li>流量平衡：除源点S和汇点T以外的所有的点vi，即流入的流量等于流出的流量，即中转点不截流量</li>
<li>对于源点S和汇点T有：S流出的流量等于T流入的流量</li>
</ul>
<h3 id="增广路"><a href="#增广路" class="headerlink" title="增广路"></a>增广路</h3><blockquote>
<p>增广路上的弧的流量通过一定规则的修改，可以令整个流量放大，也就是多流流量</p>
</blockquote>
<ul>
<li>可行流中，若$\  f[i][j]\ &#x3D;\ c[i][j]\ $ ,则称$&lt;v_i,v_j&gt;$为饱和弧，否则为非饱和弧。若$f[i][j] \ &#x3D; \ 0$，则称为零流弧，否则称为非零流弧</li>
</ul>
<h2 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h2><h3 id="Ford-Fulkerson增广"><a href="#Ford-Fulkerson增广" class="headerlink" title="Ford-Fulkerson增广"></a>Ford-Fulkerson增广</h3><blockquote>
<p>若图中有m条边，最大流为f，则算法的最大复杂度O(mf)</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">205</span>;<span class="comment">//最大结点数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x7fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> r[maxn][maxn]; <span class="comment">//残留网络，初始化为原图</span></span><br><span class="line"><span class="type">bool</span> visit[maxn];<span class="comment">//是否被访问过</span></span><br><span class="line"><span class="type">int</span> pre[maxn];<span class="comment">//前驱子图，记录了从顶点s到终点的一条可行路径上的其它顶点的前一个顶点，从前驱子图中找到从s到t的一条完整路径</span></span><br><span class="line"><span class="type">int</span> m,n;<span class="comment">//边数，顶点数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> s,<span class="type">int</span> t)</span>  <span class="comment">//广度优先寻找一条从s到t的增广路，若找到返回true</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;<span class="comment">//创建一个队列的对象</span></span><br><span class="line">    <span class="built_in">memset</span>(pre,<span class="number">-1</span>,<span class="built_in">sizeof</span>(pre));<span class="comment">//初始化，把数组pre中所有元素设置为-1</span></span><br><span class="line">    <span class="built_in">memset</span>(visit,<span class="literal">false</span>,<span class="built_in">sizeof</span>(visit));</span><br><span class="line">    pre[s]=s;</span><br><span class="line">    visit[s]=<span class="literal">true</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(s);<span class="comment">//把源点放进队列里面</span></span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())<span class="comment">//当队列不为空，继续找下一个结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        p=q.<span class="built_in">front</span>();<span class="comment">//取出队首</span></span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(r[p][i]&gt;<span class="number">0</span>&amp;&amp;!visit[i])<span class="comment">//如果从p出发到其他顶点，有残留容量大于0，并且没有被标记</span></span><br><span class="line">            &#123;</span><br><span class="line">                pre[i]=p;<span class="comment">//记录通路</span></span><br><span class="line">                visit[i]=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(i==t) <span class="comment">//如果找到汇点就结束</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(i);<span class="comment">//接着将该点进栈</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">EK</span><span class="params">(<span class="type">int</span> s,<span class="type">int</span> t)</span><span class="comment">//计算最大流</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> flow=<span class="number">0</span>,d,i;</span><br><span class="line">   <span class="keyword">while</span>(<span class="built_in">bfs</span>(s,t))<span class="comment">//当可以找到时</span></span><br><span class="line">   &#123;</span><br><span class="line">       d=inf;</span><br><span class="line">       <span class="keyword">for</span>(i=t;i!=s;i=pre[i])</span><br><span class="line">           d=d&lt;r[pre[i]][i]? d:r[pre[i]][i];<span class="comment">//找到增广路径中最小流量，如果d&lt;r[pre[i]][i],把d的值赋给d，否则把r[pre[i]][i]的值赋给d</span></span><br><span class="line">       <span class="keyword">for</span>(i=t;i!=s;i=pre[i])<span class="comment">//顺藤摸瓜找回去，正向，逆向分别更改</span></span><br><span class="line">       &#123;</span><br><span class="line">           r[pre[i]][i]-=d;<span class="comment">//正</span></span><br><span class="line">           r[i][pre[i]]+=d;<span class="comment">//反</span></span><br><span class="line">       &#125;</span><br><span class="line">       flow+=d;<span class="comment">//</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;m,&amp;n)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v,w;</span><br><span class="line">        <span class="built_in">memset</span>(r,<span class="number">0</span>,<span class="built_in">sizeof</span>(r));<span class="comment">//</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">            r[u][v]+=w;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;最大流：&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">EK</span>(<span class="number">1</span>,n));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Edmonds-Karp算法"><a href="#Edmonds-Karp算法" class="headerlink" title="Edmonds-Karp算法"></a>Edmonds-Karp算法</h3><blockquote>
<p>与Ford算法的改进地方在于，每次找简单路径时都优先找最短路</p>
<p>图有m条边，n个节点，此时的时间复杂度为O(mmn)</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 250</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">  <span class="type">int</span> from, to, cap, flow;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Edge</span>(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> c, <span class="type">int</span> f) : <span class="built_in">from</span>(u), <span class="built_in">to</span>(v), <span class="built_in">cap</span>(c), <span class="built_in">flow</span>(f) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EK</span> &#123;</span><br><span class="line">  <span class="type">int</span> n, m;             <span class="comment">// n：点数，m：边数</span></span><br><span class="line">  vector&lt;Edge&gt; edges;   <span class="comment">// edges：所有边的集合</span></span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; G[maxn];  <span class="comment">// G：点 x -&gt; x 的所有边在 edges 中的下标</span></span><br><span class="line">  <span class="type">int</span> a[maxn], p[maxn];  <span class="comment">// a：点 x -&gt; BFS 过程中最近接近点 x 的边给它的最大流</span></span><br><span class="line">                         <span class="comment">// p：点 x -&gt; BFS 过程中最近接近点 x 的边</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) G[i].<span class="built_in">clear</span>();</span><br><span class="line">    edges.<span class="built_in">clear</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">AddEdge</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> cap)</span> </span>&#123;</span><br><span class="line">    edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(from, to, cap, <span class="number">0</span>));</span><br><span class="line">    edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(to, from, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    m = edges.<span class="built_in">size</span>();</span><br><span class="line">    G[from].<span class="built_in">push_back</span>(m - <span class="number">2</span>);</span><br><span class="line">    G[to].<span class="built_in">push_back</span>(m - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">Maxflow</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in">sizeof</span>(a));</span><br><span class="line">      queue&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line">      Q.<span class="built_in">push</span>(s);</span><br><span class="line">      a[s] = INF;</span><br><span class="line">      <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> x = Q.<span class="built_in">front</span>();</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); i++) &#123;  <span class="comment">// 遍历以 x 作为起点的边</span></span><br><span class="line">          Edge&amp; e = edges[G[x][i]];</span><br><span class="line">          <span class="keyword">if</span> (!a[e.to] &amp;&amp; e.cap &gt; e.flow) &#123;</span><br><span class="line">            p[e.to] = G[x][i];  <span class="comment">// G[x][i] 是最近接近点 e.to 的边</span></span><br><span class="line">            a[e.to] =</span><br><span class="line">                <span class="built_in">min</span>(a[x], e.cap - e.flow);  <span class="comment">// 最近接近点 e.to 的边赋给它的流</span></span><br><span class="line">            Q.<span class="built_in">push</span>(e.to);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a[t]) <span class="keyword">break</span>;  <span class="comment">// 如果汇点接受到了流，就退出 BFS</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!a[t])</span><br><span class="line">        <span class="keyword">break</span>;  <span class="comment">// 如果汇点没有接受到流，说明源点和汇点不在同一个连通分量上</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> u = t; u != s;</span><br><span class="line">           u = edges[p[u]].from) &#123;  <span class="comment">// 通过 u 追寻 BFS 过程中 s -&gt; t 的路径</span></span><br><span class="line">        edges[p[u]].flow += a[t];      <span class="comment">// 增加路径上边的 flow 值</span></span><br><span class="line">        edges[p[u] ^ <span class="number">1</span>].flow -= a[t];  <span class="comment">// 减小反向路径的 flow 值</span></span><br><span class="line">      &#125;</span><br><span class="line">      flow += a[t];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="Dinic算法"><a href="#Dinic算法" class="headerlink" title="Dinic算法"></a>Dinic算法</h3><blockquote>
<p>图有m条边，n个点，此时的时间复杂度为O(mnn)</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">long</span> inf=<span class="number">2005020600</span>;</span><br><span class="line"><span class="type">int</span> n,m,s,t,u,v;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> w,ans,dis[<span class="number">520010</span>];</span><br><span class="line"><span class="type">int</span> tot=<span class="number">1</span>,now[<span class="number">520010</span>],head[<span class="number">520010</span>]; </span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">	<span class="type">int</span> to,net;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> val;</span><br><span class="line">&#125; e[<span class="number">520010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">long</span> <span class="type">long</span> w)</span> </span>&#123;</span><br><span class="line">	e[++tot].to=v;</span><br><span class="line">	e[tot].val=w;</span><br><span class="line">	e[tot].net=head[u];</span><br><span class="line">	head[u]=tot;</span><br><span class="line">	</span><br><span class="line">	e[++tot].to=u;</span><br><span class="line">	e[tot].val=<span class="number">0</span>;</span><br><span class="line">	e[tot].net=head[v];</span><br><span class="line">	head[v]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;  <span class="comment">//在惨量网络中构造分层图 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) dis[i]=inf;</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	q.<span class="built_in">push</span>(s);</span><br><span class="line">	dis[s]=<span class="number">0</span>;</span><br><span class="line">	now[s]=head[s];</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="type">int</span> x=q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=head[x];i;i=e[i].net) &#123;</span><br><span class="line">			<span class="type">int</span> v=e[i].to;</span><br><span class="line">			<span class="keyword">if</span>(e[i].val&gt;<span class="number">0</span>&amp;&amp;dis[v]==inf) &#123;</span><br><span class="line">				q.<span class="built_in">push</span>(v);</span><br><span class="line">				now[v]=head[v];</span><br><span class="line">				dis[v]=dis[x]+<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span>(v==t) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">long</span> <span class="type">long</span> sum)</span> </span>&#123;  <span class="comment">//sum是整条增广路对最大流的贡献</span></span><br><span class="line">	<span class="keyword">if</span>(x==t) <span class="keyword">return</span> sum;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> k,res=<span class="number">0</span>;  <span class="comment">//k是当前最小的剩余容量 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=now[x];i&amp;&amp;sum;i=e[i].net) &#123;</span><br><span class="line">		now[x]=i;  <span class="comment">//当前弧优化 </span></span><br><span class="line">		<span class="type">int</span> v=e[i].to;</span><br><span class="line">		<span class="keyword">if</span>(e[i].val&gt;<span class="number">0</span>&amp;&amp;(dis[v]==dis[x]+<span class="number">1</span>)) &#123;</span><br><span class="line">			k=<span class="built_in">dfs</span>(v,<span class="built_in">min</span>(sum,e[i].val));</span><br><span class="line">			<span class="keyword">if</span>(k==<span class="number">0</span>) dis[v]=inf;  <span class="comment">//剪枝，去掉增广完毕的点 </span></span><br><span class="line">			e[i].val-=k;</span><br><span class="line">			e[i^<span class="number">1</span>].val+=k;</span><br><span class="line">			res+=k;  <span class="comment">//res表示经过该点的所有流量和（相当于流出的总量） </span></span><br><span class="line">			sum-=k;  <span class="comment">//sum表示经过该点的剩余流量 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;s,&amp;t);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lld&quot;</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">		<span class="built_in">add</span>(u,v,w);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">bfs</span>()) &#123;</span><br><span class="line">		ans+=<span class="built_in">dfs</span>(s,inf);  <span class="comment">//流量守恒（流入=流出） </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>acm</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>区间dp</title>
    <url>/2024/05/30/acm/dp/%E5%8C%BA%E9%97%B4dp/</url>
    <content><![CDATA[<h1 id="区间dp"><a href="#区间dp" class="headerlink" title="区间dp"></a>区间dp</h1><ul>
<li>什么是区间dp？</li>
</ul>
<p>​               区间dp就是在***区间上进行[动态规划]***，求解一段区间上的最优解。主要是通过合并小区间的 最优解进而得出整个大区间上最优解的dp算法</p>
<ul>
<li><p>核心思路</p>
<p>那么我把这个区间分割成一个个小区间，求解每个小区间的最优解，再合并小区间得到大区间即可</p>
<p>1.可以枚举区间长度len为每次分割成的小区间长度（由短到长不断合并），</p>
<p>2.内层枚举该长度下可以的起点。</p>
<p>3.然后在这个起点终点之间枚举分割点，求解这段小区间在某个分割点下的最优解</p>
<p>4.写出特定的状态转移方程(重点)</p>
<p><strong>板子</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> len = <span class="number">1</span>;len&lt;=n;len++)&#123;<span class="comment">//枚举长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j+len&lt;=n+<span class="number">1</span>;j++)&#123;<span class="comment">//枚举起点，ends&lt;=n</span></span><br><span class="line">            <span class="type">int</span> ends = j+len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = j;i&lt;ends;i++)&#123;<span class="comment">//枚举分割点，更新小区间最优解</span></span><br><span class="line">                dp[j][ends] = min(dp[j][ends],dp[j][i]+dp[i+<span class="number">1</span>][ends]+something);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><em><strong>四边形不等式优化</strong></em></p>
<ul>
<li><p>1.区间包含的单调性：如果对于i≤i’&lt;j≤j’，有 cost(i’,j)≤cost(i,j’)，那么说明 cost 具有区间包含的单调性。（可以形象理解为如果小区间包含于大区间中，那么小区间的cost值不超过大区间的cost值 ），证明可通过题目定义的cost(i,j)的含义进行论证</p>
<p>2、四边形不等式：如果对于i≤i’&lt;j≤j’，有 cost(i,j)+cost(i’,j’)≤cost(i’,j)+cost(i,j’)，我们称函数 cost 满足四边      形不等式。（可以形象理解为两个交错区间的cost的和不超过小区间与大区间的cost的和——(交叉小于包含)）</p>
</li>
<li><p>两个定理：<br>1、如果上述的cost 函数同时满足区间包含单调性和四边形不等式性质，那么函数 dp也满足四边形不等式性质 我们再定义s(i,j)表示dp(i,j) 取得最优值时对应的下标k（即 i≤k≤j 时，k 处的 dp 值最最优，则 s(i,j)&#x3D;k）。此时有如下定理:<br>2、假如 dp(i,j) 满足四边形不等式，那么 s(i,j)(自变量为i、j两个变量) 单调，即s(i,j)≤s(i,j+1)≤s(i+1,j+1)</p>
</li>
</ul>
<p>即原来的<code>状态转移方程</code>可以改写为下式：<br><code>dp(i,j)=min&#123;dp(i,k-1),dp(k,j)&#125;+cost(i,j)(s(i,j-1)≤k≤s(i+1,j))</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">2</span>;len&lt;=n;len++) &#123;	<span class="comment">//枚举长度</span></span><br><span class="line">   		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n-len+<span class="number">1</span>;i++) &#123;</span><br><span class="line">   			<span class="type">int</span> j=i+len<span class="number">-1</span>;	<span class="comment">//根据起点推终点</span></span><br><span class="line">   			dp[i][j]=Integer.MAX_VALUE;	<span class="comment">//初始化值</span></span><br><span class="line">   			<span class="keyword">for</span>(<span class="type">int</span> k=s[i][j<span class="number">-1</span>];k&lt;=s[i+<span class="number">1</span>][j];k++) &#123;	<span class="comment">//通过平行四边形优化，缩小枚举范围</span></span><br><span class="line">   				<span class="keyword">if</span>(dp[i][k]+dp[k+<span class="number">1</span>][j]+cost[j]-cost[i<span class="number">-1</span>]&lt;dp[i][j]) &#123;	<span class="comment">//换成if语句，可以减少不必要的循环赋值</span></span><br><span class="line">   					dp[i][j]=dp[i][k]+dp[k+<span class="number">1</span>][j]+cost[j]-cost[i<span class="number">-1</span>];</span><br><span class="line">   					s[i][j]=k;	<span class="comment">//记录最优分割点</span></span><br><span class="line">   				&#125;</span><br><span class="line">   			&#125;</span><br><span class="line">   			</span><br><span class="line">   		&#125;</span><br><span class="line">   	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>acm</category>
        <category>dp</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>数位dp</title>
    <url>/2024/05/30/acm/dp/%E6%95%B0%E4%BD%8Ddp/</url>
    <content><![CDATA[<h1 id="数位dp"><a href="#数位dp" class="headerlink" title="数位dp"></a>数位dp</h1><blockquote>
<ul>
<li>要求统计满足一定条件的数的数量</li>
<li>这些条件经过转化后可以使用数位的思想去理解和判断</li>
<li>输入会提供一个数字区间来作为统计的限制</li>
<li>上界很大，暴力枚举验证会超时</li>
</ul>
</blockquote>
<h2 id="sample1"><a href="#sample1" class="headerlink" title="sample1"></a>sample1</h2><p>求<code>a~b</code>中不包含49的数的个数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a, b, shu[<span class="number">20</span>], dp[<span class="number">20</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> len, <span class="type">bool</span> if4, <span class="type">bool</span> shangxian)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (!shangxian &amp;&amp; dp[len][if4])   <span class="comment">//为什么要返回呢？可以画图理解当我们搜到3XXX时，程序运行到1XXX时就已经把3XXX之后的搜索完了，记忆化也是这个用意.</span></span><br><span class="line">        <span class="keyword">return</span> dp[len][if4];</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>, maxx = (shangxian ? shu[len] : <span class="number">9</span>);<span class="comment">//找到每一位的上限</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= maxx; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (if4 &amp;&amp; i == <span class="number">9</span>)<span class="comment">//如果上一位是4且这一位是9则跳过</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        cnt += <span class="built_in">dfs</span>(len - <span class="number">1</span>, i == <span class="number">4</span>, shangxian &amp;&amp; i == maxx);  <span class="comment">//只有之前有限制现在的达到了上限才能构成限制</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> shangxian ? cnt : dp[len][if4] = cnt; <span class="comment">//如果有限制，那么就不能记忆化，否则记忆的是个错误的数.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(shu, <span class="number">0</span>, <span class="built_in">sizeof</span>(shu));</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x)</span><br><span class="line">    &#123;</span><br><span class="line">        shu[++k] = x % <span class="number">10</span>;  <span class="comment">//保存a,b的数</span></span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(k, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">solve</span>(b) - <span class="built_in">solve</span>(a - <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//while (1);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="sample2"><a href="#sample2" class="headerlink" title="sample2"></a>sample2</h2><p>求<code>a~b</code>之间有多少个不含前导0且相邻两个数字之差至少为2的正整数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long int</span></span><br><span class="line"><span class="type">int</span> shu[<span class="number">100</span>];</span><br><span class="line">ll dp[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(ll pos,<span class="type">bool</span> limit,<span class="type">bool</span> zero,<span class="type">int</span> last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pos==<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(!limit&amp;&amp;!zero&amp;&amp;dp[pos][last]+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> dp[pos][last];</span><br><span class="line">    <span class="type">int</span> up;</span><br><span class="line">    <span class="keyword">if</span>(limit)</span><br><span class="line">    up=shu[pos];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    up=<span class="number">9</span>;</span><br><span class="line">    ll tem=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=up;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(last-i)&lt;<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(zero&amp;&amp;i==<span class="number">0</span>)</span><br><span class="line">        tem+=<span class="built_in">dfs</span>(pos<span class="number">-1</span>,limit&amp;&amp;i==up,<span class="number">1</span>,<span class="number">-22</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        tem+=<span class="built_in">dfs</span>(pos<span class="number">-1</span>,limit&amp;&amp;i==up,<span class="number">0</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!limit&amp;&amp;!zero)</span><br><span class="line">    dp[pos][last]=tem;</span><br><span class="line">    <span class="keyword">return</span> tem;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(t)</span><br><span class="line">    &#123;</span><br><span class="line">        shu[ans++]=t%<span class="number">10</span>;</span><br><span class="line">        t/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(ans<span class="number">-1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll a,b;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,<span class="built_in">solve</span>(b)-<span class="built_in">solve</span>(a<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>acm</category>
        <category>dp</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>树形dp</title>
    <url>/2024/05/30/acm/dp/%E6%A0%91%E5%BD%A2dp/</url>
    <content><![CDATA[<h1 id="树形dp"><a href="#树形dp" class="headerlink" title="树形dp"></a>树形dp</h1><ul>
<li>树的遍历，用<strong>DFS</strong>从根节点开始进行记忆化搜索</li>
<li>从树最深处开始往回进行<strong>DP</strong>，用子节点dp值来更新父节点dp值</li>
</ul>
<p>板子</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u)</span></span><br><span class="line">&#123;</span><br><span class="line">	dp[u][...] = ...; 			<span class="comment">//初始化</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i &lt; edge[u].size(); i++)	<span class="comment">//遍历处理u的子节点v</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> v = edge[u][i];</span><br><span class="line">        	dfs(v);				<span class="comment">//深搜子结点</span></span><br><span class="line">        	dp[u][...] = ...;		<span class="comment">//状态转移方程</span></span><br><span class="line">   	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>acm</category>
        <category>dp</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>状压dp</title>
    <url>/2024/05/30/acm/dp/%E7%8A%B6%E5%8E%8Bdp/</url>
    <content><![CDATA[<h1 id="状压dp"><a href="#状压dp" class="headerlink" title="状压dp"></a>状压dp</h1><blockquote>
<p>背包问题</p>
<p>如果要表示物品放不放：如果五个物品都不放，可以用00000表示；如果五个物品都放，可以用11111表示</p>
<p>可以用一个维度表示所有物品放与不放的情况，这个过程就叫做状态压缩</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">1</span> &lt;&lt; <span class="number">15</span>;</span><br><span class="line"><span class="type">int</span> dp[INF + <span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> dp1[INF+ <span class="number">10</span>] ;	<span class="comment">//定义状态 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print1</span><span class="params">(<span class="type">int</span> num)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n,m;</span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> W[<span class="number">20</span>],C[<span class="number">20</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;C[i],&amp;W[i]) ;</span><br><span class="line">		<span class="type">int</span> res = <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(!(i&amp;(<span class="number">1</span> &lt;&lt; j)))		<span class="comment">//状态转移 </span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="type">int</span> temp = i | (<span class="number">1</span>&lt;&lt;j);</span><br><span class="line">					dp[temp] = dp[i] + W[j];		</span><br><span class="line">					dp1[temp] = dp1[i] + C[j];</span><br><span class="line">					</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">print1</span>(i);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\t%d\t%d\n&quot;</span>,dp[i],dp1[i]);		<span class="comment">//打印出每种方案的情况，价值 和耗费的空间 </span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print1</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> k= <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(num == <span class="number">0</span>)</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span>(;(<span class="number">1</span> &lt;&lt; k) &lt;= num; k++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(num &amp; (<span class="number">1</span>&lt;&lt;k))</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>acm</category>
        <category>dp</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>概率dp</title>
    <url>/2024/05/30/acm/dp/%E6%A6%82%E7%8E%87dp/</url>
    <content><![CDATA[<h1 id="概率dp"><a href="#概率dp" class="headerlink" title="概率dp"></a>概率dp</h1><h2 id="dp求概率"><a href="#dp求概率" class="headerlink" title="dp求概率"></a>dp求概率</h2><p><img src="C:\Users\Tomato\AppData\Roaming\Typora\typora-user-images\image-20240514220812741.png" alt="image-20240514220812741"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> w, b;</span><br><span class="line"><span class="type">double</span> dp[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;w, &amp;b);</span><br><span class="line">  <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= w; i++) dp[i][<span class="number">0</span>] = <span class="number">1</span>;  <span class="comment">// 初始化</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= b; i++) dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= w; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= b; j++) &#123;  <span class="comment">// 以下为题面概率转移</span></span><br><span class="line">      dp[i][j] += (<span class="type">double</span>)i / (i + j);</span><br><span class="line">      <span class="keyword">if</span> (j &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">        dp[i][j] += (<span class="type">double</span>)j / (i + j) * (j - <span class="number">1</span>) / (i + j - <span class="number">1</span>) * (j - <span class="number">2</span>) /</span><br><span class="line">                    (i + j - <span class="number">2</span>) * dp[i][j - <span class="number">3</span>];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &amp;&amp; j &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        dp[i][j] += (<span class="type">double</span>)j / (i + j) * (j - <span class="number">1</span>) / (i + j - <span class="number">1</span>) * i /</span><br><span class="line">                    (i + j - <span class="number">2</span>) * dp[i - <span class="number">1</span>][j - <span class="number">2</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%.9lf\n&quot;</span>, dp[w][b]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="dp求期望"><a href="#dp求期望" class="headerlink" title="dp求期望"></a>dp求期望</h2><p><img src="C:\Users\Tomato\AppData\Roaming\Typora\typora-user-images\image-20240514220306713.png" alt="image-20240514220306713"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, s;</span><br><span class="line"><span class="type">double</span> dp[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;s);</span><br><span class="line">  dp[n][s] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = s; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i == n &amp;&amp; s == j) <span class="keyword">continue</span>;</span><br><span class="line">      dp[i][j] = (dp[i][j + <span class="number">1</span>] * i * (s - j) + dp[i + <span class="number">1</span>][j] * (n - i) * j +</span><br><span class="line">                  dp[i + <span class="number">1</span>][j + <span class="number">1</span>] * (n - i) * (s - j) + n * s) /</span><br><span class="line">                 (n * s - i * j);  <span class="comment">// 概率转移</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%.4lf\n&quot;</span>, dp[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="C:\Users\Tomato\AppData\Roaming\Typora\typora-user-images\image-20240514220339671.png" alt="image-20240514220339671"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2010</span>;</span><br><span class="line"><span class="type">int</span> n, m, v, e;</span><br><span class="line"><span class="type">int</span> f[maxn][maxn], c[maxn], d[maxn];</span><br><span class="line"><span class="type">double</span> dp[maxn][maxn][<span class="number">2</span>], p[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;n, &amp;m, &amp;v, &amp;e);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;c[i]);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;d[i]);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;p[i]);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= v; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j++) f[i][j] = f[j][i] = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> u, V, w;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= e; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;u, &amp;V, &amp;w);</span><br><span class="line">    f[u][V] = f[V][u] = <span class="built_in">min</span>(w, f[u][V]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= v; k++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= v; i++)  <span class="comment">// 前面的，按照前面的题解进行一个状态转移</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">        <span class="keyword">if</span> (f[i][k] + f[k][j] &lt; f[i][j]) f[i][j] = f[j][i] = f[i][k] + f[k][j];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++) dp[i][j][<span class="number">0</span>] = dp[i][j][<span class="number">1</span>] = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line">  dp[<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] = dp[<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)  <span class="comment">// 有后效性方程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="built_in">min</span>(i, m); j++) &#123;</span><br><span class="line">      dp[i][j][<span class="number">0</span>] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j][<span class="number">0</span>] + f[c[i - <span class="number">1</span>]][c[i]],</span><br><span class="line">                        dp[i - <span class="number">1</span>][j][<span class="number">1</span>] + f[c[i - <span class="number">1</span>]][c[i]] * (<span class="number">1</span> - p[i - <span class="number">1</span>]) +</span><br><span class="line">                            f[d[i - <span class="number">1</span>]][c[i]] * p[i - <span class="number">1</span>]);</span><br><span class="line">      <span class="keyword">if</span> (j != <span class="number">0</span>) &#123;</span><br><span class="line">        dp[i][j][<span class="number">1</span>] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">0</span>] + f[c[i - <span class="number">1</span>]][d[i]] * p[i] +</span><br><span class="line">                              f[c[i - <span class="number">1</span>]][c[i]] * (<span class="number">1</span> - p[i]),</span><br><span class="line">                          dp[i - <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">1</span>] +</span><br><span class="line">                              f[c[i - <span class="number">1</span>]][c[i]] * (<span class="number">1</span> - p[i - <span class="number">1</span>]) * (<span class="number">1</span> - p[i]) +</span><br><span class="line">                              f[c[i - <span class="number">1</span>]][d[i]] * (<span class="number">1</span> - p[i - <span class="number">1</span>]) * p[i] +</span><br><span class="line">                              f[d[i - <span class="number">1</span>]][c[i]] * (<span class="number">1</span> - p[i]) * p[i - <span class="number">1</span>] +</span><br><span class="line">                              f[d[i - <span class="number">1</span>]][d[i]] * p[i - <span class="number">1</span>] * p[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">double</span> ans = <span class="number">1e9</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; i++) ans = <span class="built_in">min</span>(dp[n][i][<span class="number">0</span>], <span class="built_in">min</span>(dp[n][i][<span class="number">1</span>], ans));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%.2lf&quot;</span>, ans);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>acm</category>
        <category>dp</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>中国剩余定理</title>
    <url>/2024/05/30/acm/%E6%95%B0%E8%AE%BA/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<h1 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h1><p>解决以下方程组</p>
<p>{</p>
<p>$x\ \equiv a_1(mod\ n_1)$</p>
<p>$x\ \equiv a_2(mod\ n_2)$</p>
<p>$x\ \equiv a_3(mod\ n_3)$</p>
<p>}</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//k 个数，a a数组，r m</span></span><br><span class="line"><span class="function">LL <span class="title">CRT</span><span class="params">(<span class="type">int</span> k, LL* a, LL* r)</span> </span>&#123;</span><br><span class="line">  LL n = <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++) n = n * r[i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">    LL m = n / r[i], b, y;</span><br><span class="line">    <span class="built_in">exgcd</span>(m, r[i], b, y);  <span class="comment">// b * m mod r[i] = 1</span></span><br><span class="line">    ans = (ans + a[i] * m * b % n) % n;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (ans % n + n) % n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>acm</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>卡特兰数</title>
    <url>/2024/05/30/acm/%E6%95%B0%E8%AE%BA/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/</url>
    <content><![CDATA[<h2 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数"></a>卡特兰数</h2><p>令h(0)&#x3D;1,h(1)&#x3D;1，catalan数满足递推式。<strong>h(n)&#x3D; h(0)*h(n-1)+h(1)*h(n-2) + … + h(n-1)h(0) (n&gt;&#x3D;2)。</strong>也就是说，如果能把公式化成上面这种形式的数，就是卡特兰数。</p>
<hr>
<p><strong>h(n)&#x3D;c(2n,n)-c(2n,n+1)</strong></p>
<p><strong>h(n)&#x3D;C(2n,n)&#x2F;(n+1)</strong></p>
]]></content>
      <categories>
        <category>acm</category>
        <category>组合数学</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>背包九讲</title>
    <url>/2024/05/30/acm/dp/%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2/</url>
    <content><![CDATA[<h1 id="背包九讲"><a href="#背包九讲" class="headerlink" title="背包九讲"></a>背包九讲</h1><blockquote>
<p>背包问题是典型的线性dp问题</p>
</blockquote>
<h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>有 N 件物品和一个容量为 V 的背包。放入第 i 件物品花费的容积是 c[i] ，得到的价值是 w[i] ，求将哪些物品装入背包可使价值总和最大。</p>
<blockquote>
<p>特点：每种物品只有一种</p>
</blockquote>
<p>定义状态</p>
<p><code>dp[i][j]</code>表示前 i 件物品恰放入一个容量为 j 的背包可以获得的最大价值<br>则状态转移方程为：</p>
<p><code>dp[i][j] = max(dp[i-1][j] , dp[i-1][j-c[i]] + w[i]])</code></p>
<p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> c[maxn], w[maxn], dp[maxn][maxn];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, v;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        cin &gt;&gt; c[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        cin &gt;&gt; w[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= v;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(c[i]&lt;=j)&#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i - <span class="number">1</span>][j - c[i]] + w[i]);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; dp[n][v] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// std::ios::sync_with_stdio(false);</span></span><br><span class="line">    <span class="comment">// cin.tie(0);</span></span><br><span class="line">    <span class="comment">// cout.tie(0);</span></span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时的时间和空间复杂度均为Θ(<em>V</em>∗<em>N</em>) ,</p>
<h3 id="滚动数组"><a href="#滚动数组" class="headerlink" title="滚动数组"></a>滚动数组</h3><p>滚动数组是 dp 中最常用的空间优化技术</p>
<p>使用滚动数组，可以将 dp 的状态维度减少一维</p>
<p>从转移方程可以看出 <code>dp[i][j] = max(dp[i-1][j-v[i]]+w[i],dp[i-1][j])</code> 只与 <code>dp[i-1]</code>有关，和 <code>dp[i-2],dp[i-3]</code>… 都没有关系，所以我们只需要 <code>dp[i-1]</code> 就够了</p>
<h4 id="交替滚动"><a href="#交替滚动" class="headerlink" title="交替滚动"></a>交替滚动</h4><p>定义<code>dp[2][j]</code>，用<code>dp[1][j],dp[0][j]</code>交替滚动</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= v; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i &amp; <span class="number">1</span>][j] = dp[(i &amp; <span class="number">1</span>) ^ <span class="number">1</span>][j];</span><br><span class="line">        <span class="comment">// 如果当前物品的体积大于当前的容量，显然不能放入</span></span><br><span class="line">        <span class="keyword">if</span> (c[i] &lt;= j)</span><br><span class="line">            dp[i &amp; <span class="number">1</span>][j] = <span class="built_in">max</span>(dp[i &amp; <span class="number">1</span>][j], dp[(i &amp; <span class="number">1</span>) ^ <span class="number">1</span>][j - c[i]] + w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="自我滚动"><a href="#自我滚动" class="headerlink" title="自我滚动"></a>自我滚动</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 逆序！！！</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (c[i] &lt;= j)</span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j], dp[j - c[i]] + w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>循环 j 的时候记得反过来</strong></p>
<h3 id="初始化问题"><a href="#初始化问题" class="headerlink" title="初始化问题"></a>初始化问题</h3><p>我们看到的求最优解的背包问题题目中，事实上有两种不太相同的问法。</p>
<p>有的题目要求“<strong>恰好装满背包</strong>”时的最优解，有的题目则并没有要求必须把背包装满。一种区别这两种问法的实现方法是在初始化的时候有所不同。</p>
<p>如果是第一种问法，要求恰好装满背包，那么在初始化时除了 <code>dp[0]</code> 为 0，其 它 <code>dp[1...v]</code> 均设为 <code>−∞</code>，这样就可以保证最终得到的 <code>dp[v]</code> 是一种恰好装满背包的 最优解。</p>
<p>如果并没有要求必须把背包装满，而是只希望价格尽量大，初始化时应该 将 <code>dp[0...V]</code>全部设为 0 。</p>
<p>这是为什么呢？可以这样理解：初始化的 F 数组事实上就是在没有任何物品可以放入背包时的合法状态。如果要求背包恰好装满，那么此时只有容量为 0 的背包可以在什么也不装且价值为 0 的情况下被“恰好装满”，其它容量的背包均没有合法的解，属于未定义的状态，应该被赋值为 <code>−∞ </code>了。如果背包并非必须被装满，那么任何容量的背包都有一个合法解“什么都不装”，这个解的价值为 0 ，所以初始时状态的值也就全部为 0 了。</p>
<p>这个小技巧完全可以推广到其它类型的背包问题，后面也就不再对进行状态转移之前的初始化进行讲解。</p>
<h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h3><p>有N 种物品和一个容量为V 的背包，每种物品都有无限件可用。第 i 种物品的费用是c [ i ] ，价值是w [ i ]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这种问题类似于01背包，不同的是每件物品有无限件，而01背包每件物品只有一件。状态方程仍然可以按照01背包时的思路，令<code>dp[i][j]</code>表示前 i 种物品放入一个容量为 j 的背包的最大权值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dp[i][j]=<span class="built_in">max</span>(dp[i−<span class="number">1</span>][j−k∗c[i]]+k∗w[i])   ∣   <span class="number">0</span>≤k∗c[i]≤j</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="comment">//第i件物品</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = c[i]; j &lt;= V; j++)<span class="comment">//背包体积</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k * c[i] &lt;= j; k++)<span class="comment">//决策数</span></span><br><span class="line">				dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i - <span class="number">1</span>][j - k * c[i]] + k * w[i]);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">for 物品</span></span><br><span class="line"><span class="comment">    for 体积</span></span><br><span class="line"><span class="comment">        for 决策</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>注意取 max 时与01背包不同</strong>，max 的第一个参数不再是<code>dp[i-1][j]</code>，因为<code>dp[i][j]</code>要在取多件的情况中取最值； 当 k &#x3D; 0时，<code>dp[i-1][j - k*c[i]] + k*w[i]</code>就相当于<code>dp[i-1][j]</code>，也就是这件物品一件也不取的情况</p>
<p>时间复杂度为<code>Θ(N ∗ Σ(V/c[i]))</code></p>
<h2 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h2><h3 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h3><p>有 N 种物品和一个容量为 V 的背包。第 i 种物品最多有 p [ i ] 件可用，每件费用是c [ i ] ，价值是w [ i ] 。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>对于第 i 种物品有 <code>p[i]+1</code>种策略：取<code>0...p[i]</code>件，令<code>dp[i][j]</code>表示前 i 种物品恰放入一个容量为 j 的背包的最大价值，则有状态转移方程</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dp[i][j]=<span class="built_in">max</span>(dp[i−<span class="number">1</span>][j−k∗c[i]]+k∗w[i]) ∣     <span class="number">0</span>≤k≤p[i]</span><br></pre></td></tr></table></figure>

<h3 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> dp[maxn], c[maxn], w[maxn], p[maxn];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        cin &gt;&gt; c[i] &gt;&gt; w[i] &gt;&gt; p[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k * c[i] &lt;= j &amp;&amp; k &lt;= p[i]; ++k)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j], dp[j - c[i] * k] + w[i] * k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        res = <span class="built_in">max</span>(res, dp[i]);</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// std::ios::sync_with_stdio(false);</span></span><br><span class="line">    <span class="comment">// cin.tie(0);</span></span><br><span class="line">    <span class="comment">// cout.tie(0);</span></span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度</strong>: O( 物品数 × 背包的体积 × 选法) </p>
<h3 id="二进制优化法"><a href="#二进制优化法" class="headerlink" title="二进制优化法"></a>二进制优化法</h3><blockquote>
<p>本质： 将多重背包转化为 01背包问题</p>
</blockquote>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>暴力法实质上是把多重背包中的每个物品都分成了 p 件，我们可以通过其他分法，可以通过选这些物品，选几个来表示选 s 个的所有可能</p>
<p>这时候就想到了二进制，因为任何实数都可以由二进制数组成。</p>
<p>那么我们就可以把一个物品拆成 $ 2^0 ，2^1 , 2^2 , …… , 2^k , (x-2^{k+1}+1)$ ( k 为最大的  $2^i$ 总和不大于 x 的实数，$log_x$ 个物品</p>
<p>这些物品可以通过组合，组成 0 - x 内的整数（不能漏不能多）</p>
<h4 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h4><p>设一个实数 x ， 拆分成 $ 2^0 ，2^1 , 2^2 , …… , 2^k ,c$ ，因 ( k 为最大的  $2^i$ 总和不大于 x 的实数)为 k 是最大的 $2^k$ 不大于 x 的实数，所以可以知道 c  &lt; $2^{k+1}$</p>
<p>根据二进制可知 0 到 ($2^{k+1}-1$)都可以用以上的数组成</p>
<p>因为 $2^{k+1}-1+c$为可以凑到的最大值，所以$2^{k+1}-1+c&#x3D;p &#x3D;&gt; p-(2^{k+1}-1)$</p>
<p>现在已知$0-(2^{k+1}-1)$ 和$c-p$ 两端都可以由以上数拼接起来，现在问题就是，这两段合在一起的时候，中间有无空缺。</p>
<p>如果有空缺的话，$c&gt;2^{k+1}-1$ 即 $c\ge2^{k+1}$</p>
<p>显然与开始得到的 $c&lt;2^{k+1}$相矛盾，可得0-p中的任何一个数都可以拼接起来</p>
<p><strong>时间复杂度</strong>：O$( 物品数 \times 背包的体积 \times log 选法) $&#x3D; O$(N \times V \times logP)$</p>
<p><a href="https://www.acwing.com/problem/content/5/">多重背包问题 ||</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> c[maxn], w[maxn], p[maxn], dp[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> c, w;</span><br><span class="line">&#125; good[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        cin &gt;&gt; c[i] &gt;&gt; w[i] &gt;&gt; p[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 分成2^k次方的时候</span></span><br><span class="line">        <span class="comment">// 新物品的体积和价值 = 选的个数 *单个的体积和价格</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> z = <span class="number">1</span>; z &lt;= p[i]; z *= <span class="number">2</span>, ++cnt)</span><br><span class="line">        &#123;</span><br><span class="line">            good[cnt].c = z * c[i];</span><br><span class="line">            good[cnt].w = z * w[i];</span><br><span class="line">            p[i] -= z;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p[i] &gt; <span class="number">0</span>)<span class="comment">//最后一个物品</span></span><br><span class="line">        &#123;</span><br><span class="line">            good[cnt].c = p[i] * c[i];</span><br><span class="line">            good[cnt++].w = p[i] * w[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//变成了01背包</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; cnt;++j)<span class="comment">//遍历选法</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = m; k &gt;= good[j].c;k--)<span class="comment">//遍历体积，由于是滚动一维，所以要逆序遍历</span></span><br><span class="line">            &#123;</span><br><span class="line">                dp[k]=<span class="built_in">max</span>(dp[k],dp[k-good[j].c]+good[j].w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; dp[m] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// std::ios::sync_with_stdio(false);</span></span><br><span class="line">    <span class="comment">// cin.tie(0);</span></span><br><span class="line">    <span class="comment">// cout.tie(0);</span></span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单调队列优化法"><a href="#单调队列优化法" class="headerlink" title="单调队列优化法"></a>单调队列优化法</h3><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>转移方程<code>dp[i][j] = max(dp[i-1][j], dp[i-1][j-k*c[i]] + k*w[i])</code></p>
<p>单调队列优化的主要思想就是<strong>分组更新</strong>，因为<code>w[i]</code>是成倍增加的，<code>dp[i-1][j]</code>只会更新<code>dp[i-1][j+k*w[i]]</code>(这里是从前往后看的，所以是+)</p>
<p>对于当前为 w 的体积，我们可以按照余数将它分为 w 组，也就是0… w−1同一个剩余系的数在一组<br>比如在模 3 意义下，1 , 4 , 7 , 10 是一组，2 , 5 , 8 , 11 是一组，3 , 6 , 9 , 12 是一组<br>每组的转移是互不影响的，也就是单独转移</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20005</span>;</span><br><span class="line"><span class="comment">// pre存储i - 1的时候的值</span></span><br><span class="line"><span class="comment">// q为偏移量为?时候的单调队列</span></span><br><span class="line"><span class="type">int</span> dp[N], pre[N], q[N], n, m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//n为物品的总数，背包容量为m</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v, w, s;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;v, &amp;w, &amp;s);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//赋值上一层结果</span></span><br><span class="line">        <span class="built_in">memcpy</span>(pre, dp, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//枚举偏移量(起点)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//建新的单调队列 头&gt;&gt;&gt;尾巴，里面存的是体积</span></span><br><span class="line">            <span class="type">int</span> head = <span class="number">0</span>, tail = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//更新该起点代表的行,k是此时的体积</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt;= m; k += v)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//判断窗格是否超过了k,头需要往后滑动</span></span><br><span class="line">                <span class="keyword">if</span> (head &lt;= tail &amp;&amp; k - q[head] &gt; s * v)</span><br><span class="line">                    head++;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//赋值</span></span><br><span class="line">                <span class="comment">//pre[q[head]]+(k - q[head]) / v * w)：前i-1个中选，且体积不大于q[head]的最大价值 + 第i个物品选(k - q[head]) / v 个的价值</span></span><br><span class="line">                <span class="keyword">if</span> (head &lt;= tail)</span><br><span class="line">                    dp[k] = <span class="built_in">max</span>(dp[k], pre[q[head]] + (k - q[head]) / v * w);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//队列中加入k,并且维护队列单调性</span></span><br><span class="line">                <span class="comment">//pre[k]：前i-1个中选，且体积不大于q[head]的最大价值 + 第i个物品选0个</span></span><br><span class="line">                <span class="comment">//pre[q[tail]] + (k - q[tail]) / v * w ：前i-1个中选，且体积不大于q[tail]的最大价值 + 第i个物品选(k - q[tail]) / v个</span></span><br><span class="line">                <span class="keyword">while</span> (head &lt;= tail &amp;&amp; pre[q[tail]] + (k - q[tail]) / v * w &lt; pre[k])</span><br><span class="line">                    tail--;</span><br><span class="line">                q[++tail] = k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, dp[m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="http://acm.sztu.edu.cn/csgoj/problemset/problem?pid=1538">演唱会 SOJ1538</a></p>
<h2 id="混合多种背包问题"><a href="#混合多种背包问题" class="headerlink" title="混合多种背包问题"></a>混合多种背包问题</h2><h3 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h3><p>将前面三个背包混合起来，也就是说，有的物品只可以取一次（01背包），有的物品可以取无限次（完全背包），有的物品可以取的次数有一个上限（多重背包）</p>
<h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>当前物品的选法，和相应的更新值，和之前的物品类型无关。所以每次判断当前物品的类型，选择对应的转移方程来进行转移就可以了。</p>
<h2 id="二维费用背包问题"><a href="#二维费用背包问题" class="headerlink" title="二维费用背包问题"></a>二维费用背包问题</h2><h3 id="题目大意-4"><a href="#题目大意-4" class="headerlink" title="题目大意"></a>题目大意</h3><p>二维费用的背包问题是指：对于每件物品，具有两种不同的费用；选择这件物品必须同时付出这两种代价；对于每种代价都有一个可付出的最大值（背包容量）。问怎样选择物品可以得到最大的价值</p>
<p><strong>P1507 NASA的食物计划</strong></p>
<p>航天飞机的体积有限，当然如果载过重的物品，燃料会浪费很多钱，每件食品都有各自的体积、质量以及所含卡路里。在告诉你体积和质量的最大值的情况下，请输出能达到的食品方案所含卡路里的最大值，当然每个食品只能使用一次。</p>
<h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>状态定义：</p>
<p>现在不仅仅是对体积有限制，还对质量有限制，因此我们在选择一个物品时还应该在意当前的质量，所以需要在01背包的基础上再加一个维度</p>
<p>定义<code>dp[i][j][k]</code>为遍历到第 i 个物品，当前体积不超过 j ，质量不超过 k 获得的最大卡路里值</p>
<p>转移方程</p>
<p><code>dp[i][j][k]=max(dp[i−1][j][k],dp[i−1][j−c[i]][k−g[i]]+w[i])</code></p>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">55</span>, M = <span class="number">4e2</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> h1[N], t1[N], k1[N];</span><br><span class="line"><span class="type">int</span> f[N][M][M];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> h, t, n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;h, &amp;t, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;h1[i], &amp;t1[i], &amp;k1[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i][<span class="number">0</span>][<span class="number">0</span>] = f[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= h; j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= t; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                f[i][j][k] = f[i - <span class="number">1</span>][j][k];</span><br><span class="line">                <span class="keyword">if</span> (h1[i] &lt;= j &amp;&amp; t1[i] &lt;= k)</span><br><span class="line">                &#123;</span><br><span class="line">                    f[i][j][k] = <span class="built_in">max</span>(f[i][j][k], f[i - <span class="number">1</span>][j - h1[i]][k - t1[i]] + k1[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[n][h][t]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="物品总个数的限制"><a href="#物品总个数的限制" class="headerlink" title="物品总个数的限制"></a>物品总个数的限制</h3><p>有时,”二维费用” 的条件是以这样一种隐含的方式给出的：最多只能取 U 件物品。这事实上相等于每件物品多了一种 “件数” 的费用，每个物品的件数费用均为 1 ，可以付出的最大件数费用为 U </p>
<h2 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h2><h3 id="题目大意-5"><a href="#题目大意-5" class="headerlink" title="题目大意"></a>题目大意</h3><p>有 N 件物品和一个容量为 V 的背包。第i ii件物品的费用是 c [ i ] ，价值是 w [ i ] 。这些物品被划分为若干组，每组中的物品互相冲突，最多选一件。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。</p>
<h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><p>将同一组的物品整合起来，称为一个大物品，那么问题就变成了若干个大物品中，每个可以选择其中的一个物品，求总费用不超过限制的价值最大值是多少？</p>
<p>其实可以发现，这个非常的类似多重背包。</p>
<p>定义<code>f[k][j]</code>为遍历到第 k 个大物品，当前体积不超过 j 的价值最大值</p>
<p><code>f[k][j] = max(f[k-1][j] , f[k-1][j-c[i]]+w[i]) </code>   物品 i $\subseteq $组别 k</p>
<h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1005</span>;</span><br><span class="line"><span class="type">int</span> dp[N][N], q[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> wei, val;</span><br><span class="line">    <span class="built_in">node</span>(<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">    &#123;</span><br><span class="line">        wei = a, val = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;node&gt; ve[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;m, &amp;n);</span><br><span class="line">    <span class="type">int</span> we = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        ve[c].<span class="built_in">push_back</span>(<span class="built_in">node</span>(a, b));</span><br><span class="line">        we = <span class="built_in">max</span>(we, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= we; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++)</span><br><span class="line">            dp[i][j] = <span class="number">-1e9</span>;</span><br><span class="line"></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= we; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 遍历体积</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 遍历决策</span></span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; ve[i].<span class="built_in">size</span>(); k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (ve[i][k].wei &lt;= j)</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i - <span class="number">1</span>][j - ve[i][k].wei] + ve[i][k].val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; i++)</span><br><span class="line">        res = <span class="built_in">max</span>(res, dp[we][i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="有依赖的背包问题"><a href="#有依赖的背包问题" class="headerlink" title="有依赖的背包问题"></a>有依赖的背包问题</h2><blockquote>
<p>这种背包问题的物品间存在某种“依赖”的关系。也就是说，i 依赖于 j ，表示若选物品 i ，则必须选物品 j 。</p>
</blockquote>
<p>比如：</p>
<p><del>要求你加入集训队试训前，一定要刷完专题</del></p>
<h3 id="题目大意-6"><a href="#题目大意-6" class="headerlink" title="题目大意"></a>题目大意</h3><p>给出每个物品的价格和重要度和是否是主件或者说是谁的附件，求最后选出的每件物品的价格与重要度乘积和的最大值，每个附件不再有附件。</p>
<p>P1064 [NOIP2006 提高组] 金明的预算方案</p>
<table>
<thead>
<tr>
<th>主件</th>
<th>附 件</th>
</tr>
</thead>
<tbody><tr>
<td>电脑</td>
<td>打印机，扫描仪</td>
</tr>
<tr>
<td>书柜</td>
<td>图书</td>
</tr>
<tr>
<td>书桌</td>
<td>台灯，文具</td>
</tr>
<tr>
<td>工作椅</td>
<td>无</td>
</tr>
</tbody></table>
<p>一个主件和它的附件集合是几乎对于分组背包中的一个物品组。</p>
<p>每个选择了主件又选择了若干附件的策略，对应这个物品组的中的一个物品。</p>
<h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><p>我们可以将每个主件选附件的问题看成一个01背包问题，这样当我们知道给一个主件分配多少价钱的时候，就可以知道此时这个主件及其附件在对应的价钱可以获得的最大价值</p>
<h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">4e3</span> + <span class="number">5</span>, M = <span class="number">65</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ve[M];</span><br><span class="line"><span class="type">int</span> wei[M], imp[M];<span class="comment">//价格和重要度</span></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> dp[M][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;m, &amp;n);</span><br><span class="line">    m /= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;wei[i], &amp;imp[i], &amp;c);</span><br><span class="line">        wei[i] /= <span class="number">10</span>;</span><br><span class="line">        ve[c].<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先处理给出每个主件分配不同空间时对应获得的最大价值</span></span><br><span class="line">    <span class="comment">//  遍历各主件</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">1</span>; u &lt;= n; u++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 01背包问题----(这里滚动了变成了一个维数组)</span></span><br><span class="line">        <span class="comment">// dp[u][j] 表示第 u 个背包，分配 j 体积 可以获得的最大价值</span></span><br><span class="line">        <span class="comment">//  遍历附件（物品数量)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; ve[u].<span class="built_in">size</span>(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> to = ve[u][j];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = m; k &gt;= wei[to]; k--)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[u][k] = <span class="built_in">max</span>(dp[u][k], dp[u][k - wei[to]] + imp[to] * wei[to] * <span class="number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 整合</span></span><br><span class="line">    <span class="comment">// 遍历主件</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ve[<span class="number">0</span>].<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> to = ve[<span class="number">0</span>][i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= wei[to]; j--)<span class="comment">//逆序！</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 遍历给当前主件的附件分配的空间</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = j - wei[to]; k &gt;= <span class="number">0</span>; k--)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[<span class="number">0</span>][j] = <span class="built_in">max</span>(dp[<span class="number">0</span>][j], dp[to][k] + imp[to] * wei[to] * <span class="number">10</span> + dp[<span class="number">0</span>][j - k - wei[to]]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dp[<span class="number">0</span>][m]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="较一般的题目"><a href="#较一般的题目" class="headerlink" title="较一般的题目"></a>较一般的题目</h3><p>依赖关系以图论中的 “森林” 形式给出，也就是说主件的附件依旧可以有自己的附件集合。</p>
<p>刚刚那道题可以直接那么做，主要是因为附件没有附件，如果还有附件的话，就需要继续先计算出附件在面对各价格时可获得的最大值才可以。</p>
<p>这种背包就是 <strong>树形背包</strong> （树形dp的一种），它的特点是每个父节点都需要对它的各个儿子的属性进行一次 dp 来求得自己相关的属性。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">4e3</span> + <span class="number">5</span>, M = <span class="number">65</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ve[M];</span><br><span class="line"><span class="type">int</span> wei[M], imp[M];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> dp[M][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//枚举物品</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ve[u].<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> to = ve[u][i];</span><br><span class="line">        <span class="built_in">dfs</span>(to);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//枚举分给当前物品的体积</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = j; k &gt;= <span class="number">0</span>; k--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (k - wei[to] &gt;= <span class="number">0</span>)</span><br><span class="line">                    dp[u][j] = <span class="built_in">max</span>(dp[u][j], dp[u][j - k] + dp[to][k - wei[to]] + imp[to] * wei[to] * <span class="number">10</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;m, &amp;n);</span><br><span class="line">    m /= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;wei[i], &amp;imp[i], &amp;c);</span><br><span class="line">        wei[i] /= <span class="number">10</span>;</span><br><span class="line">        ve[c].<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    res = dp[<span class="number">0</span>][m];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="背包问题的变化"><a href="#背包问题的变化" class="headerlink" title="背包问题的变化"></a>背包问题的变化</h2><h3 id="输出方案"><a href="#输出方案" class="headerlink" title="输出方案"></a>输出方案</h3><p>一般而言，背包问题是要求一个最优值，如果要求输出这个最优值的方案，可以参照一般动态规划问题输出方案的方法: 记录下每个状态的最优质是由状态转移方程的哪一项推出来的。然后就可以根据这个状态继续往前推导。</p>
<h4 id="题目大意-7"><a href="#题目大意-7" class="headerlink" title="题目大意"></a>题目大意</h4><p>01背包问题，但是要求输出 <strong>字典序最小的方案数</strong> 。</p>
<h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h4><p>求具体方案其实就是判断每个物品是否被选，求方案其实就是从<code>dp[n][m]</code>倒推出来每一个 i 是否选择</p>
<p>需要根据转移方程来判断是否选择第 i 个物品，所以不能滚动。</p>
<p>这里要求字典序最小，所以采用贪心的策略</p>
<p>然后对于每一个物品来说可能有三种情况</p>
<ul>
<li>只能选 —— 必选</li>
<li>只能不选 —— 必不选</li>
<li>可选可不选 —— 一定要选</li>
</ul>
<p>显然求字典序最小的时候，我们需要优先考虑编号小的物品，但是找方案的时候，又是从 <code>dp[n][m] </code> 开始回推的，所以我们在求解 01 背包的时候，从后往前推，就可以从 <code>dp[1][m]</code>始往前推了，这样的话，就和求字典序最小的顺序一致了。</p>
<h4 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> dp[maxn][maxn], n, m, w[maxn], c[maxn];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n;++i)</span><br><span class="line">        cin &gt;&gt; c[i] &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>;--i)<span class="comment">//逆序，使得编号小的可以从编号大的推算而出</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][j] = dp[i + <span class="number">1</span>][j];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(j&gt;=c[i])</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i + <span class="number">1</span>][j - c[i]] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> j = m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j-c[i]&gt;=<span class="number">0</span>&amp;&amp;dp[i][j]==dp[i+<span class="number">1</span>][j-c[i]]+w[i])<span class="comment">//分治</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">            j -= c[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//std::ios::sync_with_stdio(false);</span></span><br><span class="line"><span class="comment">//cin.tie(0);</span></span><br><span class="line"><span class="comment">//cout.tie(0);</span></span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="求第K优解"><a href="#求第K优解" class="headerlink" title="求第K优解"></a>求第K优解</h3><h4 id="题目大意-8"><a href="#题目大意-8" class="headerlink" title="题目大意"></a>题目大意</h4><p>01背包问题，但是需要输出的是可以获得的第 K 大价值。</p>
<h4 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h4><p>我们需要得到的是第 K 大价值，所以当我们得到一个当前为 K+1 大的价值时，就直接舍去。因为它一定不是第 K 大价值，然后我们又需要得到目前得到的 K 个价值具体是多少，所以我们在原来01背包的基础上再加一维</p>
<p>定义<code>dp[i][j][k]</code>: 遍历到第 i 个物品，且体积不超过 j 可得到的第 k 大价值</p>
<p>为了方便，滚动数组优化掉第一个维度，即状态变成<code>dp[i][j]</code>：体积不超过 i 时可以得到的第 j 大价值是多少</p>
<p>01背包的状态转移方程:<code>dp[i][j] = max(dp[i-1][j], dp[i-1][j-c[i]]+w[i])</code></p>
<p>划分了当前选和不选，显然这里的选择会影响到当前状态的 k 个最大值</p>
<p>所以我们取出这两种选法对应的 2*k 个数，排序成新的 k 个最大数</p>
<h4 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">1005</span>][<span class="number">35</span>], wei[<span class="number">105</span>], val[<span class="number">105</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="type">int</span> n, v, k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;v, &amp;k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;val[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;wei[i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= v; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= k; j++)</span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = v; j &gt;= wei[i]; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//a数组记录的是不选第 i 个物品的 k 个最大价值</span></span><br><span class="line">                <span class="comment">//b数组记录的是选第 i 个物品的 k 个最大价值</span></span><br><span class="line">                <span class="type">int</span> a[<span class="number">35</span>] = &#123;<span class="number">0</span>&#125;, b[<span class="number">35</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>; l &lt;= k; l++)</span><br><span class="line">                &#123;</span><br><span class="line">                    a[l] = dp[j][l];</span><br><span class="line">                    b[l] = dp[j - wei[i]][l] + val[i];</span><br><span class="line">                &#125;</span><br><span class="line">                a[k + <span class="number">1</span>] = b[k + <span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> ai = <span class="number">1</span>, bi = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>; l &lt;= k &amp;&amp; (a[ai] != <span class="number">-1</span> || b[bi] != <span class="number">-1</span>); l++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (a[ai] &gt; b[bi])</span><br><span class="line">                        dp[j][l] = a[ai++];</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        dp[j][l] = b[bi++];</span><br><span class="line">                    <span class="comment">//相同的数算同一个</span></span><br><span class="line">                    <span class="keyword">if</span> (dp[j][l] == dp[j][l - <span class="number">1</span>])</span><br><span class="line">                        l--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dp[v][k]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>序号</th>
<th>题号</th>
<th>标题</th>
<th>题目类型</th>
<th>难度评级</th>
<th>题解</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>HDU 2602</td>
<td>Bone collector</td>
<td>01背包</td>
<td>⭐</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>P1060</td>
<td>开心的金明</td>
<td>01背包</td>
<td>⭐</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>P2871</td>
<td>Charm Bracelet S</td>
<td>01背包</td>
<td>⭐</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>P1156</td>
<td>垃圾陷阱</td>
<td>01背包</td>
<td>⭐⭐</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>POJ 1276</td>
<td>Cash Machine</td>
<td>多重背包</td>
<td>⭐</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>POJ 1014</td>
<td>Dividing</td>
<td>多重背包</td>
<td>⭐</td>
<td></td>
</tr>
<tr>
<td>7</td>
<td>P5365</td>
<td>英雄联盟</td>
<td>多重背包</td>
<td>⭐⭐</td>
<td></td>
</tr>
<tr>
<td>8</td>
<td>P1776</td>
<td>宝物筛选</td>
<td>多重背包</td>
<td>⭐⭐</td>
<td></td>
</tr>
<tr>
<td>9</td>
<td>P1853</td>
<td>投资的最大效益</td>
<td>多重背包</td>
<td>⭐⭐</td>
<td></td>
</tr>
<tr>
<td>10</td>
<td>P1782</td>
<td>旅行商的背包</td>
<td>混合背包</td>
<td>⭐⭐</td>
<td></td>
</tr>
<tr>
<td>11</td>
<td>P2851</td>
<td>The Fewest Coins G</td>
<td>混合背包</td>
<td>⭐⭐⭐</td>
<td></td>
</tr>
<tr>
<td>12</td>
<td>P1833</td>
<td>樱花</td>
<td>混合背包</td>
<td>⭐⭐</td>
<td></td>
</tr>
<tr>
<td>13</td>
<td>P1507</td>
<td>NASA的食物计划</td>
<td>二维费用背包</td>
<td>⭐</td>
<td></td>
</tr>
<tr>
<td>14</td>
<td>HDU 1712</td>
<td>ACboy needs your help</td>
<td>分组背包</td>
<td>⭐</td>
<td></td>
</tr>
<tr>
<td>15</td>
<td>P1757</td>
<td>通天之分组背包</td>
<td>分组背包</td>
<td>⭐</td>
<td></td>
</tr>
<tr>
<td>16</td>
<td>P1064</td>
<td>金明的预算方案</td>
<td>有依赖背包</td>
<td>⭐⭐</td>
<td></td>
</tr>
<tr>
<td>17</td>
<td>P3961</td>
<td>黄金矿工</td>
<td>有依赖背包</td>
<td>⭐⭐⭐</td>
<td></td>
</tr>
<tr>
<td>18</td>
<td>POJ 1015</td>
<td>Jury Compromise</td>
<td>01背包+输出具体方案</td>
<td>⭐⭐⭐</td>
<td></td>
</tr>
<tr>
<td>19</td>
<td>HDU 2639</td>
<td>Bone Collector  ||</td>
<td>求第 k 优解</td>
<td>⭐⭐</td>
<td></td>
</tr>
<tr>
<td>20</td>
<td>P1858</td>
<td>多人背包</td>
<td>求第 k 优解</td>
<td>⭐⭐</td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>acm</category>
        <category>dp</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>埃式筛</title>
    <url>/2024/05/30/acm/%E6%95%B0%E8%AE%BA/%E5%9F%83%E5%BC%8F%E7%AD%9B/</url>
    <content><![CDATA[<h1 id="埃式筛"><a href="#埃式筛" class="headerlink" title="埃式筛"></a>埃式筛</h1><p>这是一个和辗转相除法一样古老的算法。原理也很简单。<br>首先将2到n范国内的整数写下来。其中2是最小的素数。将表中所有的2的倍数划去，表中剩下的最小的数宇就是3，他不能被更小的数整除，所以3是素数。<br>再将表中所有的3的倍数划去<br>⋯以此类推，_ 如果表中剩余的最小的数是m，那么m就是素数。<br>然后将表中所有m的倍数划去，像这样反复操作。就能依次枚举n以内的素数</p>
<h2 id="1-求1-20之间的素数个数"><a href="#1-求1-20之间的素数个数" class="headerlink" title="1.求1-20之间的素数个数"></a>1.求1-20之间的素数个数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;<span class="comment">//用来计数</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> isprime[<span class="number">21</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">20</span>;i++)isprime[i]=<span class="literal">true</span>;<span class="comment">//先全部置为真</span></span><br><span class="line"> </span><br><span class="line">    isprime[<span class="number">0</span>]=isprime[<span class="number">1</span>]=<span class="literal">false</span>;<span class="comment">//1 0 不是素数</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">20</span>;i++)&#123;<span class="comment">//从2开始往后筛</span></span><br><span class="line">        <span class="keyword">if</span>(isprime[i])&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>*i;j&lt;=<span class="number">20</span>;j+=i)&#123;</span><br><span class="line">                isprime[j]=<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(isprime[i])&#123;</span><br><span class="line">            cnt++;<span class="comment">//如果是素数 就计数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,cnt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>acm</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>快速幂</title>
    <url>/2024/05/30/acm/%E6%95%B0%E8%AE%BA/%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
    <content><![CDATA[<h1 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//计算a的b次方mod m</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">binpow</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a, <span class="type">long</span> <span class="type">long</span> b, <span class="type">long</span> <span class="type">long</span> m)</span> </span>&#123;</span><br><span class="line">  a %= m;</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> res = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (b &amp; <span class="number">1</span>) res = res * a % m;</span><br><span class="line">    a = a * a % m;</span><br><span class="line">    b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>根据费马小定理，如果 m 是一个质数，我们可以计算 $a^{b\ mod\ (m-1)}$ 来加速算法过程</strong></p>
]]></content>
      <categories>
        <category>acm</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>最大公约数</title>
    <url>/2024/05/30/acm/%E6%95%B0%E8%AE%BA/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/</url>
    <content><![CDATA[<h1 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h1><h2 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h2><blockquote>
<p>求出a和b的最大公约数</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">int</span> tmp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = tmp % b;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="更相减损术"><a href="#更相减损术" class="headerlink" title="更相减损术"></a>更相减损术</h3><blockquote>
<p>大整数取模的时间复杂度较高，而加减法时间复杂度较低。针对大整数，我们可以用加减代替乘除求出最大公约数。</p>
</blockquote>
<p>$gcd(a,b)\ &#x3D; \ gcd(a-b,b)$</p>
<h2 id="多个数的最大公约数"><a href="#多个数的最大公约数" class="headerlink" title="多个数的最大公约数"></a>多个数的最大公约数</h2><p>答案一定是每个数的约数，那么也一定是每相邻两个数的约数。我们采用归纳法，可以证明，每次取出两个数求出答案后再放回去，不会对所需要的答案造成影响。</p>
<h2 id="最小公倍数"><a href="#最小公倍数" class="headerlink" title="最小公倍数"></a>最小公倍数</h2><h3 id="两个数"><a href="#两个数" class="headerlink" title="两个数"></a>两个数</h3><p>$gcd(a,b)\ \times lcm(a,b)\ &#x3D; \ a \times b$</p>
<h3 id="多个数"><a href="#多个数" class="headerlink" title="多个数"></a>多个数</h3><p>可以发现，当我们求出两个数的 gcd 时，求最小公倍数是 O(1) 的复杂度。那么对于多个数，我们其实没有必要求一个共同的最大公约数再去处理，最直接的方法就是，当我们算出两个数的 gcd ，或许在求多个数的 gcd  时候，我们将它放入序列对后面的数继续求解，那么，我们转换一下，直接将最小公倍数放入序列即可</p>
<h2 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h2><p>常用于求$ax\ +\ by\ &#x3D;\ gcd(a,b)$​ 的一组可行解</p>
<h4 id="递归求法"><a href="#递归求法" class="headerlink" title="递归求法"></a>递归求法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Exgcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!b) &#123;</span><br><span class="line">    x = <span class="number">1</span>;</span><br><span class="line">    y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> d = <span class="built_in">Exgcd</span>(b, a % b, x, y);</span><br><span class="line">  <span class="type">int</span> t = x;</span><br><span class="line">  x = y;</span><br><span class="line">  y = t - (a / b) * y;</span><br><span class="line">  <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span>&amp; x, <span class="type">int</span>&amp; y)</span> </span>&#123;</span><br><span class="line">  x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> x1 = <span class="number">0</span>, y1 = <span class="number">1</span>, a1 = a, b1 = b;</span><br><span class="line">  <span class="keyword">while</span> (b1) &#123;</span><br><span class="line">    <span class="type">int</span> q = a1 / b1;</span><br><span class="line">    <span class="built_in">tie</span>(x, x1) = <span class="built_in">make_tuple</span>(x1, x - q * x1);</span><br><span class="line">    <span class="built_in">tie</span>(y, y1) = <span class="built_in">make_tuple</span>(y1, y - q * y1);</span><br><span class="line">    <span class="built_in">tie</span>(a1, b1) = <span class="built_in">make_tuple</span>(b1, a1 - q * b1);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>acm</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>欧拉函数</title>
    <url>/2024/05/30/acm/%E6%95%B0%E8%AE%BA/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h1><blockquote>
<p>求小于等于n和n互质的数的个数</p>
<p>$\alpha(n)$</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">euler_phi</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> ans = n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i * i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">      ans = ans / i * (i - <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">while</span> (n % i == <span class="number">0</span>) n /= i;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">1</span>) ans = ans / n * (n - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h2><p>$若\ gcd(a,m)\ &#x3D;\ 1,则a^{\alpha(m) }\ \equiv \ 1\ (mod\ m)$</p>
]]></content>
      <categories>
        <category>acm</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>斐波那契数列</title>
    <url>/2024/05/30/acm/%E6%95%B0%E8%AE%BA/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<h1 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h1><blockquote>
<p>$F_{n-1}F_{n+1}-F_n^{2} &#x3D; (-1)^n$</p>
<p>$F_{n+k}&#x3D;F_kF_{n+1}+F_{k-1}F_n$</p>
<p>取上一条性质中k&#x3D;n，我们得到$F_{2n}&#x3D;F_n(F_{n+1}+F_{n-1})$</p>
<p>GCD性质：$(F_m,F_n)&#x3D;F_{(m,n)}$</p>
</blockquote>
]]></content>
      <categories>
        <category>acm</category>
        <category>组合数学</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>线性筛</title>
    <url>/2024/05/30/acm/%E6%95%B0%E8%AE%BA/%E7%BA%BF%E6%80%A7%E7%AD%9B/</url>
    <content><![CDATA[<h2 id="线性筛"><a href="#线性筛" class="headerlink" title="线性筛"></a>线性筛</h2><p>初始时，假设全部都是素数，当找到一个素数时，显然这个素数乘上另外一个数之后都是合数<br>把这些合数都筛掉，即<a href="http://lib.csdn.net/base/datastructure">算法</a>名字的由来。但仔细分析能发现，这种方法会造成重复筛除合数，影响效率。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> pri[N+<span class="number">9</span>&gt;&gt;<span class="number">1</span>],now;</span><br><span class="line"><span class="type">bool</span> vis[N+<span class="number">9</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])pri[++now]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=now&amp;&amp;pri[j]*i&lt;=N;j++)&#123;</span><br><span class="line">            vis[pri[j]*i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%pri[j]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>acm</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>费马小定理</title>
    <url>/2024/05/30/acm/%E6%95%B0%E8%AE%BA/%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<h1 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h1><blockquote>
<p> 若p为素数，$若\ gcd(a,p)\ &#x3D;\ 1,则a^{p-1}\ \equiv \ 1\ (mod\ p)$</p>
</blockquote>
]]></content>
      <categories>
        <category>acm</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>二分</title>
    <url>/2024/05/30/acm/%E5%9F%BA%E7%A1%80/%E4%BA%8C%E5%88%86/</url>
    <content><![CDATA[<h1 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h1><p>找最大</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> x)</span> &#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">bsearch</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(mid)) l = mid;<span class="comment">//check中的mid符合条件包含</span></span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//有可能不存在，需要特判一下是否存在.</span></span><br></pre></td></tr></table></figure>



<p>找最小</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> x)</span> &#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">bsearch</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(mid)) r = mid;<span class="comment">//check中的mid符合条件包含</span></span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//有可能不存在，需要特判一下是否存在.</span></span><br></pre></td></tr></table></figure>

<h2 id="1-杨辉三角"><a href="#1-杨辉三角" class="headerlink" title="1.杨辉三角"></a>1.杨辉三角</h2><p>在杨辉三角中给定一个正整数 <em>N</em>，请你输出数列中第一次出现 <em>N</em> 是在第几个数。</p>
<p>杨辉三角除了几何模型上的数关系外，每一行都是<strong>排列组合</strong>的结果，通过这个来查找某一行某一列的数的大小，由于题目数据比较大，则采用<strong>二分</strong>查找降低时间复杂度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># include &lt;stdio.h&gt;</span><br><span class="line"># include &lt;string.h&gt;</span><br><span class="line"># include &lt;algorithm&gt;</span><br><span class="line"># include &lt;iostream&gt;</span><br><span class="line"># include &lt;functional&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define LL long long</span><br><span class="line">const int maxn=1e8;</span><br><span class="line"></span><br><span class="line">LL int node(LL int q,LL int p)//输出第q行第p列的值的大小</span><br><span class="line">&#123;</span><br><span class="line">    LL int sum=1;</span><br><span class="line">    for(int i=q;i&gt;=q-p+1;--i)</span><br><span class="line">    &#123;</span><br><span class="line">      sum*=i;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int j=1;j&lt;=p;++j)</span><br><span class="line">    sum/=j;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL int jie(int k)//算出前面有几个数（也可以用等差数列公式）</span><br><span class="line">&#123;</span><br><span class="line">    LL int zong=0;</span><br><span class="line">    for(int i=1;i&lt;=k;++i)</span><br><span class="line">    zong+=i;</span><br><span class="line">    return zong;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    int sum=0;</span><br><span class="line">    if(n==1)</span><br><span class="line">    cout&lt;&lt;1&lt;&lt;endl;//特殊情况</span><br><span class="line">    else&#123;</span><br><span class="line">        for(int i=20;i&gt;=0;--i)//对每一列进行查找</span><br><span class="line">        &#123;</span><br><span class="line">            int l=2*i;</span><br><span class="line">            int r=n;</span><br><span class="line">            while(l&lt;=r)//二分查找</span><br><span class="line">            &#123;</span><br><span class="line">                int mid=(l+r)&gt;&gt;1;</span><br><span class="line">                LL int o=node(mid,i);</span><br><span class="line">                if(o==n)</span><br><span class="line">                &#123;</span><br><span class="line">                    sum=1;</span><br><span class="line">                    cout&lt;&lt;jie(mid)+i+1&lt;&lt;endl;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                else if(o&gt;n)//大了的话行数变小</span><br><span class="line">                &#123;</span><br><span class="line">                    r=mid-1;</span><br><span class="line">                &#125;</span><br><span class="line">                else//行数变大</span><br><span class="line">                l=mid+1;</span><br><span class="line">            &#125;</span><br><span class="line">            if(sum==1)</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-wyh的物品"><a href="#2-wyh的物品" class="headerlink" title="2.wyh的物品"></a>2.wyh的物品</h2><p>wyh学长现在手里有 nnn 个物品，这 nnn 个物品的重量和价值都告诉你，然后现在让你从中选取 kkk 个，问你在所有可能选取的方案中，最大的单位价值为多少（单位价值为选取的 kkk 个物品的总价值和总重量的比值）.</p>
<p>本题<strong>不能采用dp</strong>，算出<strong>每一个物品的单位价值的和不等于总价值和总质量的比值</strong>；由于我们要查找最大单位价值，则可以采用二分去找出最大的单位价值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line">using ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line">ll w[maxn],v[maxn];</span><br><span class="line"><span class="type">double</span> c[maxn];</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">check</span><span class="params">(<span class="type">double</span> x)</span><span class="comment">//判断</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        c[i]=v[i]-x*w[i];</span><br><span class="line">    sort(c+<span class="number">1</span>,c+n+<span class="number">1</span>);<span class="comment">//对最后剩余的价值进行排序（升序）</span></span><br><span class="line">    <span class="type">double</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;n-k;--i)<span class="comment">//取大的</span></span><br><span class="line">        res+=c[i];</span><br><span class="line">    <span class="keyword">return</span> res&gt;=<span class="number">0</span>;<span class="comment">//如果最后的价值仍有剩余，则mid可以更大，选择右区间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//cin.tie(0)-&gt;sync_with_stdio(false);</span></span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>,&amp;w[i],&amp;v[i]);</span><br><span class="line">        <span class="type">double</span> l=<span class="number">0</span>,r=<span class="number">1e9</span>;</span><br><span class="line">        <span class="keyword">while</span>(r-l&gt;<span class="number">1e-5</span>)<span class="comment">//二分</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">double</span> mid=(r+l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(check(mid))</span><br><span class="line">                l=mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.2lf\n&quot;</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>acm</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>乘法逆元</title>
    <url>/2024/05/30/acm/%E6%95%B0%E8%AE%BA/%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83/</url>
    <content><![CDATA[<h1 id="乘法逆元"><a href="#乘法逆元" class="headerlink" title="乘法逆元"></a>乘法逆元</h1><p>给定正整数a，b，如果有 $ax\ \equiv \ 1\ (mod\ b)$​，且a与b互质，则称x的最小正整数解为a模b的逆元，（可以理解为倒数)。模n意义下，1个数a如果有逆元x，那么除以a相当于乘以x。</p>
<blockquote>
<p>如果一个线性同余方程$ax\ \equiv \ 1\ (mod\ b)$,则x称为a mod b的逆元</p>
</blockquote>
<h2 id="扩展欧几里得法"><a href="#扩展欧几里得法" class="headerlink" title="扩展欧几里得法"></a>扩展欧几里得法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span>&amp; x, <span class="type">int</span>&amp; y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">    x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exgcd</span>(b, a % b, y, x);</span><br><span class="line">  y -= a / b * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="快速幂法"><a href="#快速幂法" class="headerlink" title="快速幂法"></a>快速幂法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">  a = (a % p + p) % p;</span><br><span class="line">  <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ans = (a * ans) % p;</span><br><span class="line">    a = (a * a) % p;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>acm</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>stl</title>
    <url>/2024/05/30/acm/%E5%9F%BA%E7%A1%80/stl/</url>
    <content><![CDATA[<h1 id="stl容器"><a href="#stl容器" class="headerlink" title="stl容器"></a>stl容器</h1><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><blockquote>
<p>动态分配内存</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">v1</span>(<span class="number">3</span>);</span><br><span class="line">v1.<span class="built_in">insert</span>();<span class="comment">//在迭代器位置插入元素</span></span><br><span class="line">v1.<span class="built_in">erase</span>();<span class="comment">//在迭代器或区间删除元素</span></span><br><span class="line">v1.<span class="built_in">push_back</span>();</span><br><span class="line">v1.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="array"><a href="#array" class="headerlink" title="array"></a>array</h3><blockquote>
<p>固定长度的数组数据结构</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">array&lt;<span class="type">int</span>,3&gt; v0;</span><br><span class="line">v0.<span class="built_in">fill</span>(<span class="number">1</span>);<span class="comment">//以指定值填充容器</span></span><br><span class="line">v0.<span class="built_in">front</span>();<span class="comment">//第一个元素</span></span><br><span class="line">v0.<span class="built_in">back</span>();<span class="comment">//最后一个元素</span></span><br><span class="line">v0.<span class="built_in">data</span>();</span><br></pre></td></tr></table></figure>

<h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h2><blockquote>
<p>双端队列</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">deque&lt;<span class="type">int</span>&gt;v0;</span><br><span class="line">v0.<span class="built_in">front</span>();</span><br><span class="line">v0.<span class="built_in">back</span>();</span><br><span class="line">v0.<span class="built_in">insert</span>();</span><br><span class="line">v0.<span class="built_in">push_front</span>();</span><br><span class="line">v0.<span class="built_in">pop_front</span>();</span><br><span class="line">v0.<span class="built_in">push_back</span>();</span><br><span class="line">v0.<span class="built_in">pop_back</span>();</span><br></pre></td></tr></table></figure>

<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><blockquote>
<p>本身时排好序的</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt;s;</span><br><span class="line">s.<span class="built_in">insert</span>();</span><br><span class="line">s.<span class="built_in">erase</span>(x);<span class="comment">//删除值为x的元素</span></span><br><span class="line">s.<span class="built_in">erase</span>(pos);<span class="comment">//删除迭代器为pos的元素</span></span><br><span class="line">s.<span class="built_in">erase</span>(frist,last);<span class="comment">//删除区间元素</span></span><br><span class="line">s.<span class="built_in">count</span>(x);</span><br><span class="line">s.<span class="built_in">find</span>(x);</span><br><span class="line"><span class="comment">//O(logn)</span></span><br><span class="line">s.<span class="built_in">lower_bound</span>(x);<span class="comment">//返回指向首个不小于给定键的元素的迭代器。如果不存在这样的元素，返回 end()</span></span><br><span class="line">s.<span class="built_in">upper_bound</span>(x);<span class="comment">//返回指向首个大于给定键的元素的迭代器。如果不存在这样的元素，返回 end()</span></span><br></pre></td></tr></table></figure>

<p><strong><code>set</code> 在默认情况下的比较函数为 <code>&lt;</code>。然而在某些特殊情况下，我们希望能自定义 <code>set</code> 内部的比较方式。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span>&#123;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;<span class="keyword">return</span> a&gt;b&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">set&lt;<span class="type">int</span>,cmp&gt;s;</span><br></pre></td></tr></table></figure>

<h3 id="multiset"><a href="#multiset" class="headerlink" title="multiset"></a>multiset</h3><blockquote>
<p>可以看成一个序列，插入一个数，删除一个数都能够在O(logn)的时间内完成，而且他能时刻保证序列中的数是有序的，而且序列中可以存在重复的数。</p>
</blockquote>
<h3 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>&gt;que;<span class="comment">//从大到小</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt; &gt;que;<span class="comment">//从小到大</span></span><br></pre></td></tr></table></figure>



<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="binary-search"><a href="#binary-search" class="headerlink" title="binary_search"></a>binary_search</h3><blockquote>
<p>二分查找</p>
<p>找到返回1，找不到返回0</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">binary_search</span>(数组名+n1，数组名+n2，值);</span><br></pre></td></tr></table></figure>

<h3 id="lower-bound"><a href="#lower-bound" class="headerlink" title="lower_bound"></a>lower_bound</h3><blockquote>
<p>在一个有序序列中进行二分查找，返回指向第一个 <strong>大于等于</strong> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="x"> 的元素的位置的迭代器。如果不存在这样的元素，则返回尾迭代器</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">lower_bound</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),x);</span><br></pre></td></tr></table></figure>

<h3 id="upper-bound"><a href="#upper-bound" class="headerlink" title="upper_bound"></a>upper_bound</h3><blockquote>
<p>在一个有序序列中进行二分查找，返回指向第一个 <strong>大于</strong> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="x"> 的元素的位置的迭代器。如果不存在这样的元素，则返回尾迭代器</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upper_bound(v.begin(),v.end(),x);</span><br></pre></td></tr></table></figure>

<h3 id="next-permutation"><a href="#next-permutation" class="headerlink" title="next_permutation"></a>next_permutation</h3><blockquote>
<p>将当前排列更改为 <strong>全排列中的下一个排列</strong>。如果当前排列已经是 <strong>全排列中的最后一个排列</strong>（元素完全从大到小排列），函数返回 <code>false</code> 并将排列更改为 <strong>全排列中的第一个排列</strong>（元素完全从小到大排列）；否则，函数返回 <code>true</code></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">next_permutation</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>()))</span><br></pre></td></tr></table></figure>

<h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string s;</span><br><span class="line">s.find(&#x27;x&#x27;);//第一次出现x字符的位置</span><br><span class="line">s.find(&#x27;x&#x27;,pos);//从pos位置起第一次出现x字符</span><br><span class="line">s.substr(pos,len);//从pos位置开始截取最多len个字符组成的字符串</span><br><span class="line">s.erase(index，count);//从index位置开始的count个字符删除，count可省略</span><br><span class="line">s.insert(index,count,ch);//从index处连续插入count次字符串ch，count可省略即为1次</span><br><span class="line">s.replace(pos,count,str);//从pos开始的count个字符替换为str</span><br><span class="line">s.replace(first,last,str);//从[first,last)的子串替换为str</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>acm</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>高精度计算</title>
    <url>/2024/05/30/acm/%E5%9F%BA%E7%A1%80/%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<h1 id="高精度计算"><a href="#高精度计算" class="headerlink" title="高精度计算"></a>高精度计算</h1><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1004</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[LEN], b[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">(<span class="type">int</span> a[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; LEN; ++i) a[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> a[])</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">char</span> s[LEN + <span class="number">1</span>];</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">clear</span>(a);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) a[len - i - <span class="number">1</span>] = s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> a[])</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = LEN - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">    <span class="keyword">if</span> (a[i] != <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &gt;= <span class="number">0</span>; --i) <span class="built_in">putchar</span>(a[i] + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">  <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">read</span>(a);</span><br><span class="line">  <span class="built_in">print</span>(a);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1004</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[LEN], b[LEN], c[LEN], d[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">(<span class="type">int</span> a[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; LEN; ++i) a[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> a[])</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">char</span> s[LEN + <span class="number">1</span>];</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">clear</span>(a);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) a[len - i - <span class="number">1</span>] = s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> a[])</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = LEN - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">    <span class="keyword">if</span> (a[i] != <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &gt;= <span class="number">0</span>; --i) <span class="built_in">putchar</span>(a[i] + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">  <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加法计算器</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> b[], <span class="type">int</span> c[])</span> </span>&#123;</span><br><span class="line">  <span class="built_in">clear</span>(c);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; LEN - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">    c[i] += a[i] + b[i];</span><br><span class="line">    <span class="keyword">if</span> (c[i] &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">      c[i + <span class="number">1</span>] += <span class="number">1</span>;</span><br><span class="line">      c[i] -= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//减法计算器</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sub</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> b[], <span class="type">int</span> c[])</span> </span>&#123;</span><br><span class="line">  <span class="built_in">clear</span>(c);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; LEN - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">    c[i] += a[i] - b[i];</span><br><span class="line">    <span class="keyword">if</span> (c[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      c[i + <span class="number">1</span>] -= <span class="number">1</span>;</span><br><span class="line">      c[i] += <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//乘法计算器(高精度-低精度)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mul_short</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> b, <span class="type">int</span> c[])</span> </span>&#123;</span><br><span class="line">  <span class="built_in">clear</span>(c);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; LEN - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">    <span class="comment">// 直接把 a 的第 i 位数码乘以乘数，加入结果</span></span><br><span class="line">    c[i] += a[i] * b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c[i] &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">      <span class="comment">// 处理进位</span></span><br><span class="line">      <span class="comment">// c[i] / 10 即除法的商数成为进位的增量值</span></span><br><span class="line">      c[i + <span class="number">1</span>] += c[i] / <span class="number">10</span>;</span><br><span class="line">      <span class="comment">// 而 c[i] % 10 即除法的余数成为在当前位留下的值</span></span><br><span class="line">      c[i] %= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//乘法计算器(高精度-高精度)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> b[], <span class="type">int</span> c[])</span> </span>&#123;</span><br><span class="line">  <span class="built_in">clear</span>(c);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; LEN - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; ++j) c[i] += a[j] * b[i - j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c[i] &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">      c[i + <span class="number">1</span>] += c[i] / <span class="number">10</span>;</span><br><span class="line">      c[i] %= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">greater_eq</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> b[], <span class="type">int</span> last_dg, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (a[last_dg + len] != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[last_dg + i] &gt; b[i]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (a[last_dg + i] &lt; b[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//除法计算器</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">div</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> b[], <span class="type">int</span> c[], <span class="type">int</span> d[])</span> </span>&#123;</span><br><span class="line">  <span class="built_in">clear</span>(c);</span><br><span class="line">  <span class="built_in">clear</span>(d);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> la, lb;</span><br><span class="line">  <span class="keyword">for</span> (la = LEN - <span class="number">1</span>; la &gt; <span class="number">0</span>; --la)</span><br><span class="line">    <span class="keyword">if</span> (a[la - <span class="number">1</span>] != <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">for</span> (lb = LEN - <span class="number">1</span>; lb &gt; <span class="number">0</span>; --lb)</span><br><span class="line">    <span class="keyword">if</span> (b[lb - <span class="number">1</span>] != <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">if</span> (lb == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&gt; &lt;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; la; ++i) d[i] = a[i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = la - lb; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">greater_eq</span>(d, b, i, lb)) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; lb; ++j) &#123;</span><br><span class="line">        d[i + j] -= b[j];</span><br><span class="line">        <span class="keyword">if</span> (d[i + j] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">          d[i + j + <span class="number">1</span>] -= <span class="number">1</span>;</span><br><span class="line">          d[i + j] += <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      c[i] += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">read</span>(a);</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> op[<span class="number">4</span>];</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">read</span>(b);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (op[<span class="number">0</span>]) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">      <span class="built_in">add</span>(a, b, c);</span><br><span class="line">      <span class="built_in">print</span>(c);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">      <span class="built_in">sub</span>(a, b, c);</span><br><span class="line">      <span class="built_in">print</span>(c);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">      <span class="built_in">mul</span>(a, b, c);</span><br><span class="line">      <span class="built_in">print</span>(c);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">      <span class="built_in">div</span>(a, b, c, d);</span><br><span class="line">      <span class="built_in">print</span>(c);</span><br><span class="line">      <span class="built_in">print</span>(d);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;&gt; &lt;&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>acm</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>错排问题</title>
    <url>/2024/05/30/acm/%E6%95%B0%E8%AE%BA/%E9%94%99%E6%8E%92%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="错排问题"><a href="#错排问题" class="headerlink" title="错排问题"></a>错排问题</h1><p>又叫错位排列、重排，即使一个排列所有的元素都不在原来的位置上。</p>
<h2 id="1-信封问题"><a href="#1-信封问题" class="headerlink" title="1.信封问题"></a>1.信封问题</h2><p>共有 n  张信和 n  个信封，假设所有信都装错了信封，共有多少种情况？</p>
<p>k 号元素的排列有两种方式：</p>
<p>一是放在第 1 个位置，剩下的 n − 2  个元素进行错排，共有 f ( n − 2 ) 种可能；</p>
<p>二是不放在第 1个位置，这时我们将第 1个位置看作第 k 个位置，于是就形成了包括 k 号元素在内的 n − 1个元素的错排，共有 f ( n − 1 ) 种可能。</p>
<p>所以，k号元素共有 f ( n − 1 ) + f ( n − 2 ) 种可能。</p>
<p>又因为第一号元素有 n − 1 种放法，根据乘法原理。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">f</span><span class="params">(<span class="type">long</span> <span class="type">long</span> x)</span><span class="comment">//一定要开long long</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>( x == <span class="number">1</span> )</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>( x == <span class="number">2</span> )</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> (x<span class="number">-1</span>)*(f(x<span class="number">-1</span>)+f(x<span class="number">-2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;f(n);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>acm</category>
        <category>组合数学</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>AC自动机</title>
    <url>/2024/05/30/acm/%E5%AD%97%E7%AC%A6%E4%B8%B2/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/</url>
    <content><![CDATA[<h1 id="自动机"><a href="#自动机" class="headerlink" title="自动机"></a>自动机</h1><p>给定n个模式串和11个文本串，求有多少个模式串在文本串里<strong>出现过</strong>。(出现多次只算一次)</p>
<h2 id="前置技能"><a href="#前置技能" class="headerlink" title="前置技能"></a>前置技能</h2><p>1.Trie</p>
<p>2.KMP思想</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">note</span>&#123;</span><br><span class="line">    <span class="type">int</span> son[<span class="number">26</span>];<span class="comment">//26个英文字母</span></span><br><span class="line">    <span class="type">int</span> flag;<span class="comment">//标记是否是末端</span></span><br><span class="line">    <span class="type">int</span> fail;<span class="comment">//fail指针</span></span><br><span class="line">&#125;trie[maxn];</span><br><span class="line"><span class="type">int</span> n,cnt;</span><br><span class="line">string s;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt;q;</span><br></pre></td></tr></table></figure>



<p>我们将n个模式串建成一颗Trie树，建树的方式和建Trie完全一样</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string s)</span><span class="comment">//构建trie</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> u=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();++i)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="type">int</span> v=s[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">       <span class="keyword">if</span>(!trie[u].son[v])</span><br><span class="line">       trie[u].son[v]=++cnt;</span><br><span class="line">       u=trie[u].son[v];</span><br><span class="line">    &#125;</span><br><span class="line">    trie[u].flag++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://img2020.cnblogs.com/blog/1593693/202005/1593693-20200516230446086-779182765.png" alt="img"></p>
<p>假如我们现在有文本串ABCDBC</p>
<p>我们用文本串在Trie上匹配，刚开始会经过2、3、4号点，发现到4，成功匹配了一个模式串，然后就不能在继续匹配了，这时我们还要重新从根开始匹配吗？</p>
<p>这样效率太慢了。这时我们就要借用KMP的思想，从Trie上的某个点继续匹配</p>
<p>这时我们就应该确定从哪个点继续匹配？我们称i匹配失败后继续从j开始匹配，j是i的Fail(失配指针)</p>
<h2 id="求Fail"><a href="#求Fail" class="headerlink" title="求Fail"></a><strong>求Fail</strong></h2><p>首先我们可以确定，每一个点i的Fail指针指向的点的深度一定是比i小的。（Fail指的是后缀啊）</p>
<p>第一层的Fail一定指的是root。（比深度11还浅的只有root了）</p>
<p>设点i的父亲fa的Fail指针指的是fafail，那么如果fafail有和i值相同的儿子j，那么i的Fail就指向j。这里可能比较难理解一点，建议画图理解，不过等会转换成代码就很好理解了。</p>
<p>由于我们在处理i的情况必须要先处理好fa的情况，所以求Fail我们使用BFS来实现。</p>
<p><strong>实现的一些细节</strong></p>
<ul>
<li>1、刚开始我们不是要初始化第一层的fail指针为root，其实我们可以建一个虚节点00号节点，将00的<strong>所有儿子</strong>指向root（root编号为11，记得初始化)，然后root的fail指向00就OK了。效果是一样的。</li>
<li>2、如果不存在一个节点i，那么我们可以将那个节点设为fafail的**((值和i相同)的儿子)**。保证存在性，就算是00也可以成功返回到根，因为00的所有儿子都是根。</li>
<li>3、无论fafail存不存在和i值相同的儿子j，我们都可以将i的fail指向j。因为在处理i的时候j已经处理好了，如果出现这种情况，j的值是第22种情况，也是有实际值的，所以没有问题。</li>
<li>4、实现时不记父亲，我们直接让父亲更新儿子</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">getFail</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;++i)</span><br><span class="line">    trie[<span class="number">0</span>].son[i]=<span class="number">1</span>;<span class="comment">//初始化0的所有儿子都是0</span></span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);<span class="comment">//将根节点压入队列</span></span><br><span class="line">    trie[<span class="number">1</span>].fail=<span class="number">0</span>;<span class="comment">//1为root，将1的fail指向0</span></span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())<span class="comment">//bfs</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v=trie[u].son[i];<span class="comment">//其子节点</span></span><br><span class="line">            <span class="type">int</span> Fail=trie[u].fail;</span><br><span class="line">            <span class="keyword">if</span>(!v)<span class="comment">//表示不存在该节点</span></span><br><span class="line">            &#123;</span><br><span class="line">                trie[u].son[i]=trie[Fail].son[i];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            trie[v].fail=trie[Fail].son[i];</span><br><span class="line">            q.<span class="built_in">push</span>(v);<span class="comment">//存在实节点就压入队列</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="完整代码："><a href="#完整代码：" class="headerlink" title="完整代码："></a>完整代码：</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">note</span>&#123;</span><br><span class="line">    <span class="type">int</span> son[<span class="number">26</span>];<span class="comment">//26个英文字母</span></span><br><span class="line">    <span class="type">int</span> flag;<span class="comment">//标记是否是末端</span></span><br><span class="line">    <span class="type">int</span> fail;<span class="comment">//fail指针</span></span><br><span class="line">&#125;trie[maxn];</span><br><span class="line"><span class="type">int</span> n,cnt;</span><br><span class="line">string s;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string s)</span><span class="comment">//构建trie</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> u=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();++i)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="type">int</span> v=s[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">       <span class="keyword">if</span>(!trie[u].son[v])</span><br><span class="line">       trie[u].son[v]=++cnt;</span><br><span class="line">       u=trie[u].son[v];</span><br><span class="line">    &#125;</span><br><span class="line">    trie[u].flag++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getFail</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;++i)</span><br><span class="line">    trie[<span class="number">0</span>].son[i]=<span class="number">1</span>;<span class="comment">//初始化0的所有儿子都是0</span></span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);<span class="comment">//将根节点压入队列</span></span><br><span class="line">    trie[<span class="number">1</span>].fail=<span class="number">0</span>;<span class="comment">//1为root，将1的fail指向0</span></span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())<span class="comment">//bfs</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v=trie[u].son[i];<span class="comment">//其子节点</span></span><br><span class="line">            <span class="type">int</span> Fail=trie[u].fail;</span><br><span class="line">            <span class="keyword">if</span>(!v)<span class="comment">//表示不存在该节点</span></span><br><span class="line">            &#123;</span><br><span class="line">                trie[u].son[i]=trie[Fail].son[i];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            trie[v].fail=trie[Fail].son[i];</span><br><span class="line">            q.<span class="built_in">push</span>(v);<span class="comment">//存在实节点就压入队列</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> u=<span class="number">1</span>,ans=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();++i)</span><br><span class="line">   &#123;</span><br><span class="line">    <span class="type">int</span> v=s[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="type">int</span> k=trie[u].son[v];</span><br><span class="line">    <span class="keyword">while</span>(k&gt;<span class="number">1</span>&amp;&amp;trie[k].flag!=<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=trie[k].flag;</span><br><span class="line">        trie[k].flag=<span class="number">-1</span>;<span class="comment">//标记已经找过了</span></span><br><span class="line">        k=trie[k].fail;</span><br><span class="line">    &#125;</span><br><span class="line">    u=trie[u].son[v];<span class="comment">//到下一个儿子</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        <span class="built_in">insert</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">getFail</span>();</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">query</span>(s)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>acm</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>树状数组</title>
    <url>/2024/05/30/acm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="树状数组基础"><a href="#树状数组基础" class="headerlink" title="树状数组基础"></a>树状数组基础</h1><p>树状数组是线段树的简化版，可以做到：<strong>1.单点修改，单点查询，2.区间修改，单点查询，3.区间查询，区间修改</strong></p>
<p>树状数组的构造</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[<span class="number">1005</span>],t[<span class="number">1005</span>]; <span class="comment">//对应原数组和树状数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">lowbit</span><span class="params">(<span class="type">int</span> x)</span>&#123;<span class="comment">//计算一个非负整数n在二进制下的最低为1及其后面的0构成的数</span></span><br><span class="line">    <span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add_dandian</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span><span class="comment">//用于更新每一个节点的状态</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=x;i&lt;=n;i+=lowbit(i))</span><br><span class="line">	t[i]+=k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>单点修改，区间查询</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add_dandian</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span><span class="comment">//用于更新每一个节点的状态</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=x;i&lt;=n;i+=<span class="built_in">lowbit</span>(i))</span><br><span class="line">	t[i]+=k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(x)</span></span>&#123;<span class="comment">//查询前x项区间</span></span><br><span class="line">	<span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=x;i;i-=<span class="built_in">lowbit</span>(i))&#123;</span><br><span class="line">		sum+=t[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p>​       通过图中不难看出，sum[7]&#x3D;t[7]+t[6]+t[4] ,我们进一步发现,6&#x3D;7-lowbit(7),4&#x3D;6-lowbit(6)，所以我们可以通过不断的-   lowbit操作来实现求和</p>
<ul>
<li>求特定l到r区间(<strong>利用前缀和计算</strong>)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(<span class="type">int</span> L,<span class="type">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=L;i;i-=<span class="built_in">lowbit</span>(i))</span><br><span class="line">	ans+=c[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=R<span class="number">-1</span>;i;i-=<span class="built_in">lowbit</span>(i))</span><br><span class="line">	ans-=c[i];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>区间修改，单点查询</p>
<p>我们需要构造出<strong>原数组的差分数组b</strong>，然后<strong>用树状数组维护b数组</strong>即可</p>
<p>对于区间修改的话，我们<em><strong>只需要对差分数组进行操作</strong></em>即可，例如对区间[L,R]+k,那么我们只需要更新差分数组add(L,k),add(R+1,-k)，这是差分数组的性质.</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">update</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> k)</span><span class="comment">//pos表示修改点的位置,K表示修改的值也即+K操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=pos;i&lt;=n;i+=<span class="built_in">lowbit</span>(i))</span><br><span class="line">	c[i]+=k;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">update</span>(L,k);</span><br><span class="line"><span class="built_in">update</span>(R+<span class="number">1</span>,-k);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>单点查询:</p>
<p>求出b数组的前缀和即可，因为a[x]&#x3D;差分数组b[1]+b[2]+…+b[x]的前缀和，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="type">int</span> pos)</span><span class="comment">//返回区间pos到1的总和</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=pos;i;i-=<span class="built_in">lowbit</span>(i)) ans+=c[i];<span class="comment">//注意b数组是数组数组，树状数组求前缀和不是全部加起来</span></span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>区间修改，区间查询：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long </span></span><br><span class="line">ll <span class="type">int</span> n,f,t1[maxn],t2[maxn],c[maxn];<span class="comment">//t1,t2都为前缀数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> k&amp;(-k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_dandian</span><span class="params">(ll <span class="type">int</span> k,ll <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=k;i&lt;=n;i+=<span class="built_in">lowbit</span>(i))</span><br><span class="line">  &#123;</span><br><span class="line">    t1[i]+=p;</span><br><span class="line">    t2[i]+=p*k;<span class="comment">//记得乘k而不是i</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="type">int</span> <span class="title">search</span><span class="params">(ll <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   ll <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=k;i;i-=<span class="built_in">lowbit</span>(i))</span><br><span class="line">  &#123;</span><br><span class="line">    sum+=(k+<span class="number">1</span>)*t1[i]-t2[i];<span class="comment">//是乘k+1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;f;</span><br><span class="line">    c[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">      cin&gt;&gt;c[i];</span><br><span class="line">      <span class="built_in">add_dandian</span>(i,c[i]-c[i<span class="number">-1</span>]);<span class="comment">//差分数组建立树状数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=f;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l,r,k;</span><br><span class="line">        cin&gt;&gt;l&gt;&gt;r&gt;&gt;k;</span><br><span class="line">        <span class="built_in">add_dandian</span>(l,k);<span class="comment">//修改</span></span><br><span class="line">        cout&lt;&lt;<span class="built_in">search</span>(r)-<span class="built_in">search</span>(l<span class="number">-1</span>)&lt;&lt;endl;<span class="comment">//查询</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="逆序对"><a href="#逆序对" class="headerlink" title="逆序对"></a>逆序对</h2><p>给定的一段正整数序列 A，逆序对就是序列中 <code>Ai &gt; Aj</code> 且 <code>i &lt; j</code> 的有序对，输出 A 中逆序对总数目。</p>
<p>离散化就是另开一个数组, d[i]用来存放第i大的数在原序列的什么位置，比如原序列a&#x3D;{5，3，4，2，1}，第一大就是5，他在a中的位是1，所以d[1]&#x3D;1，同理d[2]&#x3D;3，········所以d数组为{1，3，2，4，5}，转换之后，空间复杂度就没这么高了，但不是求d中的逆序对了，而是求d中的正序对</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n,d[maxn]<span class="comment">//用来存放第i大的数在原序列的什么位置</span></span><br><span class="line"><span class="type">int</span>,tree[maxn];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">  <span class="type">int</span> id;<span class="comment">//初始位置</span></span><br><span class="line">  <span class="type">int</span> val;<span class="comment">//值</span></span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node &amp;a) <span class="type">const</span>&#123;<span class="comment">//升序排序</span></span><br><span class="line">    <span class="keyword">if</span>(val==a.val)</span><br><span class="line">    <span class="keyword">return</span> id&lt;a.id;<span class="comment">//让原顺序先出现（即逆序靠后出现）的相对值更小，防止离散后逆序遍历时错误地统计到相等值对</span></span><br><span class="line">    <span class="keyword">return</span> val&lt;a.val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;t[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_dandian</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=x;i&lt;=n;i+=<span class="built_in">lowbit</span>(i))</span><br><span class="line">  &#123;</span><br><span class="line">    tree[i]++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=x;i;i-=<span class="built_in">lowbit</span>(i))</span><br><span class="line">  &#123;</span><br><span class="line">    sum+=tree[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cin&gt;&gt;n;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">  &#123;</span><br><span class="line">     cin&gt;&gt;t[i].val;</span><br><span class="line">     t[i].id=i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(t+<span class="number">1</span>,t+<span class="number">1</span>+n);<span class="comment">//此时的数组t的每一个值从小到大排列</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">  &#123;</span><br><span class="line">    d[i]=t[i].id;<span class="comment">//d[i]表示第i大的数的id</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> sum=<span class="number">0</span>;<span class="comment">//开ll防爆</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;<span class="number">0</span>;--i)<span class="comment">//从后往前遍历，所以每一个数能找的都是比他大的数，那么找比每一个数的id还小的个数就好了，也就是tree[i]的前缀和(注意要去掉本身)</span></span><br><span class="line">   &#123;</span><br><span class="line">    sum+=<span class="built_in">search</span>(d[i]<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">add_dandian</span>(d[i]);</span><br><span class="line">   &#125;</span><br><span class="line">   cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>acm</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>主席树</title>
    <url>/2024/05/30/acm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%B8%BB%E5%B8%AD%E6%A0%91/</url>
    <content><![CDATA[<h1 id="主席树"><a href="#主席树" class="headerlink" title="主席树"></a>主席树</h1><h2 id="静态区间第k小"><a href="#静态区间第k小" class="headerlink" title="静态区间第k小"></a>静态区间第k小</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span>; <span class="comment">// 数据范围</span></span><br><span class="line"><span class="type">int</span> tot, n, m;</span><br><span class="line"><span class="type">int</span> sum[(maxn &lt;&lt; <span class="number">5</span>) + <span class="number">10</span>], rt[maxn + <span class="number">10</span>], ls[(maxn &lt;&lt; <span class="number">5</span>) + <span class="number">10</span>],</span><br><span class="line">    rs[(maxn &lt;&lt; <span class="number">5</span>) + <span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> a[maxn + <span class="number">10</span>], ind[maxn + <span class="number">10</span>], len;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getid</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;val)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 离散化</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lower_bound</span>(ind + <span class="number">1</span>, ind + len + <span class="number">1</span>, val) - ind;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 建树</span></span><br><span class="line">    <span class="type">int</span> root = ++tot;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    ls[root] = <span class="built_in">build</span>(l, mid);</span><br><span class="line">    rs[root] = <span class="built_in">build</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">return</span> root; <span class="comment">// 返回该子树的根节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">update</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> root)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 插入操作</span></span><br><span class="line">    <span class="type">int</span> dir = ++tot;</span><br><span class="line">    ls[dir] = ls[root], rs[dir] = rs[root], sum[dir] = sum[root] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">        <span class="keyword">return</span> dir;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= mid)</span><br><span class="line">        ls[dir] = <span class="built_in">update</span>(k, l, mid, ls[dir]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        rs[dir] = <span class="built_in">update</span>(k, mid + <span class="number">1</span>, r, rs[dir]);</span><br><span class="line">    <span class="keyword">return</span> dir;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 查询操作</span></span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>,</span><br><span class="line">        x = sum[ls[v]] - sum[ls[u]]; <span class="comment">// 通过区间减法得到左儿子中所存储的数值个数</span></span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= x) <span class="comment">// 若 k 小于等于 x ，则说明第 k 小的数字存储在在左儿子中</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(ls[u], ls[v], l, mid, k);</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 否则说明在右儿子中</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(rs[u], rs[v], mid + <span class="number">1</span>, r, k - x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line">    <span class="built_in">memcpy</span>(ind, a, <span class="keyword">sizeof</span> ind);</span><br><span class="line">    <span class="built_in">sort</span>(ind + <span class="number">1</span>, ind + n + <span class="number">1</span>);</span><br><span class="line">    len = <span class="built_in">unique</span>(ind + <span class="number">1</span>, ind + n + <span class="number">1</span>) - ind - <span class="number">1</span>;</span><br><span class="line">    rt[<span class="number">0</span>] = <span class="built_in">build</span>(<span class="number">1</span>, len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        rt[i] = <span class="built_in">update</span>(<span class="built_in">getid</span>(a[i]), <span class="number">1</span>, len, rt[i - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> l, r, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;l, &amp;r, &amp;k);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ind[<span class="built_in">query</span>(rt[l - <span class="number">1</span>], rt[r], <span class="number">1</span>, len, k)]); <span class="comment">// 回答询问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">work</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>acm</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>kmp</title>
    <url>/2024/05/30/acm/%E5%AD%97%E7%AC%A6%E4%B8%B2/kmp/</url>
    <content><![CDATA[<h1 id="kmp"><a href="#kmp" class="headerlink" title="kmp"></a>kmp</h1><blockquote>
<p>next数组，对于模式串的某一位置 j ， next[j] 的值是该模式串从下标0到j-1的子串最大相等前缀和后缀数</p>
</blockquote>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">s:       a b a a b c a b a</span><br><span class="line">index:   0 1 2 3 4 5 6 7 8</span><br><span class="line">next:	 -1 0 0 1 1 2 0 1 2</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">char</span> a[maxn];<span class="comment">//文本串</span></span><br><span class="line"><span class="type">char</span> b[maxn];<span class="comment">//模式串</span></span><br><span class="line"><span class="type">int</span> kmp_next[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_next</span><span class="params">(<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    kmp_next[<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//当这一位不匹配时，将j指向此为之前最大公共前后缀的位置</span></span><br><span class="line">        <span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;b[i]!=b[j])</span><br><span class="line">            j = kmp_next[j<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span> (b[i] == b[j])<span class="comment">//如果这一位匹配，那么将j+1，继续判断下一位</span></span><br><span class="line">            ++j;</span><br><span class="line">        kmp_next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到b在a中第一次出现的位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_pos</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">get_next</span>(m);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;a[i]!=b[j]) j=kmp_next[j<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span> (a[i] == b[j]) ++j;</span><br><span class="line">        <span class="keyword">if</span> (j == m)</span><br><span class="line">        &#123;</span><br><span class="line">            p = i - m + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回位置p的值</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到b在a中第k次出现的位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_num</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">get_next</span>(m);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;a[i]!=b[j]) j=kmp_next[j<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span> (a[i] == b[j]) ++j;</span><br><span class="line">        <span class="keyword">if</span> (j == m)</span><br><span class="line">            ++res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回数量</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>acm</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>st表</title>
    <url>/2024/05/30/acm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/st%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="st表"><a href="#st表" class="headerlink" title="st表"></a>st表</h1><blockquote>
<p>询问特定区间的最大&#x2F;最小值</p>
<p>先进行初始化，每次询问的复杂度为O(1)</p>
</blockquote>
<h2 id="询问区间的极差-最大值-最小值"><a href="#询问区间的极差-最大值-最小值" class="headerlink" title="询问区间的极差(最大值-最小值)"></a>询问区间的极差(最大值-最小值)</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Description: </span></span><br><span class="line"><span class="comment"> * @Author: CrayonXiaoxin</span></span><br><span class="line"><span class="comment"> * @Date: 2024-01-26 10:46:31</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2024-05-22 20:53:39</span></span><br><span class="line"><span class="comment"> * @LastEditors:  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">ll max_xy[maxn][<span class="number">22</span>], min_xy[maxn][<span class="number">22</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">st</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> s = <span class="built_in">log2</span>(r - l + <span class="number">1</span>), x, y;</span><br><span class="line">    x = <span class="built_in">max</span>(max_xy[l][s], max_xy[r - (<span class="number">1</span> &lt;&lt; s) + <span class="number">1</span>][s]);<span class="comment">//区间最大</span></span><br><span class="line">    y = <span class="built_in">min</span>(min_xy[l][s], min_xy[r - (<span class="number">1</span> &lt;&lt; s) + <span class="number">1</span>][s]);<span class="comment">//区间最小</span></span><br><span class="line">    <span class="keyword">return</span> x - y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; max_xy[i][<span class="number">0</span>];</span><br><span class="line">        min_xy[i][<span class="number">0</span>] = max_xy[i][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">21</span>;++i)<span class="comment">//这个循环的上界决定于数据的大小，即2的21次方大于数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k + (<span class="number">1</span> &lt;&lt; i) &lt;= n + <span class="number">1</span>;++k)</span><br><span class="line">        &#123;</span><br><span class="line">            max_xy[k][i] = <span class="built_in">max</span>(max_xy[k][i - <span class="number">1</span>], max_xy[k + (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>))][i - <span class="number">1</span>]);</span><br><span class="line">            min_xy[k][i] = <span class="built_in">min</span>(min_xy[k][i - <span class="number">1</span>], min_xy[k + (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>))][i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">st</span>(l, r) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//std::ios::sync_with_stdio(false);</span></span><br><span class="line"><span class="comment">//cin.tie(0);</span></span><br><span class="line"><span class="comment">//cout.tie(0);</span></span><br><span class="line"><span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//cin&gt;&gt;t;</span></span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>acm</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>z函数_扩展kmp</title>
    <url>/2024/05/30/acm/%E5%AD%97%E7%AC%A6%E4%B8%B2/z%E5%87%BD%E6%95%B0-%E6%89%A9%E5%B1%95kmp/</url>
    <content><![CDATA[<h1 id="z函数-扩展kmp"><a href="#z函数-扩展kmp" class="headerlink" title="z函数(扩展kmp)"></a>z函数(扩展kmp)</h1><blockquote>
<p>对于一个长度为 n 的字符串 s，定义函数 z[i] 表示 s 和 s[i,n-1]（即以s[i] 开头的后缀) 的最长公共前缀(LCP) ，则 z 被称为 s 的 z 函数。特别的，z[0] &#x3D; 0</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">z_function</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n = (<span class="type">int</span>)s.<span class="built_in">length</span>();</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">z</span><span class="params">(n)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, l = <span class="number">0</span>, r = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= r &amp;&amp; z[i - l] &lt; r - i + <span class="number">1</span>) &#123;</span><br><span class="line">      z[i] = z[i - l];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      z[i] = <span class="built_in">max</span>(<span class="number">0</span>, r - i + <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">while</span> (i + z[i] &lt; n &amp;&amp; s[z[i]] == s[i + z[i]]) ++z[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i + z[i] - <span class="number">1</span> &gt; r) l = i, r = i + z[i] - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符串整周期"><a href="#字符串整周期" class="headerlink" title="字符串整周期"></a>字符串整周期</h2><p>给定一个长度为 n  的字符串 <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="s">，找到其最短的整周期，即寻找一个最短的字符串 t ，使得 s  可以被若干个 t  拼接而成的字符串表示。</p>
<p>考虑计算 s  的 Z 函数，则其整周期的长度为最小的 n  的因数 i ，满足 i  + z[i] &#x3D; n。</p>
]]></content>
      <categories>
        <category>acm</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>线段树</title>
    <url>/2024/05/30/acm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    <content><![CDATA[<h1 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h1><h2 id="模板1"><a href="#模板1" class="headerlink" title="模板1"></a>模板1</h2><blockquote>
<p> 将某区间每个数加上k</p>
<p> 求出某区间每一个数的和</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line">ll n, m, a[maxn], t[maxn &lt;&lt; <span class="number">2</span>], tag[maxn &lt;&lt; <span class="number">2</span>]; <span class="comment">// t为节点数组，tag为懒标记数组</span></span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">ls</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt;&lt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">rs</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(ll p)</span> <span class="comment">// 更新当前节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t[p] = t[<span class="built_in">ls</span>(p)] + t[<span class="built_in">rs</span>(p)];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(ll p, ll l, ll r, ll k)</span> <span class="comment">// 修改</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tag[p] = tag[p] + k;</span><br><span class="line">    t[p] = t[p] + k * (r - l + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(ll p, ll l, ll r)</span> <span class="comment">// 向下一层更新</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">f</span>(<span class="built_in">ls</span>(p), l, mid, tag[p]);</span><br><span class="line">    <span class="built_in">f</span>(<span class="built_in">rs</span>(p), mid + <span class="number">1</span>, r, tag[p]);</span><br><span class="line">    tag[p] = <span class="number">0</span>; <span class="comment">// 懒标记清零</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build_tree</span><span class="params">(ll l, ll r, ll p)</span> <span class="comment">// 建树</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tag[p] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        t[p] = a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll mid = (l + r) &gt;&gt; <span class="number">1</span>; <span class="comment">// 中间分割点</span></span><br><span class="line">    <span class="built_in">build_tree</span>(l, mid, p &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">build_tree</span>(mid + <span class="number">1</span>, r, (p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">push_up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">nl,nr为要修改的区间</span></span><br><span class="line"><span class="comment">l,r为固定的区间</span></span><br><span class="line"><span class="comment">p为节点编号</span></span><br><span class="line"><span class="comment">k为修改的值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(ll nl, ll nr, ll l, ll r, ll p, ll k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nl &lt;= l &amp;&amp; r &lt;= nr)</span><br><span class="line">    &#123;</span><br><span class="line">        t[p] += k * (r - l + <span class="number">1</span>);</span><br><span class="line">        tag[p] += k;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">push_down</span>(p, l, r);</span><br><span class="line">    ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (nl &lt;= mid)</span><br><span class="line">        <span class="built_in">update</span>(nl, nr, l, mid, <span class="built_in">ls</span>(p), k);</span><br><span class="line">    <span class="keyword">if</span> (nr &gt; mid)</span><br><span class="line">        <span class="built_in">update</span>(nl, nr, mid + <span class="number">1</span>, r, <span class="built_in">rs</span>(p), k);</span><br><span class="line">    <span class="built_in">push_up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">ql,qr为询问区间</span></span><br><span class="line"><span class="comment">l,r为固定区间</span></span><br><span class="line"><span class="comment">p为节点编号</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll ql, ll qr, ll l, ll r, ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr)</span><br><span class="line">        <span class="keyword">return</span> t[p];</span><br><span class="line">    ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">push_down</span>(p, l, r); <span class="comment">// 更新下面一层的节点</span></span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= mid)</span><br><span class="line">        res += <span class="built_in">query</span>(ql, qr, l, mid, <span class="built_in">ls</span>(p));</span><br><span class="line">    <span class="keyword">if</span> (qr &gt; mid)</span><br><span class="line">        res += <span class="built_in">query</span>(ql, qr, mid + <span class="number">1</span>, r, <span class="built_in">rs</span>(p));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">build_tree</span>(<span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        ll ope;</span><br><span class="line">        cin &gt;&gt; ope;</span><br><span class="line">        <span class="keyword">if</span> (ope == <span class="number">1</span>) <span class="comment">// 修改[l,r]的每个值加上k</span></span><br><span class="line">        &#123;</span><br><span class="line">            ll l, r, k;</span><br><span class="line">            cin &gt;&gt; l &gt;&gt; r &gt;&gt; k;</span><br><span class="line">            <span class="built_in">update</span>(l, r, <span class="number">1</span>, n, <span class="number">1</span>, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ll l, r;</span><br><span class="line">            cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">query</span>(l, r, <span class="number">1</span>, n, <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// std::ios::sync_with_stdio(false);</span></span><br><span class="line">    <span class="comment">// cin.tie(0);</span></span><br><span class="line">    <span class="comment">// cout.tie(0);</span></span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="模板2"><a href="#模板2" class="headerlink" title="模板2"></a>模板2</h2><blockquote>
<p>将某区间每一个数乘上x</p>
<p>将某区间每一个数加上x</p>
<p>求某区间每一个数的和</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span>;</span><br><span class="line">ll n, q, m, a[maxn];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">nopde</span></span><br><span class="line">&#123;</span><br><span class="line">    ll v, mul, add; <span class="comment">// mul,add都是标记</span></span><br><span class="line">&#125; t[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">ls</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt;&lt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">rs</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t[p].v = (t[<span class="built_in">ls</span>(p)].v + t[<span class="built_in">rs</span>(p)].v) % mod;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build_tree</span><span class="params">(ll l, ll r, ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t[p].mul = <span class="number">1</span>;</span><br><span class="line">    t[p].add = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        t[p].v = a[l] % mod;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build_tree</span>(l, mid, <span class="built_in">ls</span>(p));</span><br><span class="line">    <span class="built_in">build_tree</span>(mid + <span class="number">1</span>, r, <span class="built_in">rs</span>(p));</span><br><span class="line">    <span class="built_in">push_up</span>(p);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">维护lazytag</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(ll l, ll r, ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 儿子的值=此刻儿子的值*爸爸的乘法lazytag+儿子的区间长度*爸爸的加法lazytag</span></span><br><span class="line">    t[<span class="built_in">ls</span>(p)].v = (t[<span class="built_in">ls</span>(p)].v * t[p].mul + t[p].add * (mid - l + <span class="number">1</span>)) % mod;</span><br><span class="line">    t[<span class="built_in">rs</span>(p)].v = (t[<span class="built_in">rs</span>(p)].v * t[p].mul + t[p].add * (r - mid)) % mod;</span><br><span class="line">    <span class="comment">// 维护lazytag</span></span><br><span class="line">    t[<span class="built_in">ls</span>(p)].mul = (t[<span class="built_in">ls</span>(p)].mul * t[p].mul) % mod;</span><br><span class="line">    t[<span class="built_in">rs</span>(p)].mul = (t[<span class="built_in">rs</span>(p)].mul * t[p].mul) % mod;</span><br><span class="line">    t[<span class="built_in">ls</span>(p)].add = (t[<span class="built_in">ls</span>(p)].add * t[p].mul + t[p].add) % mod;</span><br><span class="line">    t[<span class="built_in">rs</span>(p)].add = (t[<span class="built_in">rs</span>(p)].add * t[p].mul + t[p].add) % mod;</span><br><span class="line">    <span class="comment">// 初始化父节点</span></span><br><span class="line">    t[p].mul = <span class="number">1</span>;</span><br><span class="line">    t[p].add = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//乘上k</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mul</span><span class="params">(ll ml, ll mr, ll l, ll r, ll p, ll k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mr &lt; l || r &lt; ml)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (ml &lt;= l &amp;&amp; r &lt;= mr)</span><br><span class="line">    &#123;</span><br><span class="line">        t[p].v = (t[p].v * k) % mod;</span><br><span class="line">        t[p].mul = (t[p].mul * k) % mod;</span><br><span class="line">        t[p].add = (t[p].add * k) % mod;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 先传递lazytag</span></span><br><span class="line">    <span class="built_in">push_down</span>(l, r, p);</span><br><span class="line">    ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">mul</span>(ml, mr, l, mid, <span class="built_in">ls</span>(p), k);</span><br><span class="line">    <span class="built_in">mul</span>(ml, mr, mid + <span class="number">1</span>, r, <span class="built_in">rs</span>(p), k);</span><br><span class="line">    <span class="built_in">push_up</span>(p);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加上k</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(ll al, ll ar, ll l, ll r, ll p, ll k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ar &lt; l || r &lt; al)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (al &lt;= l &amp;&amp; r &lt;= ar)</span><br><span class="line">    &#123;</span><br><span class="line">        t[p].v = (t[p].v + k * (r - l + <span class="number">1</span>)) % mod;</span><br><span class="line">        t[p].add = (t[p].add + k) % mod;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 先传递lazytag</span></span><br><span class="line">    <span class="built_in">push_down</span>(l, r, p);</span><br><span class="line">    ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">add</span>(al, ar, l, mid, <span class="built_in">ls</span>(p), k);</span><br><span class="line">    <span class="built_in">add</span>(al, ar, mid + <span class="number">1</span>, r, <span class="built_in">rs</span>(p), k);</span><br><span class="line">    <span class="built_in">push_up</span>(p);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll ql, ll qr, ll l, ll r, ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (qr &lt; l || r &lt; ql)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr)</span><br><span class="line">        <span class="keyword">return</span> t[p].v;</span><br><span class="line">    <span class="built_in">push_down</span>(l, r, p);</span><br><span class="line">    ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">query</span>(ql, qr, l, mid, <span class="built_in">ls</span>(p)) + <span class="built_in">query</span>(ql, qr, mid + <span class="number">1</span>, r, <span class="built_in">rs</span>(p))) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">build_tree</span>(<span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> ope;</span><br><span class="line">        cin &gt;&gt; ope;</span><br><span class="line">        <span class="keyword">if</span> (ope == <span class="number">1</span>) <span class="comment">// 在[l,r]区间每个数都乘k</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l, r, k;</span><br><span class="line">            cin &gt;&gt; l &gt;&gt; r &gt;&gt; k;</span><br><span class="line">            <span class="built_in">mul</span>(l, r, <span class="number">1</span>, n, <span class="number">1</span>, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ope == <span class="number">2</span>) <span class="comment">// 在[l,r]区间每个数都加k</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l, r, k;</span><br><span class="line">            cin &gt;&gt; l &gt;&gt; r &gt;&gt; k;</span><br><span class="line">            <span class="built_in">add</span>(l, r, <span class="number">1</span>, n, <span class="number">1</span>, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 询问区间和</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l, r;</span><br><span class="line">            cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">query</span>(l, r, <span class="number">1</span>, n, <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// std::ios::sync_with_stdio(false);</span></span><br><span class="line">    <span class="comment">// cin.tie(0);</span></span><br><span class="line">    <span class="comment">// cout.tie(0);</span></span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="模板3"><a href="#模板3" class="headerlink" title="模板3"></a>模板3</h2><blockquote>
<p>将区间的所有值修改为x</p>
<p>求出区间和</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line">ll n, m, a[maxn], t[maxn &lt;&lt; <span class="number">2</span>], tag[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">ls</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt;&lt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">rs</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t[p] = t[<span class="built_in">ls</span>(p)] + t[<span class="built_in">rs</span>(p)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tag[p])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        t[<span class="built_in">ls</span>(p)] = tag[p] * (mid - l + <span class="number">1</span>);</span><br><span class="line">        t[<span class="built_in">rs</span>(p)] = tag[p] * (r - mid);</span><br><span class="line">        tag[<span class="built_in">ls</span>(p)] = tag[p];</span><br><span class="line">        tag[(<span class="built_in">rs</span>(p))] = tag[p];</span><br><span class="line">        tag[p] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build_tree</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        t[p] = a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build_tree</span>(l, mid, <span class="built_in">ls</span>(p));</span><br><span class="line">    <span class="built_in">build_tree</span>(mid + <span class="number">1</span>, r, <span class="built_in">rs</span>(p));</span><br><span class="line">    <span class="built_in">push_up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> ul, <span class="type">int</span> ur, <span class="type">int</span> p, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ul &lt;= l &amp;&amp; r &lt;= ur)</span><br><span class="line">    &#123;</span><br><span class="line">        t[p] = k * (r - l + <span class="number">1</span>);</span><br><span class="line">        tag[p] = k;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tag[p])</span><br><span class="line">        <span class="built_in">push_down</span>(l, r, p);</span><br><span class="line">    ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (ul &lt;= mid)</span><br><span class="line">        <span class="built_in">update</span>(l, mid, ul, ur, <span class="built_in">ls</span>(p), k);</span><br><span class="line">    <span class="keyword">if</span> (ur &gt; mid)</span><br><span class="line">        <span class="built_in">update</span>(mid + <span class="number">1</span>, r, ul, ur, <span class="built_in">rs</span>(p), k);</span><br><span class="line">    <span class="built_in">push_up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> ql, <span class="type">int</span> qr, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr)</span><br><span class="line">        <span class="keyword">return</span> t[p];</span><br><span class="line">    <span class="keyword">if</span> (tag[p])</span><br><span class="line">        <span class="built_in">push_down</span>(l, r, p);</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= mid)</span><br><span class="line">        sum += <span class="built_in">query</span>(l, mid, ql, qr, <span class="built_in">ls</span>(p));</span><br><span class="line">    <span class="keyword">if</span> (qr &gt; mid)</span><br><span class="line">        sum += <span class="built_in">query</span>(mid + <span class="number">1</span>, r, ql, qr, <span class="built_in">rs</span>(p));</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">build_tree</span>(<span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> ope;</span><br><span class="line">        cin &gt;&gt; ope;</span><br><span class="line">        <span class="keyword">if</span>(ope==<span class="number">1</span>)<span class="comment">//将区间[l,r]的每个值修改为k</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l, r, k;</span><br><span class="line">            cin &gt;&gt; l &gt;&gt; r &gt;&gt; k;</span><br><span class="line">            <span class="built_in">update</span>(<span class="number">1</span>, n, l, r, <span class="number">1</span>, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//询问[l,r]的区间和</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l, r;</span><br><span class="line">            cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">query</span>(<span class="number">1</span>, n, l, r, <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// std::ios::sync_with_stdio(false);</span></span><br><span class="line">    <span class="comment">// cin.tie(0);</span></span><br><span class="line">    <span class="comment">// cout.tie(0);</span></span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>acm</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>块状数组</title>
    <url>/2024/05/30/acm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9D%97%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="块状数组"><a href="#块状数组" class="headerlink" title="块状数组"></a>块状数组</h1><blockquote>
<p>对整体数组进行分块执行</p>
<p>零散块暴力处理，适用于操作数较小时</p>
<p>对区间[l,r]的数加上k</p>
<p>询问[l,r]中有多少数大于c</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SQ = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">st[i]: 第i块的起始下标</span></span><br><span class="line"><span class="comment">ed[i]: 第i块的终止下标</span></span><br><span class="line"><span class="comment">size[i]: 第i块的长度</span></span><br><span class="line"><span class="comment">bel[i]: 下标为i的数据对应第几块</span></span><br><span class="line"><span class="comment">mark[i]: 第i块整块的修改值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> n, m, a[maxn], st[SQ], ed[SQ], size[SQ], bel[maxn], mark[SQ];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v[SQ]; <span class="comment">// 第i块的集合</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_block</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sq = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= sq; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        st[i] = n / sq * (i - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        ed[i] = n / sq * i;</span><br><span class="line">    &#125;</span><br><span class="line">    ed[sq] = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= sq; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = st[i]; j &lt;= ed[i]; ++j)</span><br><span class="line">            bel[j] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= sq; ++i)</span><br><span class="line">        size[i] = ed[i] - st[i] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> t)</span> <span class="comment">// 更新排序后的数组</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= size[t]; ++i)</span><br><span class="line">        v[t][i] = a[st[t] + i];</span><br><span class="line">    <span class="built_in">sort</span>(v[t].<span class="built_in">begin</span>(), v[t].<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="type">int</span> sq = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="built_in">init_block</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= sq; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = st[i]; j &lt;= ed[i]; ++j)</span><br><span class="line">            v[i].<span class="built_in">push_back</span>(a[j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= sq; ++i)</span><br><span class="line">        <span class="built_in">sort</span>(v[i].<span class="built_in">begin</span>(), v[i].<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l, r, k, ope;</span><br><span class="line">        cin &gt;&gt; ope &gt;&gt; l &gt;&gt; r &gt;&gt; k;</span><br><span class="line">        <span class="keyword">if</span> (ope == <span class="number">1</span>) <span class="comment">// 将[l,r]的每个数加上k</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (bel[l] == bel[r]) <span class="comment">// 同一块直接暴力</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= r; ++i)</span><br><span class="line">                    a[i] += k;</span><br><span class="line">                <span class="built_in">update</span>(bel[l]);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 零散块处理</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= ed[bel[l]]; ++i)</span><br><span class="line">                a[i] += k;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = st[bel[r]]; i &lt;= r; ++i)</span><br><span class="line">                a[i] += k;</span><br><span class="line">            <span class="built_in">update</span>(bel[l]);</span><br><span class="line">            <span class="built_in">update</span>(bel[r]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = bel[l] + <span class="number">1</span>; i &lt; bel[r]; ++i) <span class="comment">// 中间一大段的块直接打标记</span></span><br><span class="line">                mark[i] += k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//查找[l,r]中大于等于k的个数</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(bel[l]==bel[r])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= r;++i)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(a[i]+mark[bel[i]]&gt;=k)</span><br><span class="line">                        sum++;</span><br><span class="line">                &#125;</span><br><span class="line">                cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= ed[bel[l]];++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(a[i]+mark[bel[i]]&gt;=k)</span><br><span class="line">                    sum++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = st[bel[r]]; i &lt;= r;++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(a[i]+mark[bel[i]]&gt;=k)</span><br><span class="line">                    sum++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//二分查找k-mark[i]的位置</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = bel[l] + <span class="number">1</span>; i &lt; bel[r] - <span class="number">1</span>;++i)</span><br><span class="line">            &#123;</span><br><span class="line">                sum += v[i].<span class="built_in">end</span>() - <span class="built_in">lower_bound</span>(v[i].<span class="built_in">begin</span>(), v[i].<span class="built_in">end</span>(), k - mark[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// std::ios::sync_with_stdio(false);</span></span><br><span class="line">    <span class="comment">// cin.tie(0);</span></span><br><span class="line">    <span class="comment">// cout.tie(0);</span></span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>acm</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>分数规划</title>
    <url>/2024/05/30/acm/%E6%9D%82%E9%A1%B9/%E5%88%86%E6%95%B0%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h1 id="分数规划"><a href="#分数规划" class="headerlink" title="分数规划"></a>分数规划</h1><blockquote>
<p>每种物品有两个权值a和b，选出若干物品使得$\frac{\sum a}{\sum b}$最小&#x2F;最大</p>
</blockquote>
<h2 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h2><p><img src="C:\Users\Tomato\AppData\Roaming\Typora\typora-user-images\image-20240523145555458.png" alt="image-20240523145555458"></p>
]]></content>
      <categories>
        <category>acm</category>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>字典树</title>
    <url>/2024/05/30/acm/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%AD%97%E5%85%B8%E6%A0%91/</url>
    <content><![CDATA[<h1 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h1><p>用于统计，排序和保存大量的字符串（但不仅限于字符串,如01字典树）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000050</span>;</span><br><span class="line"><span class="type">int</span> trie[N][<span class="number">26</span>];<span class="comment">// 每个trie代表一条边，字典树其中1~N为边上方节点的编号，0代表root节点，1~26为连在i节点下方的26个字母。如果trie[i][x]=0,则代表字典树中目前没有这个点，而trie[i][x]的值代表这个点下方连有的点的编号</span></span><br><span class="line"><span class="type">int</span> cnt[N];</span><br><span class="line"><span class="type">int</span> id;<span class="comment">//节点编号</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(<span class="built_in">string</span> s)</span><span class="comment">//建树</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x = s[i] - <span class="string">&#x27;a&#x27;</span>;<span class="comment">//转化</span></span><br><span class="line">		<span class="keyword">if</span> (trie[p][x] == <span class="number">0</span>) trie[p][x] = ++id;<span class="comment">//等于0时不存在</span></span><br><span class="line">		p = trie[p][x];<span class="comment">//向下走</span></span><br><span class="line">	&#125;</span><br><span class="line">	cnt[p]++;<span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>  <span class="title function_">find</span><span class="params">(<span class="built_in">string</span> s)</span><span class="comment">//搜索</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">		<span class="keyword">if</span> (trie[p][x] == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//不存在</span></span><br><span class="line">		p = trie[p][x];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="检索字符串"><a href="#检索字符串" class="headerlink" title="检索字符串"></a>检索字符串</h2><p>如果是<strong>查询某个单词</strong>的话，我们用bool变量 v[i]表示节点i是否是单词结束的标志。 那么最后return的是v[root],所以在插入操作中插入完每个单词是，要对单词最后一个字母的v[i]置为true，其他的都是false</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  trie tree的储存方式：将字母储存在边上，边的节点连接与它相连的字母 </span></span><br><span class="line"><span class="comment">  trie[rt][x]=tot:rt是上个节点编号，x是字母，tot是下个节点编号 </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 2000010</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> tot=<span class="number">1</span>,n;</span><br><span class="line"><span class="type">int</span> trie[maxn][<span class="number">26</span>];</span><br><span class="line"><span class="comment">//bool isw[maxn];查询整个单词用</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">char</span> *s,<span class="type">int</span> rt)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;s[i];i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x=s[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(trie[rt][x]==<span class="number">0</span>)<span class="comment">//现在插入的字母在之前同一节点处未出现过 </span></span><br><span class="line">        &#123;</span><br><span class="line">            trie[rt][x]=++tot;<span class="comment">//字母插入一个新的位置，否则不做处理 </span></span><br><span class="line">        &#125;</span><br><span class="line">        rt=trie[rt][x];<span class="comment">//为下个字母的插入做准备  </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*isw[rt]=true;标志该单词末位字母的尾结点，在查询整个单词时用到*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">find</span><span class="params">(<span class="type">char</span> *s,<span class="type">int</span> rt)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;s[i];i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x=s[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(trie[rt][x]==<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//以rt为头结点的x字母不存在，返回0 </span></span><br><span class="line">        rt=trie[rt][x];<span class="comment">//为查询下个字母做准备 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//查询整个单词时，应该return isw[rt] </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> s[<span class="number">22</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    tot=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> rt=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">        insert(s,rt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">        <span class="keyword">if</span>(find(s,rt))<span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="查询前缀出现的次数"><a href="#查询前缀出现的次数" class="headerlink" title="查询前缀出现的次数"></a>查询<strong>前缀出现的次</strong>数</h2><p>开一个sum[]，表示位置i被访问过的次数，那么最后return的是sum[root]，插入操作中每访问一个节点，都要让他的sum++，这里前缀的次数是标记在前缀的最后一个字母所在位置的后一个位置上。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> trie[<span class="number">400001</span>][<span class="number">26</span>],len,root,tot,sum[<span class="number">400001</span>];</span><br><span class="line"><span class="type">bool</span> p;</span><br><span class="line"><span class="type">int</span> n,m; </span><br><span class="line"><span class="type">char</span> s[<span class="number">11</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    len=<span class="built_in">strlen</span>(s);</span><br><span class="line">    root=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> id=s[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!trie[root][id]) trie[root][id]=++tot;</span><br><span class="line">        sum[trie[root][id]]++;<span class="comment">//前缀保存 </span></span><br><span class="line">        root=trie[root][id];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">search</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    root=<span class="number">0</span>;</span><br><span class="line">    len=<span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> id=s[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!trie[root][id]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        root=trie[root][id];</span><br><span class="line">    &#125;<span class="comment">//root经过此循环后变成前缀最后一个字母所在位置</span></span><br><span class="line">    <span class="keyword">return</span> sum[root];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">        insert();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,search());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="维护异或极值"><a href="#维护异或极值" class="headerlink" title="维护异或极值"></a>维护异或极值</h2><p>将数的二进制表示看做一个字符串，就可以建出字符集为 {0,1} 的 trie 树。</p>
]]></content>
      <categories>
        <category>acm</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串操作</title>
    <url>/2024/05/30/acm/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cin:<span class="built_in">getline</span>(<span class="type">char</span> *,<span class="type">int</span> n);<span class="comment">//输入操作</span></span><br><span class="line"></span><br><span class="line">* <span class="built_in">strlen</span>(str);<span class="comment">//计算字符串长度</span></span><br><span class="line"></span><br><span class="line">* <span class="built_in">strcpy</span>(str1,str2);<span class="comment">//字符串赋值(将str2赋给str1)</span></span><br><span class="line"></span><br><span class="line">* <span class="built_in">strtok</span>(str,c)<span class="comment">//字符串分割函数(对字符串按照字字符串c(可以是单个字符)进行分割,返回分割后的子字符串)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">20</span>]=<span class="string">&quot;china,chinese&quot;</span>;</span><br><span class="line">    <span class="type">char</span> * token;<span class="comment">//返回值为指针</span></span><br><span class="line">    <span class="type">char</span> c[<span class="number">2</span>]=<span class="string">&#x27;,&#x27;</span>;</span><br><span class="line">    token=<span class="built_in">strtok</span>(str,c);</span><br><span class="line">    <span class="keyword">while</span>(token!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,token);</span><br><span class="line">        token = <span class="built_in">strtok</span>(<span class="literal">NULL</span>,c);<span class="comment">//继续分割</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//output</span></span><br><span class="line">    china</span><br><span class="line">    chinese</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">* <span class="built_in">strcat</span>(str1,str2);<span class="comment">//字符串拼接函数，将str2字符串拼接到str1字符串后(!!!str1定义长度，必须大于拼接后的字符串长度)</span></span><br><span class="line"></span><br><span class="line">* <span class="built_in">atoi</span>(str);<span class="comment">//将字符串str转为整形(支持正负数识别)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> a[<span class="number">10</span>]=<span class="string">&quot;100&quot;</span>;</span><br><span class="line">  <span class="type">int</span> val=<span class="built_in">atoi</span>(a);</span><br><span class="line">  cout&lt;&lt;val&lt;&lt;endl;</span><br><span class="line">   <span class="comment">//output</span></span><br><span class="line">   <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">* <span class="built_in">atof</span>(str);<span class="comment">//将字符串str转为浮点型(支持正负数识别)</span></span><br><span class="line"></span><br><span class="line">* <span class="built_in">atoi</span>()和<span class="built_in">atof</span>()有个缺点就是如果字符串是其他非数字字符，就会返回<span class="number">0</span>，如果是数字<span class="number">0</span>的话，照样返回<span class="number">0</span>，这样就无法识别到底是字符<span class="string">&#x27;0&#x27;</span>还是其他非数字字符。此时需要另一个函数:</span><br><span class="line"><span class="built_in">strtol</span>()<span class="comment">//字符串转整形</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">int</span> <span class="title">strtol</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*str,<span class="type">char</span> *endptr,<span class="type">int</span> base)</span></span>;<span class="comment">//将字符串str根据base转成对应进制数，并将转后结果作为函数结果返回；endptr指针指向原字符串中转化字符串的下一个字符</span></span><br><span class="line">   <span class="type">char</span> str[<span class="number">20</span>]=<span class="string">&quot;0&quot;</span>;</span><br><span class="line">   <span class="type">char</span> *endpty;</span><br><span class="line">   <span class="type">int</span> val;</span><br><span class="line">   val = <span class="built_in">strtol</span>(str,&amp;endpty,<span class="number">8</span>);<span class="comment">//这里的base为8，指的是将字符串中的数字作为进制去识别，转化为十进制输出，则有效识别数字为1~7，9为无效字符，则到9时停止</span></span><br><span class="line">   <span class="keyword">if</span>(endpty!=str)</span><br><span class="line">   &#123;</span><br><span class="line">	cout&lt;&lt;val&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;endpty&lt;&lt;endl;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;转化的是字符！&quot;</span>&lt;&lt;endl;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">//output</span></span><br><span class="line">    <span class="number">543</span></span><br><span class="line">    <span class="number">9</span>cend$<span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">* <span class="built_in">strcmp</span>(<span class="type">const</span> <span class="type">char</span>*s1,<span class="type">const</span> <span class="type">char</span>*s2)<span class="comment">//字符串比较，若s1==s2则返回0;若s1&lt;s2则返回负数;若s1&gt;s2则返回正数(两个字符串自左向右逐个字符比较(按ASCII值大小相比较)，直到出现不同的字符或遇到&#x27;\0&#x27;为止)</span></span><br><span class="line">    </span><br><span class="line">* <span class="built_in">strstr</span>(<span class="type">const</span> <span class="type">char</span>*s1,<span class="type">const</span> <span class="type">char</span>*s2);<span class="comment">//字符串查找，用于查找s2在s1中的位置。返回s1中第一次出现s2的指针；如果s2不是s1的一部分，则返回空指针。</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> s1[<span class="number">10</span>]=<span class="string">&quot;aabb&quot;</span>;</span><br><span class="line">    <span class="type">char</span> s2[<span class="number">10</span>]=<span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *value;</span><br><span class="line">    value=<span class="built_in">strstr</span>(s1,s2);</span><br><span class="line">    <span class="keyword">if</span>(value!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;value&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;找不到&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//output</span></span><br><span class="line">    abb</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*<span class="function"><span class="type">char</span> * <span class="title">strerror</span><span class="params">(<span class="type">int</span> errnum)</span></span>;<span class="comment">//用于获取指向错误消息字符串的指针。返回值为char*类型；</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>acm</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>普通莫队算法</title>
    <url>/2024/05/30/acm/%E6%9D%82%E9%A1%B9/%E6%99%AE%E9%80%9A%E8%8E%AB%E9%98%9F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="普通莫队算法"><a href="#普通莫队算法" class="headerlink" title="普通莫队算法"></a>普通莫队算法</h1><blockquote>
<p>有一个长度为n的序列${c_i}$,现在给出m个询问，每次给出两个数l，r，从编号在l到r之间的数中随机选出两个不同的数，求两个数相等的概率</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">50005</span>;</span><br><span class="line"><span class="type">int</span> n, m, maxn;</span><br><span class="line"><span class="type">int</span> c[N];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> sum;</span><br><span class="line"><span class="type">int</span> cnt[N];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans1[N], ans2[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">query</span> &#123;</span><br><span class="line">  <span class="type">int</span> l, r, id;</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> query &amp;x) <span class="type">const</span> &#123;  <span class="comment">// 重载&lt;运算符</span></span><br><span class="line">    <span class="keyword">if</span> (l / maxn != x.l / maxn) <span class="keyword">return</span> l &lt; x.l;</span><br><span class="line">    <span class="keyword">return</span> (l / maxn) &amp; <span class="number">1</span> ? r &lt; x.r : r &gt; x.r;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">  sum += cnt[i];</span><br><span class="line">  cnt[i]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">  cnt[i]--;</span><br><span class="line">  sum -= cnt[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">gcd</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a, <span class="type">long</span> <span class="type">long</span> b)</span> </span>&#123; <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  maxn = <span class="built_in">sqrt</span>(n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;c[i]);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a[i].l, &amp;a[i].r), a[i].id = i;</span><br><span class="line">  <span class="built_in">sort</span>(a, a + m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, l = <span class="number">1</span>, r = <span class="number">0</span>; i &lt; m; i++) &#123;  <span class="comment">// 具体实现</span></span><br><span class="line">    <span class="keyword">if</span> (a[i].l == a[i].r) &#123;</span><br><span class="line">      ans1[a[i].id] = <span class="number">0</span>, ans2[a[i].id] = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (l &gt; a[i].l) <span class="built_in">add</span>(c[--l]);</span><br><span class="line">    <span class="keyword">while</span> (r &lt; a[i].r) <span class="built_in">add</span>(c[++r]);</span><br><span class="line">    <span class="keyword">while</span> (l &lt; a[i].l) <span class="built_in">del</span>(c[l++]);</span><br><span class="line">    <span class="keyword">while</span> (r &gt; a[i].r) <span class="built_in">del</span>(c[r--]);</span><br><span class="line">    ans1[a[i].id] = sum;</span><br><span class="line">    ans2[a[i].id] = (<span class="type">long</span> <span class="type">long</span>)(r - l + <span class="number">1</span>) * (r - l) / <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ans1[i] != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="type">long</span> <span class="type">long</span> g = <span class="built_in">gcd</span>(ans1[i], ans2[i]);</span><br><span class="line">      ans1[i] /= g, ans2[i] /= g;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">      ans2[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld/%lld\n&quot;</span>, ans1[i], ans2[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>acm</category>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>希尔排序</title>
    <url>/2024/05/30/acm/%E5%9F%BA%E7%A1%80/%E6%8E%92%E5%BA%8F/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><blockquote>
<p>先将整个待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: CrayonXiaoxin</span></span><br><span class="line"><span class="comment"> * @Date: 2023-12-13 20:31:58</span></span><br><span class="line"><span class="comment"> * @LastEditors: Do not edit</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2023-12-20 19:37:55</span></span><br><span class="line"><span class="comment"> * @FilePath: \c++\code\C.cpp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[maxn];</span><br><span class="line"><span class="type">void</span> <span class="title function_">solve</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n;++i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    <span class="type">int</span> gap = n;</span><br><span class="line">    <span class="keyword">while</span>(gap &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        gap /= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - gap;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> end = i;</span><br><span class="line">            <span class="type">int</span> tem = a[end + gap];</span><br><span class="line">            <span class="keyword">while</span>(end&gt;=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(tem&gt;a[end])</span><br><span class="line">                &#123;</span><br><span class="line">                    a[end + gap] = a[end];</span><br><span class="line">                    end -= gap;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            a[end + gap] = tem;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>;++i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a[n - <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        solve();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>acm</category>
        <category>基础</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串哈希</title>
    <url>/2024/05/30/acm/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/</url>
    <content><![CDATA[<h1 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h1><blockquote>
<p>快速判断两个字符串是否相等</p>
<p>遇见不定长问题可以通过</p>
</blockquote>
<h2 id="单hash"><a href="#单hash" class="headerlink" title="单hash"></a>单hash</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line">ull hash_[maxn], xp[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    xp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= maxn; ++i)</span><br><span class="line">        xp[i] = xp[i - <span class="number">1</span>] * <span class="number">13331</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">make_hash</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len = s.<span class="built_in">length</span>();</span><br><span class="line">    hash_[len] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        hash_[i] = hash_[i + <span class="number">1</span>] * <span class="number">13331</span> + s[i] - <span class="string">&#x27;A&#x27;</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ull <span class="title">get_hash</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> len)</span> <span class="comment">// 得到起点为l,长度为len的子串的哈希值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hash_[l] - hash_[l + len] * xp[len];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="hash的应用"><a href="#hash的应用" class="headerlink" title="hash的应用"></a>hash的应用</h2><ul>
<li><p>字符串匹配</p>
</li>
<li><p>允许k次失配的字符串匹配</p>
<ul>
<li>给定定长为n的源串s，以及长度为m的模式串p，要求查找源串中有多少字串与模式串匹配；s与p匹配，当且仅当s与p长度相同，且最多有k个位置字符不同</li>
<li>哈希+二分</li>
</ul>
</li>
<li><p>最长公共子字符串</p>
<ul>
<li>给定 m 个总长不超过 n 的非空字符串，查找所有字符串的最长公共子字符串，如果有多个，任意输出其中一个。</li>
<li>很显然如果存在长度为 k 的最长公共子字符串，那么 k-1 的公共子字符串也必定存在。因此我们可以二分最长公共子字符串的长度。假设现在的长度为 k ，<code>check(k)</code> 的逻辑为我们将所有所有字符串的长度为 k  的子串分别进行哈希，将哈希值放入 n 个哈希表中存储。之后求交集即可。</li>
</ul>
</li>
<li><p>最长回文子串</p>
<ul>
<li>二分答案</li>
</ul>
</li>
<li><p>确定字符串中不同子字符串的数量</p>
<ul>
<li></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>acm</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>归并排序</title>
    <url>/2024/05/30/acm/%E5%9F%BA%E7%A1%80/%E6%8E%92%E5%BA%8F/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><blockquote>
<ul>
<li>将待排序的线性表不断地切分成若干个子表，直到每个子表只包含一个元素，这时，可以认为只包含一个元素的子表是有序表。</li>
<li>将子表两两合并，每合并一次，就会产生一个新的且更长的有序表，重复这一步骤，直到最后只剩下一个子表，这个子表就是排好序的线性表。</li>
<li><strong>O(nlogn)</strong></li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType_I int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(ElemType_I A[], ElemType_I left, ElemType_I mid, ElemType_I right)</span>             <span class="comment">//合并</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ElemType_I *B = <span class="keyword">new</span> ElemType_I[right - left + <span class="number">1</span>];                                     <span class="comment">//申请辅助数组</span></span><br><span class="line">	ElemType_I i = left;</span><br><span class="line">	ElemType_I j = mid + <span class="number">1</span>;</span><br><span class="line">	ElemType_I k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right)</span><br><span class="line">		<span class="keyword">if</span> (A[i] &lt;= A[j])</span><br><span class="line">			B[k++] = A[i++];</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			B[k++] = A[j++];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (i &lt;= mid)</span><br><span class="line">		B[k++] = A[i++];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (j &lt;= right)</span><br><span class="line">		B[k++] = A[j++];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = left, k = <span class="number">0</span>; i &lt;= right; i++)</span><br><span class="line">		A[i] = B[k++];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span>[] B;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(ElemType_I A[], ElemType_I left, ElemType_I right)</span>                             <span class="comment">//递归形式的归并排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (left &lt; right)</span><br><span class="line">	&#123;</span><br><span class="line">		ElemType_I mid;</span><br><span class="line">		mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">		<span class="built_in">MergeSort</span>(A, left, mid);</span><br><span class="line">		<span class="built_in">MergeSort</span>(A, mid + <span class="number">1</span>, right);</span><br><span class="line">		<span class="built_in">Merge</span>(A, left, mid, right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ElemType_I n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	ElemType_I *A = <span class="keyword">new</span> ElemType_I[n];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		cin &gt;&gt; A[i];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">MergeSort</span>(A, <span class="number">0</span>, n - <span class="number">1</span>);                                          <span class="comment">//调用归并排序              </span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		cout &lt;&lt; A[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//system(&quot;pause&quot;);                                                        //输出暂停，头文件&lt;cstdlib&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>acm</category>
        <category>基础</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>直插排序</title>
    <url>/2024/05/30/acm/%E5%9F%BA%E7%A1%80/%E6%8E%92%E5%BA%8F/%E7%9B%B4%E6%8F%92%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: CrayonXiaoxin</span></span><br><span class="line"><span class="comment"> * @Date: 2023-12-13 20:31:58</span></span><br><span class="line"><span class="comment"> * @LastEditors: Do not edit</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2023-12-20 19:47:20</span></span><br><span class="line"><span class="comment"> * @FilePath: \c++\code\C.cpp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[maxn];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">void</span> <span class="title function_">solve</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n;++i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> tem = a[i];</span><br><span class="line">        <span class="type">int</span> now = i;</span><br><span class="line">        <span class="keyword">while</span>(now&gt;=<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[now<span class="number">-1</span>]&gt;tem)</span><br><span class="line">            &#123;</span><br><span class="line">                a[now] = a[now<span class="number">-1</span>];</span><br><span class="line">                now--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        a[now] = tem;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ios::sync_with_stdio(false);</span></span><br><span class="line">    <span class="comment">// cin.tie(0);</span></span><br><span class="line">    <span class="comment">// cout.tie(0);</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)</span><br><span class="line">        solve();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>acm</category>
        <category>基础</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>快排</title>
    <url>/2024/05/30/acm/%E5%9F%BA%E7%A1%80/%E6%8E%92%E5%BA%8F/%E5%BF%AB%E6%8E%92/</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: CrayonXiaoxin</span></span><br><span class="line"><span class="comment"> * @Date: 2023-12-13 20:31:58</span></span><br><span class="line"><span class="comment"> * @LastEditors: Do not edit</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2023-12-27 19:35:29</span></span><br><span class="line"><span class="comment"> * @FilePath: \c++\code\C.cpp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[maxn];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> temp = a[left];</span><br><span class="line">    <span class="type">int</span> i = left;</span><br><span class="line">    <span class="type">int</span> j = right;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (a[j] &gt;= temp &amp;&amp; i &lt; j)</span><br><span class="line">        &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(a[i], a[j]);</span><br><span class="line">        <span class="keyword">while</span> (a[i] &lt;= temp &amp;&amp; i &lt; j)</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(a[i], a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="built_in">quickSort</span>(left, i - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">quickSort</span>(i + <span class="number">1</span>, right);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">quickSort</span>(<span class="number">1</span>, n);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>acm</category>
        <category>基础</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>博弈论</title>
    <url>/2024/05/30/acm/%E6%9D%82%E9%A1%B9/%E5%8D%9A%E5%BC%88%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="博弈论"><a href="#博弈论" class="headerlink" title="博弈论"></a>博弈论</h1><h2 id="公平组合游戏"><a href="#公平组合游戏" class="headerlink" title="公平组合游戏"></a>公平组合游戏</h2><ul>
<li>由两名玩家交替行动</li>
<li>在游戏进程的任意时刻，可以执行的合法行动与轮到哪名玩家无关</li>
<li>游戏中的同一个状态不可能多次抵达，游戏以玩家无法行动为结束，且游戏一定会在有限步后以非平局结束</li>
</ul>
<h2 id="尼姆游戏"><a href="#尼姆游戏" class="headerlink" title="尼姆游戏"></a>尼姆游戏</h2><blockquote>
<p>给定 N堆物品，第 i 堆物品有 $a_i$个。两名玩家轮流行动，每次可以任选一堆，取走任意多个物品，可把一堆取光，但不能不取。取走最后一件物品者获胜。两人都采取最优策略，问先手是否必胜</p>
</blockquote>
<p>结论：定义 Nim 和为$a_1\oplus a_2\oplus a_3…\oplus a_n$,当且仅当 Nim和为 0 时，该状态为先手必败状态 否则该状态为先手必胜状态	</p>
<h2 id="巴什博弈"><a href="#巴什博弈" class="headerlink" title="巴什博弈"></a>巴什博弈</h2><blockquote>
<p>有 1 堆石子，总个数是 n ，两名玩家轮流在石子堆中拿石子，每次至少取 1 个，至多取 m 个。取走最后一个石子的玩家为胜者。判定先手和后手谁胜。</p>
</blockquote>
<p>结论： 若 <code>n%(m+1)==0</code> ，则先手获胜，否则后手获胜</p>
<h2 id="威佐夫博弈"><a href="#威佐夫博弈" class="headerlink" title="威佐夫博弈"></a>威佐夫博弈</h2><blockquote>
<p>有两堆石子，石子数可以不同。两人轮流取石子，每次可以在一堆中取，或者从两堆中取走相同个数的石子，数量不限，取走最后一个石头的人获胜。判定先手是否必胜。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b)</span><br><span class="line">        <span class="built_in">swap</span>(a, b);</span><br><span class="line">    <span class="type">int</span> ans = (b - a) * ((<span class="number">1.0</span> + <span class="built_in">sqrt</span>(<span class="number">5.0</span>)) / <span class="number">2.0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ans == a)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="斐波那契博弈"><a href="#斐波那契博弈" class="headerlink" title="斐波那契博弈"></a>斐波那契博弈</h2><blockquote>
<p>有一堆个数为 n ( n ≥ 2 ) n(n\ge 2)n(n≥2)的石子，游戏双方轮流取石子，规则如下：</p>
<p>先手不能在第一次把所有的石子取完，至少取 1 11 颗；</p>
<p>之后每次可以取的石子数至少为 1 11，至多为对手刚取的石子数的 2 22 倍。</p>
<p>约定取走最后一个石子的人为赢家，求必败态</p>
</blockquote>
<p>结论：先手必败，当且仅当石子数为斐波那契数</p>
<h2 id="SG函数"><a href="#SG函数" class="headerlink" title="SG函数"></a>SG函数</h2><h3 id="Mex运算"><a href="#Mex运算" class="headerlink" title="Mex运算"></a>Mex运算</h3><p>设 S 表示一个非负整数集合。定义 mex(S) 为求出不属于集合 S 的最小非负整数的运算。</p>
<h3 id="SG函数-1"><a href="#SG函数-1" class="headerlink" title="SG函数"></a>SG函数</h3><p>SG(终点) &#x3D; 0</p>
<p><img src="https://img-blog.csdnimg.cn/20210218211729494.png" alt="img"></p>
<p>若SG(x)   &#x3D; 0则为必败状态，若SG(x) !&#x3D; 0,则为必胜状态</p>
<ul>
<li>对于任意的局面，如果它的SG值为0，那么他的任何一个后继局面的SG值不为0</li>
<li>对于任意的局面，如果它的SG值不为0，那么她一定有一个后继局面的SG值为0</li>
</ul>
<h3 id="SG定理"><a href="#SG定理" class="headerlink" title="SG定理"></a>SG定理</h3><p>有一般胜利下的公平组合游戏都能转化成尼姆数表达的尼姆堆博弈，一个博弈的 尼姆值 定义为这个博弈的等价尼姆数，即：对于当前游戏 X ，它可以拆分成若干个子游戏 $x_1,x_2,x_3…x_n$，那么$SG(X) &#x3D; SG(X_1)\oplus SG(X_2)\oplus SG(X_3)\oplus …\oplus SG(X_N)$	</p>
<p>对于由 n nn 个有向图游戏组成的组合游戏 设它们的起点分别为$x_1,x_2,x_3…x_n$，那么仅当$SG(X_1)\oplus SG(X_2)\oplus SG(X_3)\oplus …\oplus SG(N) ！&#x3D; 0$时，这个游戏为先手必胜</p>
<h3 id="有向图游戏的和"><a href="#有向图游戏的和" class="headerlink" title="有向图游戏的和"></a>有向图游戏的和</h3><blockquote>
<p>设$G_1,G_2,…G_n$是 n 个有向图游戏。定义有向图游戏 G， 他的行动规则是任选某个有向图$G_i$，并在$G_i$上行动一步。G被称为有向图游戏</p>
</blockquote>
<p>有向图游戏的和的SG函数值等于它包含的各个子游戏SG函数值的异或和</p>
<p>$SG(G) &#x3D; SG(G_1)\oplus SG(G_2)\oplus SG(G_3)\oplus …\oplus SG(G_N)$</p>
<ul>
<li>有向图游戏的某个局面必胜，当且仅当该局面对应节点的SG函数值大于0</li>
<li>有向图游戏的某个局面必败，当且仅当该局面对应节点的SG函数值等于0</li>
</ul>
<h3 id="sample"><a href="#sample" class="headerlink" title="sample"></a>sample</h3><blockquote>
<p>给定n堆石子以及一个由k个不同正整数构成的数字<a href="https://so.csdn.net/so/search?q=%E9%9B%86%E5%90%88&spm=1001.2101.3001.7020">集合</a>S。现在有两位玩家轮流操作，每次操作可以从任意一堆石子中拿取石子，每次拿取的石子数量必须包含于集合S，最后无法进行操作的人视为失败。问如果两人都采用最优策略，先手是否必胜。</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200104104613957.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMwMjc3MjM5,size_16,color_FFFFFF,t_70" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> s[<span class="number">105</span>],f[<span class="number">10005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sg</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(f[x] != <span class="number">-1</span>)  <span class="keyword">return</span> f[x];</span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; S;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> sum = s[i];</span><br><span class="line">        <span class="keyword">if</span>(x &gt;= sum)    S.<span class="built_in">insert</span>(<span class="built_in">sg</span>(x - sum));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!S.<span class="built_in">count</span>(i)) <span class="keyword">return</span> f[x] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;m;<span class="comment">//m个数量选择</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;i++)    cin&gt;&gt;s[i];</span><br><span class="line">    cin&gt;&gt;n;<span class="comment">//n堆石子</span></span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">-1</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line">    <span class="type">int</span> x,res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        res ^= <span class="built_in">sg</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">if</span>(res) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span>    <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="SG游戏及其变形"><a href="#SG游戏及其变形" class="headerlink" title="SG游戏及其变形"></a>SG游戏及其变形</h2><h3 id="Anti-SG-游戏（走完最后一步者输）"><a href="#Anti-SG-游戏（走完最后一步者输）" class="headerlink" title="Anti-SG 游戏（走完最后一步者输）"></a>Anti-SG 游戏（走完最后一步者输）</h3><h4 id="Anti-Nim"><a href="#Anti-Nim" class="headerlink" title="Anti-Nim"></a>Anti-Nim</h4><blockquote>
<p>有 n 堆石子，两个人可以从任意一堆石子中拿任意多个石子(不能不拿)，拿走最后一个石子的人失败。问谁会胜利</p>
</blockquote>
<p>结论：先手必胜当且仅当</p>
<ul>
<li>所有堆的石子数都为 1且游戏的SG值为 0</li>
<li>有些堆的石子数大于 1且游戏的SG值不为 0</li>
</ul>
<h4 id="Anti-SG"><a href="#Anti-SG" class="headerlink" title="Anti-SG"></a>Anti-SG</h4><blockquote>
<p>决策集合为空的游戏者获胜，也可以理解将所有集合变为空的游戏者即为失败。</p>
<p>其余规则与普通的 SG 游戏相同。</p>
</blockquote>
<p>SJ定理：先手必胜当且仅当</p>
<ul>
<li><strong>游戏的 SG 函数值不为 0 且游戏中某个单一游戏的 SG 函数值大于 1</strong></li>
<li>**游戏的SG函数值为 0 且游戏中没有任意一个单一游戏的SG函数值大于 1 **</li>
</ul>
<h3 id="Multi-SG"><a href="#Multi-SG" class="headerlink" title="Multi-SG"></a>Multi-SG</h3><blockquote>
<p>可以将一堆石子分成多堆</p>
</blockquote>
<h4 id="Multi-Nim"><a href="#Multi-Nim" class="headerlink" title="Multi-Nim"></a>Multi-Nim</h4><blockquote>
<p>有 n 堆石子，两个人可以从任意一堆石子中拿任意多个石子（不能不拿）或者可以把一堆数量不少于 2石子堆分为两堆不为空的石子堆，没法拿的人失败。问谁会胜利。</p>
</blockquote>
<p>性质：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(x%<span class="number">4</span>==<span class="number">0</span>)</span><br><span class="line"><span class="built_in">SG</span>(x) = x<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(x%<span class="number">4</span>==<span class="number">1</span>||x%<span class="number">2</span>==<span class="number">2</span>)</span><br><span class="line"><span class="built_in">SG</span>(x)=x;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(x%<span class="number">4</span>==<span class="number">3</span>)</span><br><span class="line"><span class="built_in">SG</span>(x)=x+<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h4 id="Multi-SG-1"><a href="#Multi-SG-1" class="headerlink" title="Multi-SG"></a>Multi-SG</h4><blockquote>
<p>每次操作能将一个当前的单一游戏分为多个单一游戏，也就是将当前这个堆石子分为多堆石子的特殊游戏。</p>
</blockquote>
<h2 id="翻硬币游戏"><a href="#翻硬币游戏" class="headerlink" title="翻硬币游戏"></a>翻硬币游戏</h2><p>N 枚硬币排成一排，有的正面朝上，有的反面朝上。我们从左开始对硬币按1 到N 编号。</p>
<p>第一，游戏者根据某些约束翻硬币，但他所翻动的硬币中，<strong>最右边那个硬币的必须是从正面翻到反面</strong>。例如，只能翻3个硬币的情况，那么第三个硬币必须是从正面翻到反面。如果局面是正正反，那就不能翻硬币了，因为第三个是反的。</p>
<p>第二，谁不能翻谁输。</p>
<p>有这样的结论：局面的SG 值为局面中每个正面朝上的棋子单一存在时的SG 值的异或和。即一个有k个硬币朝上，朝上硬币位置分布在的翻硬币游戏中，<strong>SG值是等于k个独立的开始时只有一个硬币朝上的翻硬币游戏的SG值异或和</strong>。比如THHTTH这个游戏中，2号、3号、6号位是朝上的，它等价于TH、TTH、TTTTTH三个游戏和，即sg[THHTTH]&#x3D;sg[TH]⨁sg[TTH]⨁sg[TTTTTH]��[������]&#x3D;��[��]⨁��[���]⨁��[������].我们的重点就可以放在单个硬币朝上时的SG值的求法。</p>
<p><strong>约束条件一：每次只能翻一个硬币。</strong></p>
<p>一般规则中，所翻硬币的最右边必须是从正面翻到反面，因为这题是只能翻一个硬币，那么这个硬币就是最右边的硬币，所以，每次操作是挑选一个正面的硬币翻成背面。</p>
<p>对于任意一个正面的硬币，SG值为1。</p>
<p>有奇数个正面硬币，局面的SG值 &#x3D;&#x3D; 1，先手必胜，有偶数个正面硬币，局面的SG值 &#x3D;&#x3D; 0，先手必败</p>
<p><strong>约束条件二：每次能翻转一个或两个硬币。(不用连续)</strong></p>
<p>每个硬币的SG值为它的编号，初始编号为1，可以转化为<strong>NIM游戏</strong></p>
<p>如果对于一个局面，把正面硬币的SG值异或起来不等于0，既a1 ^ a2 ^ a3 ^ … ^ an &#x3D;&#x3D; x,</p>
<p>那么玩家必然可以通过翻转一个或两个硬币使得异或和为0<br>证明：不妨设x的二进制表示中最高一位1在第k位，那么在a1,a2,…,an中，必然有一个数ai，它的第k位是1，且ai’ &#x3D; ai ^ x&lt;ai，</p>
<p>如果 ai’ &#x3D;&#x3D; 0，意思就是说，把 ai 这个值从式子中去掉就可以了。对应游戏，就是把编号为ai’的正面硬币翻成背面就可以了。</p>
<p>如果ai’ !&#x3D;0，意思就是说，把 ai 这个值从式子中去掉后再在式子中加上ai’。对应游戏，去掉ai’就是把编号为ai的正面硬币翻成背面，加上ai’ ，如果编号为ai’ 的硬币是正面，我们就把它翻成背面，是背面就翻成正面，总之，就是翻转编号为ai’ 的硬币。</p>
<p><strong>约束条件三：每次必须连续翻转k个硬币。</strong></p>
<p>可以转化为<strong>巴什博弈</strong></p>
<p>我们计算的是个数为N的硬币中，当中最后一个硬币为正面朝上,的sg值。</p>
<p>当N&#x3D;&#x3D;1时。硬币为：正，先手必输，所以sg[1]&#x3D;0。</p>
<p>当N&#x3D;&#x3D;2时，硬币为：反正。先手必输，所以sg[2]&#x3D;0。</p>
<p>当N&#x3D;&#x3D;3时，硬币为：反反正，先手必胜。所以sg[3]&#x3D;1。</p>
<p>当N&#x3D;&#x3D;4时，硬币为：反反反正。先手操作后为：反正正反，子状态局面的SG&#x3D;0^1&#x3D;1，那么sg[4]&#x3D;0。</p>
<p>当N&#x3D;&#x3D;5时，硬币为：反反反反正。先手操作后为：反反正正反。子状态局面的SG&#x3D;1^0&#x3D;1。那么sg[5]&#x3D;0。</p>
<p>当N&#x3D;&#x3D;6时，硬币为：反反反反反正。先手操作后为：反反反正正反。子状态局面的SG&#x3D;0^0&#x3D;0。那么sg[6]&#x3D;1。</p>
<p>依据观察，能够知道:从编号为1开始，sg值为：001 001 001 001……</p>
<p>依据观察，能够知道，sg的形式为000…01 000…01，当中一小段0的个数为k-1。</p>
<p><strong>约束条件4：每次翻动一个硬币后。必须翻动其左侧三个硬币中的一个，即翻动第x个硬币后。必须选择x-1。x-2，x-3中的当中一个硬币进行翻动，除非x是小于等于3的。（Subtraction Games）</strong></p>
<p>还是可以转化为类似<strong>巴什博弈</strong>的模型</p>
<p>当N &#x3D;&#x3D; 1时，硬币为：正，先手必赢，所以sg[1]&#x3D;1。</p>
<p>当N &#x3D;&#x3D; 2时。硬币为：反正，先手必赢，由于先手能够翻成反反或正反。可能性为2。所以sg[2] &#x3D;&#x3D; 2。</p>
<p>当N &#x3D;&#x3D; 3时，硬币为：反反正，先手操作后能够为：反正</p>
<p>位置x：1 2 3 4 5 6 7 8 9 10 11 12 13 14…</p>
<p>sg[x]： 1 2 3 0 1 2 3 0 1 2 3 0 1 2…</p>
<p>这个与每次最多仅仅能取3个石子的取石子游戏的SG分布一样，相同还有相似的这类游戏，约束条件5也是一样。</p>
<p><strong>约束条件5：每次必须翻动两个硬币，并且这两个硬币的距离要在可行集S&#x3D;{1,2,3}中。硬币序号从0开始。(Twins游戏)</strong></p>
<p>当N &#x3D;&#x3D; 1时，硬币为：正，先手必输，所以sg[0]&#x3D;0。</p>
<p>当N &#x3D;&#x3D; 2时，硬币为：反正，先手必赢。所以sg[1]&#x3D;1。</p>
<p>当N &#x3D;&#x3D; 3时。硬币为：反反正。先手必赢，所以sg[2]&#x3D;2。</p>
<p>当N &#x3D;&#x3D; 4时，硬币为：反反反正，先手必赢，所以sg[3]&#x3D;3。</p>
<p>当N &#x3D;&#x3D; 5时。硬币为：反反反反正，先手必输，所以sg[4]&#x3D;0。</p>
<p>位置x：0 1 2 3 4 5 6 7 8 9 10 11 12 13 14…</p>
<p>sg[x]： 0 1 2 3 0 1 2 3 0 1 2 3 0 1 2…</p>
<p><strong>约束条件6：每次能够翻动一个、二个或三个硬币（Mock Turtles游戏）</strong></p>
<p>初始编号从0开始。</p>
<p>当N&#x3D;&#x3D;1时。硬币为：正，先手必胜，所以sg[0]&#x3D;1.</p>
<p>当N&#x3D;&#x3D;2时，硬币为：反正，先手必赢，先手操作后可能为：反反或正反，方案数为2，所以sg[1]&#x3D;2。</p>
<p>当N&#x3D;&#x3D;3时，硬币为：反反正。先手必赢，先手操作后可能为：反反反、反正反、正反正、正正反。方案数为4。所以sg[2]&#x3D;4。</p>
<p>位置x：0 1 2 3 4 5 6 7 8 9 10 11 12 13 14…</p>
<p>sg[x]： 1 2 4 7 8 11 13 14 16 19 21 22 25 26 28…</p>
<p>看上去sg值为2x或者2x+1。</p>
<p>下面引入一个概念：我们称一个非负整数为odious，当且仅当该数的二进制形式的1出现的次数是奇数，否则称作evil。</p>
<p>所以1，2，4，7是odious，因为它们的二进制形式是1,10,100,111。而0,3,5,6是evil，由于它们的二进制形式是0,11,101,110。</p>
<p>而上面那个表中。貌似sg值都是odious数。所以当2x为odious时，sg值是2x，当2x是evil时。sg值是2x+1.</p>
<p>这样怎么证明呢？我们会发现发现：</p>
<p> evil ^ evil &#x3D; odious ^ odious &#x3D; evil</p>
<p> evil ^ odious &#x3D; odious ^ evil &#x3D; odious</p>
<p>如果刚才的假说是成立的，我们想证明下一个sg值为下一个odious数。注意到我们总能够在第x位置翻转硬币到达sg为0的情况；通过翻转第x位置的硬币和两个其他硬币。我们能够移动到全部较小的evil数，由于每一个非零的evil数都能够由两个odious数异或得到。可是我们不能移动到下一个odious数，由于不论什么两个odious数的异或都是evil数。</p>
<p>假设在一个Mock Turtles游戏中的首正硬币位置x1,x2,…,xn是个P局面。即sg[x1]…sg[xn]&#x3D;0.那么无可置疑的是n必然是偶数，由于奇数个odious数的异或是odious数，不可能等于0。而由上面可知sg[x]是2x或者2x+1，sg[x]又是偶数个，那么x1 ^ x 2 ^ …^ xn &#x3D; 0。相反，假设x1 ^ x 2 ^ … ^ xn &#x3D; 0且n是偶数，那么sg[x1] ^ … ^ sg[xn]&#x3D;0。这个假设不太理解的话，我们能够先这么看下：2x在二进制其中相当于把x所有左移一位，然后补零，比方说2的二进制是10。那么4的二进制就是100。而2x+1在二进制其中相当于把x所有左移一位，然后补1，比方说2的二进制是10，5的二进制是101。如今看下sg[x1] ^ … ^ sg[xn]&#x3D;0，由于sg[x]是2x或者2x+1。所以式子中的2x+1必须是偶数个（由于2x的最后一位都是0,2x+1的最后一位都是1，要最后异或为0,2x+1必须出现偶数次），所以:MT游戏其中的P局面是拥有偶数堆石子的Nim游戏的P局面。</p>
<p><strong>其实只需要记住MT游戏中每个位置的sg为对应的odious数（2x或2x+1）即可</strong></p>
<p><strong>约束条件7：每次能够连续翻动随意个硬币，至少翻一个。（Ruler游戏）</strong></p>
<p>初始编号从1开始。</p>
<p>那么这个游戏的SG函数是g(n)&#x3D;mex{0,g(n-1),g(n-1) ^ g(n-2),…,g(n-1) ^ … ^ g(1)}</p>
<p>依据SG函数能够得到SG值表例如下：</p>
<p>位置x：1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16…</p>
<p>g(x): 1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 16…</p>
<p>所以sg值为x的因数其中2的能达到的最大次幂。比方14&#x3D;2 * 7，最大1次幂。即2；16&#x3D;2 * 2 * 2 * 2。最大4次幂，即16。</p>
<p>这个游戏成为尺子游戏是由于SG函数非常像尺子上的刻度。</p>
<p><strong>约束条件8：每次必须翻转4个对称的硬币，最左与最右的硬币都必须是从正翻到反。（开始的时候两端都是正面）（Grunt游戏）</strong></p>
<p>这是Grundy游戏的变种，初始编号从0开始。</p>
<p>当正硬币位置为0,1,2时是terminal局面，即 终结局面，sg值都是0。当正硬币位置n大于等于3的时候的局面能够通过翻0,x,n-x,n四个位置得到(当中x&lt;n&#x2F;2可保证胜利)。</p>
<p>这就像是把一堆石子分成两堆不同大小石子的游戏，也就是Grundy游戏。<br><strong>小结：</strong><br>遇到翻硬币问题，如果找不到现成的模型，可以尝试往现有的模型（如nim游戏、巴什博弈等转化），不行就暴力打表sg函数找规律即可</p>
<h2 id="无向图删边"><a href="#无向图删边" class="headerlink" title="无向图删边"></a>无向图删边</h2><h3 id="一、树的删边游戏"><a href="#一、树的删边游戏" class="headerlink" title="一、树的删边游戏"></a>一、树的删边游戏</h3><p>给出一棵有根树，两人轮流操作，每人每次可以选择一条边删去，不与根节点相连的部分将被移走。无法操作者输。</p>
<p><strong>结论：</strong>叶子节点的 SGSG 值为 00；中间节点的 SGSG 值为它的所有子节点的「SGSG 值加 11」的异或和。这样就可以推出根节点的 SGSG 值。<a href="https://img2020.cnblogs.com/blog/1859218/202012/1859218-20201221150704676-1599213390.png">证明</a>。</p>
<h3 id="二、POJ-3710-Christmas-Game"><a href="#二、POJ-3710-Christmas-Game" class="headerlink" title="二、POJ 3710 Christmas Game"></a>二、POJ 3710 Christmas Game</h3><h4 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h4><p>有 n 个局部连通的图，两人轮流操作，每人每次可以选择一条边删去，不与根节点相连的部分将被移走。无法操作者输。（图是通过从基础树上加一些边得到的，环与环之间无公共边，且只与基础树有一个公共点。）</p>
<h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>与「树的删边游戏」不同的在于图中 <strong>出现了环</strong>。所以环可以单独考虑。</p>
<p>分析环的性质：环保证不共用边，且只与基础树有一个公共点。因此所有的环都是从树中某一个点连出又连回同一个点的简单环。</p>
<ul>
<li><p>对于长度为奇数的环，去掉其中任意一条边后，剩下的两个链长度 <strong>同奇偶</strong>，异或之后的 SG 值不可能为奇数，并且可能为 00。所以进行 mex 运算后它的 SG 值为 11。</p>
</li>
<li><p>对于长度为奇数的环，去掉其中任意一条边后，剩下的两个链长度 <strong>不同奇偶</strong>，异或之后的 SG 值不可能为 0。所以进行 mex 运算后它的 SG 值为 0。实际上它并没有贡献。</p>
</li>
</ul>
<p>所以可以去掉所有的偶环，将所有的奇环变为长度为 1 的链，转化为「树的删边游戏」的模型。</p>
<p>算出每一棵树的 SG 值，再把所有根节点的 SG 值异或起来即可。</p>
<p>具体实现时，不需要做「将所有的奇环变为长度为 1 的链」的操作，只需考虑奇环的贡献。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> t,n,m,x,y,cnt,hd[N],to[N&lt;&lt;<span class="number">1</span>],nxt[N&lt;&lt;<span class="number">1</span>],top,s[N],sg[N],vis[N],ans;    <span class="comment">//vis=0: 未访问过  vis=1: 访问过且不是某个环上的点（不考虑树上的点）  vis=-1: 访问过且是某个环上的点 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    to[++cnt]=y,nxt[cnt]=hd[x],hd[x]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    s[++top]=x,vis[x]=<span class="number">1</span>,sg[x]=<span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> flag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=hd[x];i;i=nxt[i])&#123;</span><br><span class="line">        <span class="type">int</span> y=to[i];</span><br><span class="line">        <span class="keyword">if</span>(y==fa&amp;&amp;!flag)&#123;flag=<span class="number">1</span>;<span class="keyword">continue</span>;&#125;     <span class="comment">//第一次连向父节点 </span></span><br><span class="line">        <span class="keyword">if</span>(vis[y]==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">int</span> cnt=<span class="number">1</span>,now=x;</span><br><span class="line">            <span class="keyword">while</span>(now!=y) cnt++,vis[now]=<span class="number">-1</span>,now=s[--top];</span><br><span class="line">            <span class="keyword">if</span>(cnt&amp;<span class="number">1</span>) sg[y]^=<span class="number">1</span>;    <span class="comment">//奇环 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!vis[y])&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(y,x);</span><br><span class="line">            <span class="keyword">if</span>(~vis[y]) sg[x]^=(sg[y]+<span class="number">1</span>);    <span class="comment">//不在环上的才能更新 </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(~vis[x]) --top;    <span class="comment">//非环上的，及时出栈 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;t))&#123;</span><br><span class="line">        ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;m),cnt=top=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) hd[i]=vis[i]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">                <span class="built_in">add</span>(x,y),<span class="built_in">add</span>(y,x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>),ans^=sg[<span class="number">1</span>];    <span class="comment">//根节点的 SG 值异或起来 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(ans?<span class="string">&quot;Sally&quot;</span>:<span class="string">&quot;Harry&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>acm</category>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>选择排序</title>
    <url>/2024/05/30/acm/%E5%9F%BA%E7%A1%80/%E6%8E%92%E5%BA%8F/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><ul>
<li>从原始数组中选择最小的一个数据，将其和位于第一个位置的数据交换</li>
<li>不断重复</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 10</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Select_Sort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> n)</span>   <span class="comment">//arr为数据数组，n为数组长度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">		<span class="type">int</span> min = i;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[min] &gt; arr[j]) &#123;</span><br><span class="line">				min = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (min != i) &#123;</span><br><span class="line">			<span class="built_in">swap</span>(arr[i], arr[min]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> arr[N]= &#123; <span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span> &#125;;</span><br><span class="line">	<span class="built_in">Select_Sort</span>(arr, <span class="number">10</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>acm</category>
        <category>基础</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
</search>
